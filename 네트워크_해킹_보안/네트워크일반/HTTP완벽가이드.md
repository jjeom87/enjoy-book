# HTTP 완벽 가이드

## I. HTTP: 웹의 기초

### 1장 HTTP 개관

#### 1.1 HTTP: 인터넷의 멀티미디어 배달부
* HTTP는 신뢰성 있는 데이터 전송 프로토콜을 사용하기 때문에, 데이터가 지구 반대편에서 오더라도 전송 중 손상되거나 꼬이지 않음을 보장
* 사용자는 인터넷에서 얻은 정보가 손상된 게 아닌지 염려하지 않아도 됨
* 개발자는 인터넷의 결함이나 약점에 대한 걱정 없이 애플리케이션 고유의 기능을 구현하는 데 집중

#### 1.2 웹 클라이언트와 서버
* 웹 서버는 HTTP 프로토콜로 의사소통하기 때문에 보통 HTTP 서버라고 불림
* 웹 서버는 인터넷의 데이터를 저장하고, HTTP 클라이언트가 요청한 데이터를 제공

![웹 클라이언트와 웹 서버](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-1.png)

#### 1.3 리소스
* 웹 서버는 웹 리소스를 관리하고 제공
* 웹 리소스는 웹 콘텐츠의 원천 
* 가장 단순한 웹 리소스는 웹 서버 파일 시스템의 정적 파일
* 리소스는 반드시 정적 파일이어야 할 필요는 없음
* 리소스는 요청 에 따라 콘텐츠를 생산하는 프로그램이 될 수도 있음

![웹 리소스란 웹에 콘텐츠를 제 공하는 모든 것을 말한다](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-2.png)

##### 1.3.1 미디어 타입
* 인터넷은 수천 가지 데이터 타입을 다루기 때문에, HTTP는 웹에서 전송되는 객체 각각에 신중하게 MIME 타입이라는 데이터 포맷 라벨을 붙임
* MIME (Multipurpose Internet Mail Extensions, 다목적 인터넷 메일 확장)은 원래 각기 다른 전자메일 시스템 사이 에서 메시지가 오갈 때 겪는 문제점을 해결하기 위해 설계
* 웹 서버는 모든 HTIP 객체 데이터에 MIME 타입을 붙임
* 웹브라우저는 서버로부터 객체를 돌려받을 때, 다룰 수 있는 객체 인지 MIME 타입을 통해 확인
* MIME 타입은 사선(/)으로 구분된 주 타입(primary object type)과 부 타입(specific subtype)으로 이루어 진 문자열 라벨

##### 1.3.2 URI
* **서버 리소스 이름은 통합 자원 식별자(uniform resource identifier), 혹은 URI로 불림**
* **URI는 인터넷의 우편물 주소 같은 것으로, 정보 리소스를 고유하게 식별하고 위치를 지정할 수 있음**
* URI에는 두 가지가 있음 URL, URN

![URL은 프로토콜, 서버 , 리소스롤 명시한다](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-4.png)

##### 1.3.3 URI
* 통합 자원 지시자(uniform resource locator, URL)는 리소스 식별자의 가장 흔한 형태
* URL은 특정 서버의 한 리소스에 대한 구체적인 위치를 서술

| URL | 설명 |
| --- | --- |
| http://www.oreilly.com/index.html | 오라일리 출판사 홈페이지의 URL |
| http://www.yahoo.com/images/logo.gif | 야후! 웹 사이트 로고의 URL |
| http://www.joes-hardware.com/nventory-check.cgl?ltem=12731 | 물품 #12731의 재고가 있는지 확인하는 프로그램에 대한URL |
| ftp://joe:tools4u@ftp.joes-hardware.com/locking-pliers.gif | 비밀번호로 보호되는 FTP를 통해 locking-pliers.gif 이미지 파일에 접근하는 URL |

* URL은 세 부분으로 이루어진 표준 포맷을 따름
  * URL의 첫 번째 부분은 스킴(scheme)이라고 불리는데, 리소스에 접근하기 위해 사용되는 프로토콜을 서술
  * 두 번째 부분은 서버의 인터넷 주소를 제공
  * 마지막은 웹 서버의 리소스를 가리킴

##### 1.3.4 URN
* URN은 콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 위치에 영향 받지 않는 유일무이한 이름 역할
* 이 위치 독립적인 URN은 리소스를 여기저기로 옮기더 라도 문제없이 동작
* 리소스가 그 이름을 변하지 않게 유지하는 한, 여러 종류 의 네트워크 접속 프로토콜로 접근해도 문제없음
* URN은 여전히 실험 중인 상태고 아직 널리 채택되지 않음

#### 1.4 트랜잭션
* HTTP 트랜잭션은 요청 명령(클라이언트에서 서버로 보내는)과 응답 결과(서버가 클라이언트에게 돌려주는)로 구성

![HTTP 트랜잭션은 요청과 응답 메시지로 구성되 어 있다](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-5.png)

##### 1.4.1 메서드
* HTTP는 HTTP 메서드라고 불리는 여러 가지 종류의 요청 명령을 지원

| HTTP 메서드 | 설명 |
| --- | --- |
| GET | 서버에서 클라이언트로 지정한 리소스를 보내라. |
| PUT | 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장하라. |
| DELETE | 지정한 리소스를 서버에서 삭제하라. |
| POST | 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라. |
| HEAD | 지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보내라. |

##### 1.4.2 상태 코드
* 모든 HTTP 응답 메시지는 상태 코드와 함께 반환 

| HTTP 상태 코드 | 설명 |
| --- | --- |
| 200 | 좋다. 문서가 바르게 반환되었다. |
| 302 | 다시 보내라. 다른 곳에 가서 리소스를 가져가라. |
| 404 | 없음. 리소스를 찾을 수 없다. |

* HTTP는 각 숫자 상태 코드에 덱스트로 된 "사유 구절(reason phrase)"도 함께 보냄

##### 1.4.3 웹페이지는 여러 객체로 이루어질 수 있다.
* 페이지 레이아웃을 서술하는 HTML '뼈대'를 한 번의 트랜잭션으로 가져온 뒤, 첨부된 이미지, 그래픽 조각, 자바 애플릿 등을 가져오기 위해 추가로 HTTP 트랜책션들을 수행
* '웹페이지'는 보통 하나의 리소스가 아닌 리소스의 모음

#### 1.5 메시지
* HTTP 메시지는 단순한 줄 단위의 문자열
* 이진 형식이 아닌 일반 텍스트이기 때문에 사람이 읽고 쓰기 쉽움
* 웹 클라이언트에서 웹 서버로 보낸 HTTP 메시지를 요청 메시지
* 서버 에서 클라이 언트로 가는 메 시지는 응답 메시지

![HTTP 메시지는 단순한 줄 단위 텍스트로 구조를 갖고 있다](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-7.png)

* 시작줄
  * 메시지의 첫 줄은 시작줄로 요청이라면 무엇을 해야 하는지 응답이라면 무슨 일이 일어났는지 나타냄
* 헤더
  * 시작줄 다음에는 0개 이상의 헤더 필드가 이어짐
  * 각 헤더 필드는 쉬운 구문분석 을 위해 쌍점(:)으로 구분되어 있는 하나의 이름과 하나의 값으로 구성
  * 헤더 필드를 추가하려면 그저 한 줄을 더하기만 하면 됨
  * 헤더는 빈 줄로 끝남 
* 본문
  * 빈줄 다음에는 어떤 종류의 데이터든 들어갈 수 있는 메시지 본문이 필요에 따라 수 있음 
  * 요청의 본문은 웹 서버로 데이터를 실어 보내며, 응답의 본문은 클라이언트로 데이터를 반환 
  * 문자열이며 구조적인 시작줄이나 헤더와 달리, 본문은 임의의 이진 데이터를 포함할 수 있음(이미지, 비디오, 오디오 트랙, 응용 소프트웨어). 
  * 본문은 텍스트도 포함할 수 있음

##### 1.5.1 간단한 메세지의 예
![http;//www.joes-hardware.com/tools.html에 대한 GET 트랜잭션 의 예](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-8.png)

#### 1.6 TCP 커넥션

##### 1.6.1 TCP/IP
* HTTP는 애플리케이션 계층 프로토콜
* HTTP는 네트워크 통신의 핵심적인 세부사항에 대해서 신경 쓰지 않음
* TCP
  * 오류 없는 데이터 전송
  * 순서 에 맞는 전달 (데이터는 언제나 보낸 순서 대로 도착한다)
  * 조각나지 않는 데이터 스트림 (언제든 어떤 크기로든 보낼 수 있다)
* 인터넷 자체가 전 세계의 컴퓨터와 네트워크 장치들 사이에서 대중적으로 사용되는 TCP/IP에 기초
* TCP/IP는 TCP와 IP가 충을 이루는, 패킷 교환 네트워크 프로토콜의 집합
* TCP/IP는 각 네트워크와 하드웨어의 특성을 숨기고, 어떤 종류의 컴퓨터나 네트워크든 서로 신뢰성 있는 의사소통을 하게 해 줌
* TCP 커넥션이 맺어지면, 클라이언트와 서버 컴퓨터 간에 교환되는 메시지가 없어지거나, 손상되거나, 순서가 뒤바뀌어 수신되는 일은 결코 없음

![HTTP 네트워크 프로토콜 스택](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-9.png)

##### 1.6.2 접속, IP 주소 그리고 포트번호
* 인터넷 프로토콜 (Internet protocol, IP) 주소와 포트번호를 사용해 클라이 언트와 서버 사이 에 TCP/IP 커넥션을 맺어야 함
* IP 주소와 포트번호를 이용해 클라이언트는 TCP/IP로 쉽게 통신할 수 있음
* 순서
  * (a) 웹브라우저는 서버의 URL에서 호스트 명을 추출한다
  * (b) 웹브라우저는 서 버 의 호스트 명을 IP로 변환한다.
  * (c) 웹브라우저는 URL에서 포트번호(있다면)를 추출한다
  * (d) 웹브라우저는 웹 서버와 TCP 커넥션을 맺는다.
  * (e) 웹브라우저는 서 버 에 HTTP 요청을 보낸다.
  * (f) 서 버는 웹브라우저 에 HTTP 응답을 돌려준다.
  * (g) 커넥션이 닫히면, 웹브라우저는 문서를 보여준다.

![웹브라우저 연결의 기본적인 절차](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-10.png)

##### 1.6.3 텔넷(Telnet)을 이용한 실제 예제
* 텔넷 유틸리티는 당신의 키보드를 목적지의 TCP 포트로 연결해주고 출력 TCP 포트를 당신의 화면으로 연결
* 텔넷은 원격 터미널 세션을 위해 흔히 사용되지만 HTTP 서버를 포함한 일반적 인 TCP 서 버 에 연결하기 위해 사용 될 수 있음
* 텔넷은 직접 컴퓨터 의 포트로 TCP 커 넥션을 연결해서 그 포트로 글자를 타이핑해 넣을 수 있게 줌
* nc(netcat)는 HTTP를 포함한 UDP 혹은 TCP 기반의 트래픽을 조작하고 스크립트할 수 있게 해줌

#### 1.7 프로토콜 버전
* HTTP/0.9
  * 1991년의 HTTP 프로토타입은 HTTP/0.9로 알려짐
  * 이 프로토콜은 심각한 디자인 결함이 다수 있고 구식 클라이언트하고만 같이 사용할 수 있음
  * HTTP/0.9는 오직 GET 메서드만 지원하고, 멀티미디어 콘텐츠에 대한 MIME 타입이나, HTTP 헤더. 버전 번호는 지원하지 않음
  * HTTP/0.9는 원래 간단한 HTML 객체를 받아 오기 위해 만들어진 것
  * HTTP/0.9는 금방 HTTP/1.0으로 대체  
* HTTP/1.0 
  * HTTP/1.0은 버전번호, HTTP 헤더, 추가 메서드, 멀티미디어 객체 처리를 추가
  * HTTP가 상업적, 학술적으로 급성장하던 시기에 만들어진, 잘 동작하는 용례들의 모음에 가깝움
* HTTP/1.0+
  * 오래 지속되는 "keep-alive" 커넥션, 가상 호스팅 지원, 프락시 연결 지원을 포함해 많은 기능이 공식적이진 않지만 사실상의 표준으로 HTTP에 추가
* HTTP/1.1
  * HTTP/1.1은 HTTP 설계의 구조적 결함 교정, 두드러진 성능 최적화, 잘못된 기능 제거에 집중
  * HTTP/1.1은 더 복잡해진 웹 애플리케이션과 배포(1990년대 후반에 이미 쓰이고 있었다)를 지원
* HTTP/2.0
  * HTTP/2.0은, HTTP/1.1 성능 문제를 개선하기 위해 구글의 SPDY 프로토콜을 기반으로 설계가 진행 중인 프로토콜

#### 1.8 웹의 구성요소
* 프락시 :클라이언트와 서버 사이에 위치한 HTTP 중계자
* 캐시 :많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고
* 게이트웨이 : 다른 애플리케이션과 연결된 특별한 웹 서버
* 터널 : 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시
* 에이전트 : 자동화된 HTTP 요청을 만드는 준지능적 웹클라이언트

##### 1.8.1 프락시
* 프락시는 클라이언트와 서버 사이에 위치하여, 클라이언트의 모든 HTTP 요청을 받아 서버에 전달
* 프락시는 주로 보안을 위해 사용
* 모든 웹 트래픽 흐름 속에서 신뢰할 만한 중개자 역할함
* 프락시는 요청과 응답을 필터링

##### 1.8.2 캐시
* 웹캐시와 캐시 프락시는 자신을 거쳐 가는 문서들 중 자주 찾는 것의 사본을 저장해 두는, 특별한 종류의 HTTP 프락시 서버
* 클라이언트는 멀리 떨어진 웹 서버보다 근처의 캐시에서 훨씬 더 빨리 문서를 다운 받을 수 있음
* HTTP는, 캐시를 효율적으로 동작하게 하고 캐시된 콘텐츠를 최신 버전으로 유지하면서 동시에 프라이버시도 보호하기 위한 많은 기능을 정의

##### 1.8.3 게이트웨이
* 게이트웨이는 다른 서버들의 중개자로 동작하는 특별한 서버
* 게이트웨이는 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용
* HTTP/FTP 게이트웨이는 FTP URI에 대한 HTTP 요청을 받아들인 뒤, FTP 프로토콜을 이용해 문서를 가져옴
* 받아온 문서는 HTTP 메시지에 담겨 클라이언트에게 보냄

##### 1.8.4 터널
* 터널은 두 커넥션 사이에서 날(raw) 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션
* HTTP 터널은 주로 비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송해주기 위해 사용
* HTTP 터널을 활용하는 대표적인 예로, 암호화된 SSL 트래픽을 HTIP 커넥션으로 전송함으로써 웹 트래픽만 허용하는 사내 방화벽을 통과시키는 것

##### 1.8.5 에이전트
* 사용자 에이전트(혹은 그냥 에이전트)는 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램

#### 1.9 시작의 끝

#### 1.10 추가 정보

##### 1.10.1 HTTP 프로토콜에 대한 정보

##### 1.10.2 역사적 시각

##### 1.10.3 기타 월드 와이드 웹 정보

### 2장 URL과 리소스
* URL(Uniform Resource Locator)은 인터넷의 리소스틀 가리키는 표준이름

#### 2.1 인터넷의 리소스 탐색하기
* URL은 통합 자원 식별자(Uniform Resource Identifier) 혹은 URI라고 불리는 일반화된 부류의 부분집합
* URI는 두 가지 주요 부분집합인, URL과 URN으로 구성된 종합적인 개념
* HTIP 명세에서는 URI를 더 일반화된 개념의 리소스 식별자로 사용
* 실제로 HTTP 애플리케이션은 URL을 URI의 한 부분으로 취급
* URL을 사용하면 리소스를 일관된 방식으로 지칭할 수 있음

##### 2.1.1 URL이 있기 전 암흑의 시대
* URL은 애플리케이션이 리소스에 접근할 수 있는 방법을 제공
* URL은 당신과 브라우저에게 정보 찾는데 필요한 모든 것을 제공하며, 당신이 원하는 리소스가 어디에 위치하고 어떻게 가져오는지 정의

#### 2.2 URL 문법
* 대부분의 URL 스킴은 문법은 일반적으로 9개 부분으로 나뉨

```
<스킴>://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>
```

##### 2.2.1 스킴: 사용할 프로토콜
* URI을 해석하는 애플리케이션이 어떤 프로토콜을 사용하여 리소스를 요청해야 하는지 알려줌
* 스킴 컴포넌트는 알파벳으로 시작해야 하고 URL의 나머지 부분들과 첫 번째 ':' 문자로 구분

##### 2.2.2 호스트와 포트
* 호스트 컴포넌트는 접근하려고 하는 리소스를 가지고 있는 인터넷상의 호스트 장비
* 포트 컴포넌트는 서버가 열어놓은 네트워크 포트를 가리킴
* 내부적으로 TCP 프로토콜을 사용하는 HTTP는 기본 포트로 80을 사용

##### 2.2.3 사용자 이름과 비밀번호
* 서버가 자신이 가지고 있는 데이터에 접근을 허용하기 전에 사용자 이름과 비밀번호를 요구
* 예시
  * ftp://ftp.prep.ai.mit.edu/pub/gnu
  * ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu
  * ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu
  * http://jeo:joespasswd@www.joes-hardware.com/sales_info.txt

##### 2.2.4 경로
* URL의 경로 컴포넌트는 리소스가 서버의 어디에 있는지 알려줌

##### 2.2.5 파라미터
* URL을 사용하는 애플리케이션이 리소스에 접근하려면 프로토콜 파라미터가 필요

##### 2.2.6 질의 문자열
* URL의 질의 컴포넌트는 게이트웨이를 가리 키는 URL의 경로 컴포넌트와 함께 전달
* 편의상 많은 게이트웨이가 ‘&'로 나뉜 ‘이름=값' 쌍 형식의 질의 문자열을 원함

##### 2.2.7 프래그먼트
* URL은 리소스 내의 조각을 가리킬 수 있는 프래그먼트 컴포넌트를 제공
* 프래그먼트는 URL의 오른쪽에 # 문자에 이어서 옴

#### 2.3 단축 URL
* 상대 URL은 리소스 안에 있는 리소스를 간결하게 기술하는데 사용할 수 있음
* 많은 브라우저가 사용자가 기억하고 있는 URL 일부를 입력하면 나머지 부분을 자동으로 입 력해주는 URL '자동 확장'을 지원

##### 2.3.1 상대 URL
* URL은 상대 URL과 절대 URL 두 가지로 나뉨
* 절대 URL은 리소스에 접근하는데 필요한 모든 정보를 가지고 있음
* 상대 URL은 모든 정보를 담고 있지는 않음
* 상대 URL로 리소스에 접근하는데 필요한 모든 정보를 얻기 위해서는, 기저(base)라고 하는 다른 URI을 사용

![기지 URL의 사용](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_2-4.png)

* URL을 처리하는 브라우저 같은 애플리케이션은 상대 URL과 절대 URL 간에 상호 변환을 할 수 있어야 함
* 기저 URL 찾는 방법
  * 리소스에서 명시적으로 제공
  * 리소스를 포함하고 있는 기저 URL
  * 기저 URL이 없는 경우
  * 상대 참조 해석하기

![상대 URL을 절대 URL로 변환하기](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_2-5.png)

##### 2.3.2 URL 확장
* 호스트 명 확장
  * 호스트 명 확장 기능을 지 원하는 브라우저는 단순한 휴리스틱만을 사용해서 입력한 호스트 명을 전체 호스트 명으로 확장할 수 있음
  * 예를 들어 주소 입 력란에 'yahoo'를 입력하면, 브라우저는 호스트 명에 자동으로 'www,'와 '.com' 을 붙여서 'www.yahoo.com' 을 만듬
  * 어떤 브라우저는 'yahoo' 란 단어를 포함한 사이트를 찾지 못하면, 확장을 포기하기 전에 몇 가지의 URL을 추가로 제시
* 히스토리 확장
  * 사용자가 URL을 입 력하는 시간을 줄이고자, 브라우저가 사용하는 또 다른 기술은 과거 에 사용자가 방문했던 URL의 기록을 저장해 놓는 것
  * 프락시를 사용할 경우 URL 자동확장 기능은 다르게 동작할 수 있다는 것을 유념

#### 2.4 안전하지 않은 문자
* 안전한 전송이란, 정보가 유실될 위험 없이 URL을 전송할 수 있다는 것을 의미
* 전자메일에 시용되는 SMTP(Simple Mail Transfer Protocol)같은 프로토콜은 특정 문자를 제거할 수도 있는 전송 방식을 사용
* 이스케이프라는 기능을 추가하여, 안전하지 않은 문자를 안전한 문자로 인코딩할 수 있게 했음

##### 2.4.1 URL 문자 집합
* URL에 이스케이프 문자열을 쓸 수 있게 설계
* 이스케이프 문자열은 US-ASCll에서 사용이 금지된 문자들로, 특정 문자나 데이터를 인코딩할 수 있게 함으로써 이동성과 완성도를 높임

##### 2.4.2 인코딩 체계
* 인코딩은 안전하지 않은 문자를 퍼센티지 기호(%)로 시작해, ASCII 코드로 표현되는 두 개의 16진수 숫자로 이루어진 '이스케이프' 문자로 바꿈

| 문자 | ASCII코드| URL의 예 |
| --- | --- | --- |
| ~ | 126(0x7E) | http://www.joes-hardware.com/%7Ejoe |
| 빈문자 | 32(0x20) | http://www.joes-hardware.com/more%20tools.html |
| % | 37(0x25) | http://www.joes-hardware.com/100%25satisfaction.html |

##### 2.4.3 문자 제한
* 몇몇 문자는 URL 내에서 특별한 의미로 예약되어 있다. 어떤 문자는 US-ASCII의 출력 가능한 문자 집합에 포함되어 있지 않음

| 문자 | 선점 및 제한 |
| --- | --- |
| % | 인코딩된 문자에 사용할 이스케이프 토큰으로 선점 |
| / | 경로 컴포넌트에 있는 경로 세그먼트를 나누는 용도로 선점 |
| . | 경로 컴포넌트에서 선점 |
| .. | 경로 컴포넌트에서 선점 |
| # | 프래그먼트의 구획 문자로 선점 |
| ? | 질의 문자열의 구획 문자로 선점 |
| ; | 파라미터의 구획 문자로 선점 |
| : | 스킴 사용자 이름/비밀번호, 호스트/포트의 구획 문자로 선점 |
| $, + | 선점 |
| @ & = | 특정 스킴에서 특별한 의미가 있기 때문에 선점 |
| {} \| · \ ~ [] \` | 게이트웨이와 같은 여러 전송 에이전트에서 불안전하게 다루기 때문에 제한됨 |
| <> " | 안전하지 않음. 웹 문서에서 URL을 구분 지어 표시하듯이(예를 들어 'http://www.joes-hardware.com'), URL 범위 밖에서 역할이 있는 문자이기 때문에 반드시 인코딩해야 한다 |
| 0x00-0x1F, 0x7F | 제한됨. 이 16진수 범위에 속하는 문자들은 인쇄되지 않는 US-ASCII 문지다 |
| > 0x7F | 제한됨. 이 16진수 범위에 속하는 문자들은 7비트 US-ASCII 문자가 아니다 |

##### 2.4.4 좀 더 알아보기
* 애플리케이션은 정해진 방식 대로 구현해야 함
* 어떤 애플리케이션에 어떤 URL을 보내든지, 그 전에 클라이언트 애플리케이션에서 안전하지 않거나 제한된 문자를 변환하는 것이 좋음
* 안전하지 않은 모든 문자를 인코딩하기만 하면, 다른 애플리케이션으로부터 특별한 의미를 가지는 문자를 받았을 때 흔동할 걱정 없이, 애플리케이션 간에 공유할 수 있는 URL의 원형을 유지할 수 있음

#### 2.5 스킴의 바다

| 스킴 | 설명 |
| --- | --- |
| http | 사용자 이름이나 비밀번호가 없다는 것을 제외하고는, 일반 URL 포맷을 지키는 하이퍼텍스트 전송 프로토콜(Hypertext Transfer Protocol) 스킴이다. 포트값이 생략되어 있으면 기본값은 80 이다. |
| https | https 스킴은 http 스킴과 거의 같다. 다른 점이라고는 https는 HTTP의 커넥션의 양 끝단에서 암호화하기 위해 넷스케이프에서 개발한 보안 소켓 계층(Secure Sockets Layer, SSL)을 사용한다는 것뿐이다. 문법은 HTTP와 같고 기본 포트값은 443이다. |
| mailto | mailto URL은 이메일 주소를 가리킨다. 이메일은 다른 스킴과는 다르게 동작하기 때문에, mailto URL은 표준 URL과는 다른 포맷을 가진다. 인터넷 이메일 주소의 문법은 RFC 822에 기술되어 있다. |
| ftp | 파일 전송 프로토콜(File Transfer Protocol) URL은 FTP 서버에 있는 파일을 내려 받거나 올리고, FTP 서버의 디렉터리에 있는 콘텐츠 목록을 가져오는 데 사용할 수 있다. FTP는 웹과 URL이 출현하기 전부터 있었다. 웹 애플리케이선은 데이터에 접근하는 용도의 스킴으로 FTP를 사용한다. URL 문법은 다음과 같이 일반적인 URL 포맷이다. |
| rtsp, rtspu | RTSP URL은 실시간 스트리밍 프로토콜(Real Time Streamng Protocol)을 통해서 읽을 수 있는 오디오 및 비디오와 같은 미디어 리소스 식별자다. nspu 스킴에 있는 'u'는 리소스를 읽기 위해서 UDP 프로토콜이 사용됨을 뜻한다. |
| file | file 스킴은 주어진 호스트 기기(로컬 디스크' 네트워크 파일 시스템 혹은 기타 파일 공유 시스템)에서 바로 접근할 수 있는 파일들을 나타낸다. 각 필드도 일반적 인 URL 포맷을 따른다. 만약 호스트가 생략되어 있으면, URL을 사용하고 있는 기기의 로컬 호스트가 기본값이 된다. |
| news | news 스킴은 RFC 1036에 정의된 바와 같이 특정 문서나 뉴스 그룹에 접근하는데 사용한다. news URL은 리소스의 위치 정보를 중분히 포함하지 않는 특이한 속성이 있다. news URL은 해당 리소스가 어디에 있는지에 대한 정보를 포함하지 않는다. 호스트 명이나 서버 이름도 제공하지 않는다. 사용자로부터 그 정보를 알아내는 것은 애플리케이션의 몫이다 |
| telnet | telnet 스킴은 대화형 서비스에 접근하는데 사용한다. tenet URL 자체가 객체를 가리키지는 않지만, 리소스라고 할 수 있는 대화형 애플라케이션은 이 telnet 프로토콜을 통해 접근할 수 있다. |

#### 2.6 미래
* URL이 완벽한 것은 아님
* 사실 URL은 주소이지 실제 이름은 아님
* 스킴의 단점은 리소스가 옮겨지면 URL을 더는 사용할 수 없다는 것

##### 2.6.1 지금이 아니면, 언제 ?
* URN(Uniform Resource Names)이라는 새로운 표준 작업에 착수
* URN은 객체가 옮겨지더라도(웹 서버 내에서나 웹 서버 간 모두) 항상 객체를 가리수 있는 이름을 제공
* 유감스럽게도(혹은 다행스럽게도) URN으로 전환하기 위한 모든 것이 준비 되려면 시간이 걸리기 때문에, URL은 당분간 계속 사용될 것

#### 2.7 추가 정보

### 3장 HTTP 메시지

#### 3.1 메시지의 흐름
* HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록
* 데이터의 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있음
* '인바운드', '아웃바운드' , '업스트림', '다운스트림'은 메시지의 방향을 의미하는 용어

##### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다
* HTTP는 인바운드와 아웃바운드라는 용어를 트랜책션 방향을 표현하기 위해 사용
* 메시지가 원 서버로 향하는 것은 인바운드
* 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드

##### 3. 1 .2 다운스트림으로 흐르는 메시지
* 요청 메시지냐 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐름

#### 3.2 메시지의 각 부분
* 메시지는 시작줄, 헤더 블록, 본문 이렇게 세 부분으로 이루어짐
* 시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열
* 각 줄은 캐리지 리턴 (ASCII 13)과 개행 문자 (ASCII 10)로 구성된 두 글자의 줄바꿈 문자열으로 끝남
* 줄바꿈 문자열은 'CRLF'라고 씀
* 엔터티 본문이나 메시지 본문(혹은 그냥 '본문')은 단순히 선택적인 데이터 덩어리
* 시작줄이나 헤더와는 달리, 본문은 텍스트나 이진 데이터를 포함할 수도 있고 그냥 비 어 있을 수도 있음

![HTTP 메시지의 세 부분](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_3-3.png)

##### 3.2.1 메시지 문법
* 모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류
* 요청 메시지의 형식

```
<메서드> <요청 URL> <버전>
<헤더>
<엔터티 본문>
```

* 응답 메시지의 형식

```
<버전> <상태 코드> <사유 구절>
<헤더>
<엔터티 본문>
```

###### 메서드
* 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작

###### 요청 URL
* 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소

###### 버전
* 이 메시 지 에서 사용 중인 HTTP의 버 전

```
HTTP/<메이저>.<마이너>
```

###### 상태코드
* 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자

###### 사유 구절
* 숫자로 된 상태 코드의 의미를사람이 이해할 수 있게 설명해주는 짧은 문구
* 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절
* 사유 구절은 오로지 사람에게 읽히기 위한 목적으로만 존재하는 것

###### 헤더들
* 이름, 콜론(:), 선택적인 공백, 값, CRLF가 순서 대로 나타나는 0개 이상의 헤더들

###### 엔터티 본문
* 엔터티 본문은 임의의 데이터 블록을 포함
* 헤더나 엔터티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄(그냥 CRLF)로 끝나야 함에 주의

##### 3.2.2 시작줄

###### 요청줄
* 요청 메시지의 시작줄, 혹은 요청줄에는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어 있음
* 모든 필드는 공백으로 구분

###### 응답줄
* 응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려줌
* 응답 메시지의 시작줄 혹은 응답줄에는 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유 구절이 들어있음

###### 메서드
* 요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해줌

| 메서드 | 설명 | 메시지 본문이 있는가? |
| :--- | :--- | :--- |
| GET | 서버에서 어떤 문서를 가져온다. | 없음 |
| HEAD | 서버에서 어떤 문서에 대해 헤더만 가져온다. | 없음 |
| POST | 서버가 처리해야 할 데이터를 보낸다. | 있음 |
| PUT | 서버에 요청 메시지를 본문을 저장한다. | 있음 |
| TRACE | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다. | 없음 |
| OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다. | 없음 |
| DELETE | 서버에서 문서를 제거한다. | 없음 |

###### 상태 코드
* 메서드가 서버에게 무엇을 해야 하는지 말해주는 것처럼, 상태 코드는 클라이언트에게 무엇이 일어났는지 말해줌
* 200에서 299까지의 상태 코드는 성공을 나타낸다. 500에서 399까지의 코드는 리소스 옮가겨졌음을 뜻
* 400에서 499까지의 코드는 클라이언트가 뭔가 잘못된 요청을음을 의미
* 500에서 599까지의 코드는 서버에서 뭔가 실패했음을 의미

| 전체 범위 | 정의된 범위 | 분류 |
| --- | --- | :--- |
| 100-199 | 100-101 | 정보 |
| 200-299 | 200-206 | 성공 |
| 300-399 | 300-305 | 리다이렉션 |
| 400-499 | 400-415 | 클라이언트 에러 |
| 500-599 | 500-105 | 서버 에러 |

###### 사유 구절
* 상태 코드에 대한 글로 된 설명을 제공
* 사유 구절은 상태 코드와 일대일로 대응
* HTTP 명세는 사유 구절이 어때야 한다는 어떤 엄격한 규칙도 제공하지 않음

###### 버전 번호
* 버전 번호는 HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 
* HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단

##### 3.2.3 헤더
* HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더함
* 이름/값 쌍의 목록

###### 헤더 분류
* 일반 헤더 : 요청과 응답 양쪽에 모두 나타날 수 있음
* 요청 헤더 : 요청 에 대한 부가 정보를 제공
* 응답 헤더 : 웅답에 대한 부가 정보를 제공
* Entity 헤더 : 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
* 확장 헤더 : 명세에 정의되지 않은 새로운 헤더

###### 헤더를 여러 줄로 나누기
* 긴 헤더 줄은 그들을 여러 줄로 쪼개서 더 읽기 좋게 만들 수 있는데, 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야 함

##### 3.2.4 엔터티 본문
* HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있음

##### 3.2.5 버전 0.9 메시지
* HTTP/0.9 메시지도 마찬가지로 요청과 응답으로 이루어져 있지만, 요청은 그저 메서드와 요청 URL를 갖고 있을 뿐
* 응답은 오직 엔터티로만 되어 있음

#### 3.3 메서드
* 메서드는 대부분 제한적으로 사용될 것

##### 3.3.1 안전한 메서드 (Safe Method)
* HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의
* GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 GET이나 HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미
* 안전한 메서드가 서버 에 작용을 유발하지 않는다는 보장은 없음
* 안전한 메서드의 목적은, 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것

##### 3.3.2 GET
* 주로 서버에게 리소스를 달라고 요청하기 위해 쓰임
* HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구함

##### 3.3.3 HEAD
* HEAD 메서드는 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려줌
* **리소스를 가져오지 않고도 그에 대해 무엇인가(타입이라거나)를 알아낼 수 있다.**
* **응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.**
* **헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.**
* HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어어야 함

##### 3.3.4 PUT
* GET 메서드가 서버로부터 문서를 읽어 들이는데 반해 PUT 메서드는 서버에 문서를 씀
* PUT 메서드의 의미는, 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것

##### 3.3.5 POST
* POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계

##### 3.3.6 TRACE
* 클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있음
* HTTP 요청을 수정할 수 있는 기회 있음
* TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줌
* TRACE 요청은 목적지 서버에서 '루프백(loopback)' 진단을 시작
* 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려줌
* 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTIP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지, 만약 그렇다면 어 떻게 변경 되었는지 확인할 수 있음
* **TRACE는 진단을 위해 사용할 때는 괜찮지만, 그 대신 중간 애플리케이션이 여러 다른 종류의 요청(GET, HEAD, POST 등 각각 다른 메서드를 사용한)들을 일관되게 다룬다고 가정하는 문제가 있다.(?)**
* TRACE 요청은 어떠한 엔터티 본문도 보낼 수 없음
* TRACE 응답의 엔터티 본문에는 서버가 받은 요청이 그대로 들어 있음

* R : 루프백(loopback)

##### 3.3.7 OPTIONS
* OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어봄
* 이 메서드는 여러 리소스에 대해 실제로 접근하지 않고도 그것들을 어떻게 접근하는 것이 최선인지 확인할 수 있는 수단을 클라이언트 애플리케이션에게 제공

##### 3.3.8 DELETE
* 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청
* 클라이언트는 삭제가 수행되는 것을 보장하지 못함
* HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문

##### 3.3.9 확장 메서드
* HTTP는 필요에 따라 확장해도 문제가 없도록 설계
* 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않음
* 확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드
* **그들은 개발자들에게 그들의 서버가 구현한 HTTP 서비스의 서버가 관리하는 리소스에 대한 능력을 확장하는 수단을 제공한다.**
* 모든 확장 메서드가 형식을 갖춘 명세로 정의된 것은 아니라는 점에 주의
* 만약 당신이 어떤 확장 메서드를 정의한다면, 그것은 대부분의 HTTP 애플리케이션이 이해할 수 없을 것

* Q : `HTTP 애플리케이션이 이해할 수 없을 것` -> `이용할 수 없는 것` 라는 표현이 더 적절하지 않은가?
* Q : 405, 501의 차이는? 어떤 경우에 올바른 선택인가?
* R : [Tomcat Access-Control-Allow-Methods header](https://tomcat.apache.org/tomcat-8.0-doc/config/filter.html)

#### 3.4 상태 코드
* HTTP 상태 코드는 크게 다섯 가지로 나뉨

##### 3.4 1 100-199: 정보성 상태 코드

###### 클라이언트와 100 Continue
* 100 Continue는 HTTP 클라이언트 애플리케이션이 서버에 엔터티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 할 때, 그 확인 작업을 최적화하기 위한 의도로 도입된 것
* 100-Continue를 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버 에게 보내지 않으려는 목적으로만 사용

* Q : '다루거나 사용할 수 없는 큰 엔터티를' 이 문맥에서 다룬다와 사용의 차이는 무엇인가?

###### 서버와 100 Continue
* 서버가 100-Continue 값이 담긴 Expect 헤더가 포함된 요청을 받는다면, 100 Continue 응답 혹은 에러 코드로 답해야 함
* 서버가 100 Continue 응답을 보낼 기회를 갖기 전에 어떤 이유로 인해 엔터티의 일부(혹은 전체)를 수신하였다면, 서버는 이 상태 코드를 보낼 필요가 없음
* 만약 서버가 100 continue 응답을 받을 것을 의도한 요청을 받고 난 상태에서 엔터티 본문을 읽기 전에 요청을 끝내기로 결정했다면(에러 등의 이유로), 서버는 그냥 응답을 보내고 연결을 닫아서는 안 됨

* Q : '100 Continue 응답 혹은 에러 코드로 답' 에러 코드는 417을 전달하는가? 아니면 다른 코드인가?

###### 프락시와 100 Continue
* 클라이언트로부터 100-continue 응답을 의도한 요청을 받은 프락시는 몇 가지 해야 할 일이 있음
* 다음 흡(next-hop) 서버(6장에서 다룬다)가 HTTP/1.1을 따르거나 혹은 어 떤 버 전을 따르는지 모른다면, Expect 헤더를 포함시 켜서 요청을 다음으로 전달해야 함
* 만약 다음 흡의 서버가 1.1보다 이전 버전의 HTTP를 따른다는 것을 알고 있다면, 프락시는 417 Expectation Failed 에러로 응답
* 프락시가 HTTP/1.0이나 이전 버전을 따르는 클라이언트를 대신하여 Expect 헤더와 100-continue 값을 요청 에 포함시키 기로 결정했다면, 프락시는 100 Continue 응답을 클라이언트에 전달해서는 안 됨

##### 3.4.2 200-299: 성공 상태 코드
* 서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응

##### 3.4.3 300-399: 리다이렉션 상태 코드
* 리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공
* 리다이렉션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용
* 302, 303, 307 상태 코드 사이에서 중복되는 부분
  * 상태 코드들이 어떻게 사용되는가에 대해서는 약간 미묘한 차이가 있는데, 이는 주로 HTTP/1.0과 HTTP/1.1 애플리케이션이 이 상태 코드를 다루는 방식의 차이점에 기인

##### 3.4.4 400-499: 클라이언트 에러 상태 코드
* 클라이언트는 서버가 다를 수 없는 무엇인가를 보낸다. 잘못 구성된 요청 메시지 같은 것이 있을 수 있으며 , 가장 흔한 것은 존재하지 않는 URL에 대한 요청

##### 3.45 500-599: 서버 에러 상태 코드
* 클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우

#### 3.5 헤더
* 헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용
* 헤더에는 특정 종류의 메시지에만 사용할 수 있는 헤더와, 더 일반 목적으로 사용할 수 있는 헤더, 그리고 응답과 요청 메시지 양쪽 모두에서 정보를 제공하는 헤더

###### 일반 헤더 (General Headers)
* 일반 헤더는 클라이언트와 서버 양쪽 모두가 사용
* 클라이언트, 서버, 그리고 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용

###### 요청 헤더 (Request Headers)
* 요청 헤더는 요청 메시지를 위한 헤더
* 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공

###### 응답 헤더(Response Headers)
* 응답 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더

###### 엔터티 헤더(Entity Headers)
* 엔터티 헤더란 엔터티 본문에 대한 헤더

```
Content-Type: text/html; charset=iso-latin-1
```

###### 확장 헤더(Extension Headers)
* 확장 헤더는 애플리케이션 개발자들에 의해 만들어졌지만 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더

##### 3.5.1 일반 헤더
* 메시지에 대한 아주 기본적인 정보를 제공
* 메시지가 어떤 종류이든 상관없이 유용한 정보를 제공

###### 일반 캐시 헤더
* HTTP/1.0은 HTTP 애플리케이션에게 매번 원 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 최초의 헤더를 도입

##### 3.5.2 요청 헤더
* 요청 헤더는 요청 메시지에서만 의미를 갖는 헤더
* 요청이 최초 발생한 곳에서 누가 혹은 무엇이 그 요청을 보냈는지에 대한 정보
* 클라이언트의 선호나 능력에 대한 정보

###### Accept 관련 헤더
* 클라이언트는 Accept 관련 헤더들은 이용해 서버에게 자신의 선호와 능력을 알려줄 수 있음
* Accept 관련 헤더들은 서버와 클라이언트 양쪽 모두에게 유익

###### 조건부 요청 헤더
* 조건부 요청 헤더를 사용하면, 클라이언트는 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있음

###### 요청 보안 헤더
* HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있음

###### 프락시 요청 헤더
* 프락시 기능을 돕기 위한 헤더

##### 3.5.3 응답 헤더
* 응답 헤더는 클라이언트에게 부가 정보를 제공
* 누가 응답을 보내고 있는지 혹은 응답자의 능력은 어떻게 되는지 알려주며, 더 나아가 응답에 대한 특별한 설명도 제공

###### 협상 헤더
* HTTP/1.1은 서버와 클라이언트가 어떤 표현을 택할 것인가에 대한 협상을 할 수 있도록 지원

###### 응답 보안 헤더

##### 3.5.4 엔터티 헤더
* HITP 메시지의 엔터티에 대해 설명하는 헤더들은 많음
* 일반적으로 엔터티 헤더는 메시지의 수신자에게 자신이 다루고 있는 것이 무엇인지 말해줌

###### 콘텐츠 헤더
* 콘텐츠 헤더는 엔터티의 콘텐츠에 대한 구체적인 정보를 제공
* 콘텐츠의 종류, 크기, 기타 콘텐츠를 처리할 때 유용

###### 엔터티 캐싱 헤더
* 일반 캐싱 헤더는 언제 어떻게 캐시가 되어야 하는지에 대한 지시지를 제공
* 엔터티 캐싱 헤더는 엔터티 캐싱에 대한 정보를 제공

#### 3.6 추가 정보

### 4장 커넥션 관리

#### 4.1 TCP 커넥션
* 일단 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달

##### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP
* HTTP 커넥션은 몇몇 사용 규칙을 제외하고는 TCP 커넥션에 불과
* TCP 커넥션은 인터넷을 안정적으로 연결
* TCP 커넥션의 한쪽에 있는 바이트들은 반대쪽으로 순서 에 맞게 정확히 전달

![TCP는 충돌 없이 순서에 맞게 HTTP 데이터를 전달한다.](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_4-2.png)

##### 4.1.2 TCP 스트팀은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다
* TCP는 IP 패킷(혹은 IP 데이터그램)이라고 불리는 작은 조각을 통해 데이터를 전송
* HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보냄
* TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달
* 각 TCP 세그먼트는 하나의 IP 주소에서 다른 IP 주소로 IP 패킷에 담겨 전달

##### 4.1.3 TCP 커넥션 유지하기
* 컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있음
* TCP는 포트 번호를 통해서 이런 여러 개의 커넥션을 유지
* TCP 커넥션은 네 가지 값으로 식별
* 네 가지 값으로 유일한 커넥션을 생성

```
<발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>
```

##### 4.1.4 TCP 소켓 프로그래밍
* 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능을 제공
* 소켓 API를 사용하면, TCP 종단(endpoint) 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있음
* TCP API는, 기본적인 네트워크 프로토콜의 핸드셰이킹, 그리고 TCP 데이터 스트림과 IP 패킷 간의 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨김

#### 4.2 TCP의 성능에 대한 고려

##### 4.2.1 HTTP 트랜잭션 지연
* 클라이언트나 서버가 너무 많은 데이터를 내려받거나 복잡하고 동적인 자원들을 실행하지 않는 한, 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생

![HTTP 트랜잭선이 처리되는 과정](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_4-7.png)

##### 4.2.2 성능 관련 중요 요소
* **TCP 커넥션의 핸드셰이크 설정**
* **인터넷의 흔잡을 제어하기 위한 TCP의 느린 시작(slow-start)**
* **데이터를 한데 모아 한 번에 전송하기 위한 네이글(nagle) 알고리즘**
* **TCP의 편승(piggyback) 확인응답(acknowledgment)을 위한 확인응답 지연 알고리즘**
* **TIME WAIT 지연과 포트 고갈**

##### 4.2.3 TCP 커넥션 핸드셰이크 지연
* TCP커넥션이핸드셰이크를하는순서
  * 클라이언트는 새로운 TCP 커넥 션을 생성하기 위해 작은 TCP 패킷(보통 40~60바이트)을 서버에게 보낸
  * 서버가 그 커넥션을 받으면 몇 가지 커넥션 매개변수를 산출하고, 커넥션 요청이 받아들여졌음을 의미하는 'SYN'과 'ACK' 플래그를 포함한 TCP 패킷을 클라이언트에게 보냄
  * 마지막으로 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위해서 서버에게 다시 확인응답 신호를 보냄

![TCP는 데이터를 전송하기 전에, 커넥션 설정을 위해 두 개의 패킷 전송을 해야 한다.](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_4-8.png)

##### 4.2.4 확인응답 지연
* TCP는 성공적인 데이터 전송을 보장하기 위해서 자체적인 확인 체계를 가짐 (?)
* 각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가짐
* 세그먼트의 수신자는 세그먼트를 온전히 받으면 작은 확인응답 패킷을 송신자에게 반환
* 송신자가 특정 시간 안에 확인응답 메시지를 받지 못하면 패킷이 파기되었거나 오류가 있는 것으로 판단하고 데이터를 다시 전송
* 확인응답은 그 크기가 작기 때문에, TCP는 같은 방향으로 송출되는 데이터 패킷에 확인응답을 '편승(piggyback)' 시킴
* 요청과 응답 두 가지 형식으로만 이루어지는 HTTP 동작 방식은, 확인 응답이 송출 데이터 패킷에 편승할 기회를 감소 시킴
* TCP 스택에 있는 매개변수를 수정할 때는, 지금 무엇을 하고 있는지 항상 잘고 수정 (수정 할 일이 있을까?)

##### 4.2.5 TCP 느린 시작(slow start)
* TCP 커넥션은 시간이 지나면서 자체적으로 '튜닝'되어서, 처음에는 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라서 속도 제한 을 높여나감

##### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY
* 애플리케이션이 어떤 크기의 데이터든지(심지어 1바이트라도) TCP 스택으로 전송 할 수 있도록, TCP는 데이터 스트림 인터페이스를 제공
* 네트워크 효율을 위해서, 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한개 의 덩어리로 합침
* 문제점
 * 크기가 작은 HTTP 메시지는 패킷을 채우지 못하기 때문에, 앞으로 생길지 생기지 않을지 모르는 추가적인 데이터를 기다리며 지연될 것
 * 네이글 알고리즘은 확인응답 지연과 함께 쓰일 경우 형편없이 동작
* HTTP 애플리케이션은 성능 향상을 위해서 HTTP 스택에 TCP NODELAY 파라미터 값을 설정하여 네이글 알고리즘을 비활성화하기도 함

##### 4.2.7 TIMEWAIT의 누적과 포트 고갈 (?)
* TCP 커넥션의 종단에서 TCP 커넥션을 끊으면, 종단에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 제어영역(control block)에 기록
  * 주소와 포트 번호를 사용하는 새로운 TCP 커넥션이 일정 시간 동안에는 생성되지 않게 하기 위한 것

#### 4.3 HTTP 커넥션 관리

##### 4.3.1 흔히 잘못 이해하는 Connection 헤더 (?)
* HTTP C○nncction 헤더 필드는 커넥션 토큰을 쉼표로 구분하여 가지고 있으며, 그 값들은 다른 커넥션에 전달되지 않음

##### 4.32 순차적인 트랜잭션 처리에 의한 지연
* 각 트랜책션이 새로운 커넥션을 필요로 한다면, 커넥션을 맺는데 발생하는 지연과 함께 느린 시작 지연이 발생할 것

![네 개의 트랜잭션(순차)](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_4-10.png)

* HTTP 커넥션의 성능을 향상시킬 수 있는 여러 최신 기술
  * 병렬(parallel) 커넥션 : 여러 개의 TCP 커넥션을 통한 동시 HTTP 요청
  * 지속(persistent) 커넥션 : 커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션의 재활용
  * 파이프라인(pipelined) 커넥션 : 공유 TCP 커넥션을 통한 병렬 HTTP 요청
  * 다중(multiplexed) 커넥션 : 요청과 응답들에 대한 중재(실험적인 기술이다)

#### 4.4 병렬 커넥션

##### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다
* 단일 커넥션의 대역폭 제한과 커넥션이 동작하지 않고 있는 시간을 활용하면, 객체가 여러 개 있는 웹페이지를 더 빠르게 내려받을 수 있을 것
* 각 커넥션의 지연 시간을 겹치게 하면 총 지연 시간을 줄일 수 있고, 클라이언트의 인터넷 대역폭을 한 개의 커넥션이 다 써버리는 것이 아니라면 나머지 객체를 내려받는 데에 남은 대 역폭을 사용할 수 있음

##### 4.4.2 병혈 커넥션이 항상 더 빠르지는 않다
* 여러 개의 객체를 병렬로 내려받는 경우, 이 제한된 대역폭 내에서 각 객체를 전송받는 것은 느리기 때문에 성능상의 장점은 거의 없어짐
* 서버는 특정 클라이언트로부터 과도한 수의 커넥션이 어졌을 경우, 그것을 임의로 끊어버릴 수 있음

##### 4.4.3 병렬 커넥션은 더 빠르게 '느껴질 수' 있다
* 병렬 커넥션이 실제로 페이지를 더 빠르게 내려받는 것은 아니지만, 화면에 여러 개의 객체가 동시에 보이면서 내려받고 있는 상황을 볼 수 있기 때문에 사용자는 더 빠르게 내려받고는 것처럼 느낄 수 있음

#### 4.5 지속 커넥션
* 사이트 지역성 (site locality) : 서버에 HTTP 요청을 하기 시작한 애플리케이션은 웹페이지 내의 이미지 등을 가져오기 위해서 그 서버에 또 요청하게 될 것
* HTTP/1.1(HTTP/1.0의 개선 버전)을 지원하는 기기는 처리가 완료된에도 TCP 커 넥션을 유지하여 앞으로 있을 HTTP 요청 에 재사용할 수 있음
* 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 지속 커넥션이라고 부름
* 지속 커넥션은 클라이언트나 서버가 커넥션을 끊기 전까지는 트랜잭션 간에도 커넥션을 유지

##### 4.5.1 지속 커넥션 vs 병렬 커넥션
* 지속 커넥션 장점
  * 커넥션을 맺기 위한 사전 작업과 지연을 줄여주고, 튜닝된 커넥션을 유지하며, 커넥션의 수를 줄여줌
* 지속 커넥션은 병렬 커넥션과 함께 사용될 때에 가장 효과적
* HTTP/1.0+에는 'keep-alive' 커넥션이 있고 HTIP/1.1에는 '지속' 커넥션 (?)

##### 4.5.2 HTTP/1.0+의 Keep-Alive 커넥션
* 많은 HTTP/1.0 브라우저와 서 버들은 일찍부터 다소 실험 적 이 었던 keep-alive 커션이라는 지속 커넥션을 지원하기 위해 확장

![네 개의 트랜책션(연속 vs 지속)](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_4-13.png)

##### 4.5.3 Keep-Alive 동작
* keep-alive는 사용하지 않기로 결정되어 HTTP/1.1 명세에서 빠짐
* HTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해서 요청에 Connection:Keep-Alive 헤더를 포함
* 이 요청을 받은 서버는 그다음 요청도 이 커넥션을 통해 받고자 한다면, 응답 메시지에 같은 헤더를 포함

##### 4.5.4 Keep-AIive 옵션
* Keep-AIive 헤더는 커넥션을 유지하기를 바라는 요청일 뿐
* 클라이언트나 서버가 keep-alive 요청을 받았다고 해서 무조건 그것을 따를 필요는 없음

```
Connection: Keep-AIive
Keep-Alive: max=5, timeout=12O
```

##### 4.5.5 Keep-Alive 커넥션 제한과 규칙
* keep-alive는 HTTP/1.0에서 기본으로 사용되지는 않음
* 클라이언트는 keep-alive 커넥션을 사용하기 위해 Connection: Keep-AIive 요청 헤더를 보내야 함
* 커넥션을 계속 유지하려면 모든 메시지에 Connection: Keep-Alive 헤더를 포함해 보내야 함 (클라이 언트가 Connection: Keep-Alive 헤더를 보내지 않으면 서버는 요청을 처 리한 후 커넥션을 끊을 것)
* 클라이언트는 Connection: Keep-Alive 응답 헤더가 없는 것을 보고 서버가 응답후에 커넥션을 끊을 것임을 알 수 있음

##### 4.5.6 Keep-Alive와 멍청한(dumb) 프락시

###### Connection 헤더의 무조건 전달
* 특히 문제는 프락시에서 시작되는데, 프락시는 Connection 헤더를 이해하지 못해서 해당 헤더들을 삭제하지 않고 요청 그대로를 다음 프락시에 전달

![keep-alive는 Connection 헤더를 지원하지 않은 프락시와는 상호작용하지 않는다](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_4-15.png)

###### 프락시와 흡별 헤더
* 프락시는 Connection 헤더와 Connection 헤더에 명시된 헤더들은 절대 전달하면 안 됨

##### 4.5.7 Proxy-Connection 살펴보기

![ProxyConnection 헤더는 단일 무조건 전달 문제를 해결해준다.](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_4-16.png)

##### 4.5.8 HTTTP/1.1 의 지속 커넥션
* HTTP/1.1에서는 keep-live 커넥션을 지원하지 않는 대신, 설계가 더 개선된 지속 커넥션을 지원
* 지속 커넥션의 목적은 keep-alive 커넥션과 같지만 그에 비해 더잘 동작
* HTTP/1.0의 keep-alive 커넥션과는 달리 HTTP/1.1의 지속 커넥션은 기본으로 활성화
* HTTP/1.1에서는 별도 설정을 하지 않는 한, 모든 커넥션을 지속 커넥션으로 취급
* HTTP/1.1 애플리케이션은 트랜잭션이 끝난 다음 커넥션을 끊으려면 Connection: close 헤더를 명시
* HTTP/1.1 클라이언트는 응답에 Connection: close 헤더가 없으면 응답 후에도 HTTP/1.1 커넥션을 계속 유지하지는 것으로 추정
* 클라이언트와 서버는 언제든지 커넥션을 끊을 수 있음
* Connection: close를 보내지 않는 것이 서버가 커넥션을 영원히 유지하겠다는 것을 뜻하지는 않음

###### 4.5.9 지속 커넥션의 제한과 규칙
* 클라이언트가 요청에 Connection: close 헤더를 포함해 보냈으면, 클라이언트는 그 커넥션으로 추가적 인 요청 을 보낼 수 없음
* 클라이언트가 해당 커넥션으로 추가적인 요청을 보내지 않을 것이라면, 마지막 요청에 Connection: close 헤더를 보내야 함

#### 4.6 파이프라인 커넥션
* HTTP/1.1은 지속 커넥션을 통해서 요청을 파이프라이닝할 수 있음
* HTTP 응답은 요청 순서와 같게 와야 한다. HTTP 메시지는 순번이 매겨져 있지 않아서 응답이 순서 없이 오면 순서에 맞게 정렬시킬 방법이 없음
* 멱등(idempotent) : 연산의 한 성질을 나타내는 것으로, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질
* 비멱등(nonidempotent) : 연산이 한 번 일어날 때 마다 결과가 변할 수 있음을 뜻
  
#### 4.7 커넥션 끊기에 대한 미스터리

##### 4.7.1 '마음대로', 커넥션 끊기
* HTTP 클라이언트, 서버, 혹은 프락시든 언제든지 TCP 전송 커넥션을 끊을수 있음
* 보통 커넥션은 메시지를 다 보낸 다음 끊지만, 에러가 있는 상황에서는 헤더의 중간이나 다른 엉뚱한 곳에서 끊길 수 있음

##### 4.7.2 Content-Length와 Truncation
* 각 HTTP 응답은 본문의 정확한 크기 값을 가지는 Content-Length 헤더를 가지고 있어야 함
* 클라이언트나 프락시가 커넥션이 끊어졌다는 HTTP 응답을 받은 후, 실제 전달 된 엔터티의 길이와 Content-Length의 값이 일치하지 않거나 Content-Length 자체가 존재하지 않으면 수신지는 데이터의 정확한 길이를 서버에게 물어봐야 함

##### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성
* 한 번 혹은 여러 번 실행됐는지에 상관없이 같은 결과를 반환한다면 그 트랜책션은 멱등(idempotent)
* GET, HEAD, PUT, DELETE, TRACE 그리고 OPTIONS 메서드들은 멱등
* 비멱등인 요청을 다시 보내야 한다면, 이 전 요청 에 대한 응답을 받을 때까지 기다려야 함
* GET 기반의 동적인 폼을 사용할 경우에는 GET이 멱등하게 동작하는 것이 맞는지 확인이 필요
  
##### 4.7.4 우아한 커넥션 끊기

###### 전체 끊기와 절반 끊기
* 애플리케이션은 TCP 입력 채널과 출력 채널 중 한 개만 끊거나 둘 다 끊을 수 있음
* '전체 끊기' close()를 호출하면 TCP 커넥션의 입력 채널과 출력 채널의 커넥션을 모두 끊음
* '절반 끊기' 입력 채널이나 출력 채널 중에 하나를 개별적으로 끊으려면 shutdown()을 호출

###### TCP 끊기와 리셋 에러
* 보통은 커넥션의 출력 채널을 끊는 것이 안전
* 커넥션의 반대편에 있는 기기는 모든 데이터를 버퍼로부터 읽고 나서 데이터 전송이 끝남과 동시에 당신이 커넥션을 끊었다는 것을 알게 됨
* 클라이언트에서 더는 데이터를 보내지 않을 것임을 확신할 수 없는 이상, 커넥션의 입력 채널을 끊는 것은 위험
* 클라이언트에서 이미 끊긴 입력 채널에 데이터를 전송하면, 서버의 운영체제는 TCP 'connection reset by peer' 메시지를 클라이언트에 보냄

###### 우아하게 커넥션 끊기
* 일반적으로 애플리케이션이 우아한 커넥션 끊기를 구현하는 것은 애플리케이션 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것
* 커넥션을 우아하게 끊고자 하는 애플리케이션은 출력 채널에 절반 끊기를 하고 난 후에도 데이터나 스트림의 끝을 식별하기 위해 입력 채널에 대해 상태 검시률 주기적으로 해야 함

#### 4.8 추가 정보

## II. HTTP 아키텍처

### 5장 웹 서버

#### 5.1 다채로운 웹 서버
* '웹 서버'라는 용어는 웹 서버 소프트웨어와 웹페이지 제공에 특화된 장비(컴퓨터와 같은) 양쪽 모두를 가리킴

##### 5.1.1 웹 서버 구현
* 웹 서버는 HTTP 및 그와 관련된 TCP 처 리를 구현한 것
* 웹 서버는 자신이 제공하는 리소스를 관리하고 웹 서버를 설정, 통제, 확장하기 위한 관리 기능을 제공
* 웹 서버는 HTTP 프로토콜을 구현하고, 웹 리소스를 관리하고, 웹 서버 관리 기능을 제공
* 웹 서버는 TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 갖음
* 운영체제는 컴퓨터 시스템의 하드웨어를 관리하고 TCP/IP 네트워크 지원,웹 리소스를 유지하기 위한 파일 시스템, 현재 연산 활동을 제어하기 위한 프로세스 관리를 제공 

##### 5.1.2 다목적 소프트웨어 웹 서버
* 다목적 소프트웨어 웹 서버는 네트워크에 연결된 표준 컴퓨터 시스템에서 동작

##### 5.1.3 임베디드 웹 서버
* 임베디드 웹 서버는 일반 소비자용 제품에 내장될 목적으로 만들어진 작은 웹 서버

#### 5.2 간단한 펄 웹 서버
* HTTP/1.1의 기능들을 지원하려면, 풍부한 리소스 지원, 가상 호스팅, 접근 제어, 로깅, 설정, 모니터링, 그 외 성능을 위한 각종 기능들이 필요

```perl

# !/usr/bin/perl 

```

#### 5.3 진짜 웹 서버가 하는 일

#### 5.4 단계 1: 클라이언트 커넥션 수락

#### 5.5 단계 2: 요청 메시지 수신

#### 5.6 단계 3: 요청 처리

#### 5.7 단계 4: 리소스의 매핑과 접근

#### 5.8 단계 5: 응답 만들기

#### 5.9 단계 6: 응답 보내기

#### 5.10 단계 7: 로깅

#### 5.11 추가 정보
 
### 6장 프락시

#### 6.1 웹 중개자

#### 6.2 왜 프락시를 사용하는가?

#### 6.3 프락시는 어디에 있는가?

#### 6.4 클라이언트 프락시 설정

#### 6.5 프락시 요청의 미묘한 특징들

#### 6.6 메시지 추적

#### 6.7 프락시 인증

#### 6.8 프락시 상호운용성

#### 6.9 추가 정보
 
### 7장 캐시

#### 7.1 불필요한 데이터 전송

#### 7.2 대역폭 병목

#### 7.3 갑작스런 요청 쇄도(Flash Crowds)

#### 7.4 거리로 인한 지연

#### 7.5 적중과 부적중

#### 7.6 캐시 토폴로지

#### 7.7 캐시 처리 단계

#### 7.8 사본을 신선하게 유지하기

#### 7.9 캐시 제어

#### 7.10 캐시 제어 설정

#### 7.11 자세한 알고리즘

#### 7.12 캐시와 광고

#### 7.13 추가 정보
 
### 8장 통합점: 게이트웨이, 터널, 릴레이

#### 8.1 게이트웨이

#### 8.2 프로토콜 게이트웨이

#### 8.3 리소스 게이트웨이

#### 8.4 애플리케이션 인터페이스와 웹 서비스

#### 8.5 터널

#### 8.6 릴레이

#### 8.7 추가 정보

### 9장 웹 로봇

#### 9.1 크롤러와 크롤링

#### 9.2 로봇의 HTTP

#### 9.3 부적절하게 동작하는 로봇들

#### 9.4 로봇 차단하기

#### 9.5 로봇 에티켓

#### 9.6 검색엔진

#### 9.7 추가 정보

#### 10장 HTTP/2.0

#### 10.1 HTTP/2.0의 등장 배경

#### 10.2 개요

#### 10.3 HTTP/1.1과의 차이점

#### 10.4 알려진 보안 이슈

#### 10.5 추가 정보

## III. 식별, 인가, 보안
 
### 11장 클라이언트 식별과 쿠키

#### 11.1 개별 접촉

#### 11.2 HTTP 헤더

#### 11.3 클라이언트 IP 주소

#### 11.4 사용자 로그인

#### 11.5 뚱뚱한 URL

#### 11.6 쿠키

#### 11.7 추가 정보
 
### 12장 기본 인증

#### 12.1 인증

#### 12.2 기본 인증

#### 12.3 기본 인증의 보안 결함

#### 12.4 추가 정보

### 13장 다이제스트 인증

#### 13.1 다이제스트 인증의 개선점

#### 13.2 요약 계산

#### 13.3 보호 수준(Quality of Protection) 향상

#### 13.4 실제 상황에 대한 고려

#### 13.5 보안에 대한 고려사항

#### 13.6 추가 정보
 
### 14장 보안 HTTP

#### 14.1 HTTP를 안전하게 만들기

#### 14.1.1 HTTPS

#### 14.2 디지털 암호학

#### 14.3 대칭키 암호법

#### 14.4 공개키 암호법

#### 14.5 디지털 서명

#### 14.6 디지털 인증서

#### 14.7 HTTPS의 세부사항

#### 14.8 진짜 HTTPS 클라이언트

#### 14.9 프락시를 통한 보안 트래픽 터널링

#### 14.10 추가 정보 388

## IV. 엔터티, 인코딩, 국제화
 
### 15장 엔터티와 인코딩

#### 15.1 메시지는 컨테이너, 엔터티는 화물

#### 15.2 Content-Length: 엔터티의 길이

#### 15.3 엔터티 요약

#### 15.4 미디어 타입과 차셋(Charset)

#### 15.5 콘텐츠 인코딩 

#### 15.6 전송 인코딩과 청크 인코딩 

#### 15.7 시간에 따라 바뀌는 인스턴스 

#### 15.8 검사기와 신선도 

#### 15.9 범위 요청 

#### 15.10 델타 인코딩 

#### 15.11 추가 정보 
 
### 16장 국제화 

#### 16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원 

#### 16.2 문자집합과 HTTP 

#### 16.3 다중언어 문자 인코딩에 대한 지침 

#### 16.4 언어 태그와 HTTP 

#### 16.5 국제화된 URI 

#### 16.6 기타 고려사항 

#### 16.7 추가 정보 
 
### 17장 내용 협상과 트랜스코딩 

#### 17.1 내용 협상 기법 

#### 17.2 클라이언트 주도 협상 

#### 17.3 서버 주도 협상 

#### 17.4 투명 협상 

#### 17.5 트랜스코딩 

#### 17.6 다음 단계 

#### 17.7 추가 정보 

## V. 콘텐츠 발행 및 배포
 
### 18장 웹 호스팅

#### 18.1 호스팅 서비스

#### 18.2 가상 호스팅

#### 18.3 안정적인 웹 사이트 만들기

#### 18.4 웹 사이트 빠르게 만들기

#### 18.5 추가 정보

### 19장 배포 시스템

#### 19.1 배포 지원을 위한 FrontPage 서버 확장

#### 19.2 WebDAV와 공동 저작

#### 19.3 추가 정보 

### 20장 리다이렉션과 부하 균형

#### 20.1 왜 리다이렉트인가?

#### 20.2 리다이렉트 할 곳

#### 20.3 리다이렉션 프로토콜의 개요

#### 20.4 일반적인 리다이렉션 방법

#### 20.5 프락시 리다이렉션 방법

#### 20.6 캐시 리다이렉션 방법

#### 20.7 인터넷 캐시 프로토콜

#### 20.8 캐시 배열 라우팅 프로토콜

#### 20.9 하이퍼텍스트 캐싱 프로토콜

#### 20.10 추가 정보

### 21장 로깅과 사용 추적

#### 21.1 로그란 무엇인가?

#### 21.2 로그 포맷

#### 21.3 적중 계량하기

#### 21.4 개인 정보 보호에 대해

#### 21.5 추가 정보