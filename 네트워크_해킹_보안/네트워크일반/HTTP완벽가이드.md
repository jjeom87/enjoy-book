# HTTP 완벽 가이드

## I. HTTP: 웹의 기초

### 1장 HTTP 개관 

#### 1.1 HTTP: 인터넷의 멀티미디어 배달부
* HTTP는 신뢰성 있는 데이터 전송 프로토콜을 사용하기 때문에, 데이터가 지구 반대편에서 오더라도 전송 중 손상되거나 꼬이지 않음을 보장
* 사용자는 인터넷에서 얻은 정보가 손상된 게 아닌지 염려하지 않아도 됨
* 개발자는 인터넷의 결함이나 약점에 대한 걱정 없이 애플리케이션 고유의 기능을 구현하는 데 집중

#### 1.2 웹 클라이언트와 서버
* 웹 서버는 HTTP 프로토콜로 의사소통하기 때문에 보통 HTTP 서버라고 불림
* 웹 서버는 인터넷의 데이터를 저장하고, HTTP 클라이언트가 요청한 데이터를 제공

![웹 클라이언트와 웹 서버](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-1.png)

#### 1.3 리소스
* 웹 서버는 웹 리소스를 관리하고 제공 
* 웹 리소스는 웹 콘텐츠의 원천 
* 가장 단순한 웹 리소스는 웹 서버 파일 시스템의 정적 파일
* 리소스는 반드시 정적 파일이어야 할 필요는 없음
* 리소스는 요청 에 따라 콘텐츠를 생산하는 프로그램이 될 수도 있음

![웹 리소스란 웹에 콘텐츠를 제 공하는 모든 것을 말한다](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-2.png)

##### 1.3.1 미디어 타입
* 인터넷은 수천 가지 데이터 타입을 다루기 때문에, HTTP는 웹에서 전송되는 객체 각각에 신중하게 MIME 타입이라는 데이터 포맷 라벨을 붙임
* MIME (Multipurpose Internet Mail Extensions, 다목적 인터넷 메일 확장)은 원래 각기 다른 전자메일 시스템 사이 에서 메시지가 오갈 때 겪는 문제점을 해결하기 위해 설계
* 웹 서버는 모든 HTIP 객체 데이터에 MIME 타입을 붙임
* 웹브라우저는 서버로부터 객체를 돌려받을 때, 다룰 수 있는 객체 인지 MIME 타입을 통해 확인
* MIME 타입은 사선(/)으로 구분된 주 타입(primary object type)과 부 타입(specific subtype)으로 이루어 진 문자열 라벨

##### 1.3.2 URI
* **서버 리소스 이름은 통합 자원 식별자(uniform resource identifier), 혹은 URI로 불림**
* **URI는 인터넷의 우편물 주소 같은 것으로, 정보 리소스를 고유하게 식별하고 위치를 지정할 수 있음**
* URI에는 두 가지가 있음 URL, URN

![URL은 프로토콜, 서버 , 리소스롤 명시한다](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-4.png)

##### 1.3.3 URI
* 통합 자원 지시자(uniform resource locator, URL)는 리소스 식별자의 가장 흔한 형태
* URL은 특정 서버의 한 리소스에 대한 구체적인 위치를 서술

| URL | 설명 |
| --- | --- |
| http://www.oreilly.com/index.html | 오라일리 출판사 홈페이지의 URL |
| http://www.yahoo.com/images/logo.gif | 야후! 웹 사이트 로고의 URL |
| http://www.joes-hardware.com/nventory-check.cgl?ltem=12731 | 물품 #12731의 재고가 있는지 확인하는 프로그램에 대한URL |
| ftp://joe:tools4u@ftp.joes-hardware.com/locking-pliers.gif | 비밀번호로 보호되는 FTP를 통해 locking-pliers.gif 이미지 파일에 접근하는 URL |

* URL은 세 부분으로 이루어진 표준 포맷을 따름
  * URL의 첫 번째 부분은 스킴(scheme)이라고 불리는데, 리소스에 접근하기 위해 사용되는 프로토콜을 서술
  * 두 번째 부분은 서버의 인터넷 주소를 제공
  * 마지막은 웹 서버의 리소스를 가리킴

##### 1.3.4 URN
* URN은 콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 위치에 영향 받지 않는 유일무이한 이름 역할
* 이 위치 독립적인 URN은 리소스를 여기저기로 옮기더 라도 문제없이 동작
* 리소스가 그 이름을 변하지 않게 유지하는 한, 여러 종류 의 네트워크 접속 프로토콜로 접근해도 문제없음
* URN은 여전히 실험 중인 상태고 아직 널리 채택되지 않음

#### 1.4 트랜잭션
* HTTP 트랜잭션은 요청 명령(클라이언트에서 서버로 보내는)과 응답 결과(서버가 클라이언트에게 돌려주는)로 구성

![HTTP 트랜잭션은 요청과 응답 메시지로 구성되 어 있다](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-5.png)

##### 1.4.1 메서드
* HTTP는 HTTP 메서드라고 불리는 여러 가지 종류의 요청 명령을 지원

| HTTP 메서드 | 설명 |
| --- | --- |
| GET | 서버에서 클라이언트로 지정한 리소스를 보내라. |
| PUT | 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장하라. |
| DELETE | 지정한 리소스를 서버에서 삭제하라. |
| POST | 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라. |
| HEAD | 지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보내라. |

##### 1.4.2 상태 코드
* 모든 HTTP 응답 메시지는 상태 코드와 함께 반환 

| HTTP 상태 코드 | 설명 |
| --- | --- |
| 200 | 좋다. 문서가 바르게 반환되었다. |
| 302 | 다시 보내라. 다른 곳에 가서 리소스를 가져가라. |
| 404 | 없음. 리소스를 찾을 수 없다. |

* HTTP는 각 숫자 상태 코드에 덱스트로 된 "사유 구절(reason phrase)"도 함께 보냄

##### 1.4.3 웹페이지는 여러 객체로 이루어질 수 있다.
* 페이지 레이아웃을 서술하는 HTML '뼈대'를 한 번의 트랜잭션으로 가져온 뒤, 첨부된 이미지, 그래픽 조각, 자바 애플릿 등을 가져오기 위해 추가로 HTTP 트랜책션들을 수행
* '웹페이지'는 보통 하나의 리소스가 아닌 리소스의 모음

#### 1.5 메시지
* HTTP 메시지는 단순한 줄 단위의 문자열
* 이진 형식이 아닌 일반 텍스트이기 때문에 사람이 읽고 쓰기 쉽움
* 웹 클라이언트에서 웹 서버로 보낸 HTTP 메시지를 요청 메시지
* 서버 에서 클라이 언트로 가는 메 시지는 응답 메시지

![HTTP 메시지는 단순한 줄 단위 텍스트로 구조를 갖고 있다](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-7.png)

* 시작줄 
 * 메시지의 첫 줄은 시작줄로 요청이라면 무엇을 해야 하는지 응답이라면 무슨 일이 일어났는지 나타냄
* 헤더
 * 시작줄 다음에는 0개 이상의 헤더 필드가 이어짐
 * 각 헤더 필드는 쉬운 구문분석 을 위해 쌍점(:)으로 구분되어 있는 하나의 이름과 하나의 값으로 구성
 * 헤더 필드를 추가하려면 그저 한 줄을 더하기만 하면 됨
 * 헤더는 빈 줄로 끝남 
* 본문
 * 빈줄 다음에는 어떤 종류의 데이터든 들어갈 수 있는 메시지 본문이 필요에 따라 수 있음 
 * 요청의 본문은 웹 서버로 데이터를 실어 보내며, 응답의 본문은 클라이언트로 데이터를 반환 
 * 문자열이며 구조적인 시작줄이나 헤더와 달리, 본문은 임의의 이진 데이터를 포함할 수 있음(이미지, 비디오, 오디오 트랙, 응용 소프트웨어). 
 * 본문은 텍스트도 포함할 수 있음

##### 1.5.1 간단한 메세지의 예
![http;//www.joes-hardware.com/tools.html에 대한 GET 트랜잭션 의 예](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-8.png)

#### 1.6 TCP 커넥션

##### 1.6.1 TCP/IP
* HTTP는 애플리케이션 계층 프로토콜
* HTTP는 네트워크 통신의 핵심적인 세부사항에 대해서 신경 쓰지 않음
* TCP
  * 오류 없는 데이터 전송
  * 순서 에 맞는 전달 (데이터는 언제나 보낸 순서 대로 도착한다)
  * 조각나지 않는 데이터 스트림 (언제든 어떤 크기로든 보낼 수 있다)
* 인터넷 자체가 전 세계의 컴퓨터와 네트워크 장치들 사이에서 대중적으로 사용되는 TCP/IP에 기초
* TCP/IP는 TCP와 IP가 충을 이루는, 패킷 교환 네트워크 프로토콜의 집합
* TCP/IP는 각 네트워크와 하드웨어의 특성을 숨기고, 어떤 종류의 컴퓨터나 네트워크든 서로 신뢰성 있는 의사소통을 하게 해 줌
* TCP 커넥션이 맺어지면, 클라이언트와 서버 컴퓨터 간에 교환되는 메시지가 없어지거나, 손상되거나, 순서가 뒤바뀌어 수신되는 일은 결코 없음

![HTTP 네트워크 프로토콜 스택](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-9.png)

##### 1.6.2 접속, IP 주소 그리고 포트번호
* 인터넷 프로토콜 (Internet protocol, IP) 주소와 포트번호를 사용해 클라이 언트와 서버 사이 에 TCP/IP 커넥션을 맺어야 함
* IP 주소와 포트번호를 이용해 클라이언트는 TCP/IP로 쉽게 통신할 수 있음
* 순서
  * (a) 웹브라우저는 서버의 URL에서 호스트 명을 추출한다
  * (b) 웹브라우저는 서 버 의 호스트 명을 IP로 변환한다.
  * (c) 웹브라우저는 URL에서 포트번호(있다면)를 추출한다
  * (d) 웹브라우저는 웹 서버와 TCP 커넥션을 맺는다.
  * (e) 웹브라우저는 서 버 에 HTTP 요청을 보낸다.
  * (f) 서 버는 웹브라우저 에 HTTP 응답을 돌려준다.
  * (g) 커넥션이 닫히면, 웹브라우저는 문서를 보여준다.

![웹브라우저 연결의 기본적인 절차](/assets/images/books/네트워크_해킹_보안/네트워크일반/HTTP완벽가이드/figure_1-10.png)

##### 1.6.3 텔넷(Telnet)을 이용한 실제 예제
* 텔넷 유틸리티는 당신의 키보드를 목적지의 TCP 포트로 연결해주고 출력 TCP 포트를 당신의 화면으로 연결
* 텔넷은 원격 터미널 세션을 위해 흔히 사용되지만 HTTP 서버를 포함한 일반적 인 TCP 서 버 에 연결하기 위해 사용 될 수 있음
* 텔넷은 직접 컴퓨터 의 포트로 TCP 커 넥션을 연결해서 그 포트로 글자를 타이핑해 넣을 수 있게 줌
* nc(netcat)는 HTTP를 포함한 UDP 혹은 TCP 기반의 트래픽을 조작하고 스크립트할 수 있게 해줌

#### 1.7 프로토콜 버전
* HTTP/0.9
  * 1991년의 HTTP 프로토타입은 HTTP/0.9로 알려짐
  * 이 프로토콜은 심각한 디자인 결함이 다수 있고 구식 클라이언트하고만 같이 사용할 수 있음
  * HTTP/0.9는 오직 GET 메서드만 지원하고, 멀티미디어 콘텐츠에 대한 MIME 타입이나, HTTP 헤더. 버전 번호는 지원하지 않음
  * HTTP/0.9는 원래 간단한 HTML 객체를 받아 오기 위해 만들어진 것
  * HTTP/0.9는 금방 HTTP/1.0으로 대체  
* HTTP/1.0 
  * HTTP/1.0은 버전번호, HTTP 헤더, 추가 메서드, 멀티미디어 객체 처리를 추가
  * HTTP가 상업적, 학술적으로 급성장하던 시기에 만들어진, 잘 동작하는 용례들의 모음에 가깝움
* HTTP/1.0+
  * 오래 지속되는 "keep-alive" 커넥션, 가상 호스팅 지원, 프락시 연결 지원을 포함해 많은 기능이 공식적이진 않지만 사실상의 표준으로 HTTP에 추가
* HTTP/1.1
  * HTTP/1.1은 HTTP 설계의 구조적 결함 교정, 두드러진 성능 최적화, 잘못된 기능 제거에 집중
  * HTTP/1.1은 더 복잡해진 웹 애플리케이션과 배포(1990년대 후반에 이미 쓰이고 있었다)를 지원
* HTTP/2.0
  * HTTP/2.0은, HTTP/1.1 성능 문제를 개선하기 위해 구글의 SPDY 프로토콜을 기반으로 설계가 진행 중인 프로토콜

#### 1.8 웹의 구성요소
* 프락시
  * 클라이언트와 서버 사이에 위치한 HTTP 중계자
* 캐시
  * 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고
* 게이트웨이
  * 다른 애플리케이션과 연결된 특별한 웹 서버
* 터널
  * 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시
* 에이전트
  * 자동화된 HTTP 요청을 만드는 준지능적 웹클라이언트

##### 1.8.1 프락시
* 프락시는 클라이언트와 서버 사이에 위치하여, 클라이언트의 모든 HTTP 요청을 받아 서버에 전달
* 프락시는 주로 보안을 위해 사용
* 모든 웹 트래픽 흐름 속에서 신뢰할 만한 중개자 역할함
* 프락시는 요청과 응답을 필터링

##### 1.8.2 캐시
* 웹캐시와 캐시 프락시는 자신을 거쳐 가는 문서들 중 자주 찾는 것의 사본을 저장해 두는, 특별한 종류의 HTTP 프락시 서버
* 클라이언트는 멀리 떨어진 웹 서버보다 근처의 캐시에서 훨씬 더 빨리 문서를 다운 받을 수 있음
* HTTP는, 캐시를 효율적으로 동작하게 하고 캐시된 콘텐츠를 최신 버전으로 유지하면서 동시에 프라이버시도 보호하기 위한 많은 기능을 정의

##### 1.8.3 게이트웨이
* 게이트웨이는 다른 서버들의 중개자로 동작하는 특별한 서버
* 게이트웨이는 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용
* HTTP/FTP 게이트웨이는 FTP URI에 대한 HTTP 요청을 받아들인 뒤, FTP 프로토콜을 이용해 문서를 가져옴
* 받아온 문서는 HTTP 메시지에 담겨 클라이언트에게 보냄

##### 1.8.4 터널
* 터널은 두 커넥션 사이에서 날(raw) 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션
* HTTP 터널은 주로 비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송해주기 위해 사용
* HTTP 터널을 활용하는 대표적인 예로, 암호화된 SSL 트래픽을 HTIP 커넥션으로 전송함으로써 웹 트래픽만 허용하는 사내 방화벽을 통과시키는 것

##### 1.8.5 에이전트
* 사용자 에이전트(혹은 그냥 에이전트)는 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램

#### 1.9 시작의 끝

#### 1.10 추가 정보

##### 1.10.1 HTTP 프로토콜에 대한 정보

##### 1.10.2 역사적 시각

##### 1.10.3 기타 월드 와이드 웹 정보

### 2장 URL과 리소스
* URL(Uniform Resource Locator)은 인터넷의 리소스틀 가리키는 표준이름

#### 2.1 인터넷의 리소스 탐색하기
* URL은 통합 자원 식별자(Uniform Resource Identifier) 혹은 URI라고 불리는 일반화된 부류의 부분집합
* URI는 두 가지 주요 부분집합인, URL과 URN으로 구성된 종합적인 개념
* HTIP 명세에서는 URI를 더 일반화된 개념의 리소스 식별자로 사용
* 실제로 HTTP 애플리케이션은 URL을 URI의 한 부분으로 취급
* URL을 사용하면 리소스를 일관된 방식으로 지칭할 수 있음

##### 2.1.1 URL이 있기 전 암흑의 시대
* URL은 애플리케이션이 리소스에 접근할 수 있는 방법을 제공
* URL은 당신과 브라우저에게 정보 찾는데 필요한 모든 것을 제공하며, 당신이 원하는 리소스가 어디에 위치하고 어떻게 가져오는지 정의

#### 2.2 URL 문법
* 대부분의 URL 스킴은 문법은 일반적으로 9개 부분으로 나뉨

```
<스킴>://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>
```

##### 2.2.1 스킴: 사용할 프로토콜
* URI을 해석하는 애플리케이션이 어떤 프로토콜을 사용하여 리소스를 요청해야 하는지 알려줌
* 스킴 컴포넌트는 알파벳으로 시작해야 하고 URL의 나머지 부분들과 첫 번째 ':' 문자로 구분

##### 2.2.2 호스트와 포트
* 호스트 컴포넌트는 접근하려고 하는 리소스를 가지고 있는 인터넷상의 호스트 장비
* 포트 컴포넌트는 서버가 열어놓은 네트워크 포트를 가리킴
* 내부적으로 TCP 프로토콜을 사용하는 HTTP는 기본 포트로 80을 사용

##### 2.2.3 사용자 이름과 비밀번호
* 서버가 자신이 가지고 있는 데이터에 접근을 허용하기 전에 사용자 이름과 비밀번호를 요구
* 예시
  * ftp://ftp.prep.ai.mit.edu/pub/gnu
  * ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu
  * ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu
  * http://jeo:joespasswd@www.joes-hardware.com/sales_info.txt

##### 2.2.4 경로
* URL의 경로 컴포넌트는 리소스가 서버의 어디에 있는지 알려줌

##### 2.2.5 파라미터
* URL을 사용하는 애플리케이션이 리소스에 접근하려면 프로토콜 파라미터가 필요

##### 2.2.6 질의 문자열
* URL의 질의 컴포넌트는 게이트웨이를 가리 키는 URL의 경로 컴포넌트와 함께 전달
* 편의상 많은 게이트웨이가 ‘&'로 나뉜 ‘이름=값' 쌍 형식의 질의 문자열을 원함

##### 2.2.7 프래그먼트
* URL은 리소스 내의 조각을 가리킬 수 있는 프래그먼트 컴포넌트를 제공
* 프래그먼트는 URL의 오른쪽에 # 문자에 이어서 옴

#### 2.3 단축 URL
* 상대 URL은 리소스 안에 있는 리소스를 간결하게 기술하는데 사용할 수 있음
* 많은 브라우저가 사용자가 기억하고 있는 URL 일부를 입력하면 나머지 부분을 자동으로 입 력해주는 URL '자동 확장'을 지원

##### 2.3.1 상대 URL

#### 2.4 안전하지 않은 문자

#### 2.5 스킴의 바다

#### 2.6 미래

#### 2.7 추가 정보

### 3장 HTTP 메시지

#### 3.1 메시지의 흐름 

#### 3.2 메시지의 각 부분

#### 3.3 메서드

#### 3.4 상태 코드 

#### 3.5 헤더

#### 3.6 추가 정보

### 4장 커넥션 관리

#### 4.1 TCP 커넥션

#### 4.2 TCP의 성능에 대한 고려

#### 4.3 HTTP 커넥션 관리 

#### 4.4 병렬 커넥션 

#### 4.5 지속 커넥션 

#### 4.6 파이프라인 커넥션 

#### 4.7 커넥션 끊기에 대한 미스터리

#### 4.8 추가 정보 
 
## II. HTTP 아키텍처 
 
### 5장 웹 서버 

#### 5.1 다채로운 웹 서버 

#### 5.2 간단한 펄 웹 서버 

#### 5.3 진짜 웹 서버가 하는 일 

#### 5.4 단계 1: 클라이언트 커넥션 수락

#### 5.5 단계 2: 요청 메시지 수신

#### 5.6 단계 3: 요청 처리

#### 5.7 단계 4: 리소스의 매핑과 접근

#### 5.8 단계 5: 응답 만들기 

#### 5.9 단계 6: 응답 보내기 

#### 5.10 단계 7: 로깅 

#### 5.11 추가 정보 
 
### 6장 프락시 

#### 6.1 웹 중개자 

#### 6.2 왜 프락시를 사용하는가? 

#### 6.3 프락시는 어디에 있는가? 

#### 6.4 클라이언트 프락시 설정 

#### 6.5 프락시 요청의 미묘한 특징들 

#### 6.6 메시지 추적 

#### 6.7 프락시 인증 

#### 6.8 프락시 상호운용성 

#### 6.9 추가 정보 
 
### 7장 캐시 

#### 7.1 불필요한 데이터 전송 

#### 7.2 대역폭 병목 

#### 7.3 갑작스런 요청 쇄도(Flash Crowds) 

#### 7.4 거리로 인한 지연 

#### 7.5 적중과 부적중 

#### 7.6 캐시 토폴로지 

#### 7.7 캐시 처리 단계 

#### 7.8 사본을 신선하게 유지하기 

#### 7.9 캐시 제어 

#### 7.10 캐시 제어 설정 

#### 7.11 자세한 알고리즘 

#### 7.12 캐시와 광고 

#### 7.13 추가 정보 
 
### 8장 통합점: 게이트웨이, 터널, 릴레이 

#### 8.1 게이트웨이 

#### 8.2 프로토콜 게이트웨이 

#### 8.3 리소스 게이트웨이 

#### 8.4 애플리케이션 인터페이스와 웹 서비스 

#### 8.5 터널 

#### 8.6 릴레이 

#### 8.7 추가 정보 

### 9장 웹 로봇 

#### 9.1 크롤러와 크롤링 

#### 9.2 로봇의 HTTP 

#### 9.3 부적절하게 동작하는 로봇들 

#### 9.4 로봇 차단하기 

#### 9.5 로봇 에티켓 

#### 9.6 검색엔진 

#### 9.7 추가 정보 

#### 10장 HTTP/2.0 

#### 10.1 HTTP/2.0의 등장 배경 

#### 10.2 개요 

#### 10.3 HTTP/1.1과의 차이점 

#### 10.4 알려진 보안 이슈 

#### 10.5 추가 정보 

## III. 식별, 인가, 보안 
 
### 11장 클라이언트 식별과 쿠키 

#### 11.1 개별 접촉 

#### 11.2 HTTP 헤더 

#### 11.3 클라이언트 IP 주소 

#### 11.4 사용자 로그인 

#### 11.5 뚱뚱한 URL 

#### 11.6 쿠키 

#### 11.7 추가 정보 
 
### 12장 기본 인증 

#### 12.1 인증 

#### 12.2 기본 인증 

#### 12.3 기본 인증의 보안 결함 

#### 12.4 추가 정보 

### 13장 다이제스트 인증 

#### 13.1 다이제스트 인증의 개선점 

#### 13.2 요약 계산 

#### 13.3 보호 수준(Quality of Protection) 향상 

#### 13.4 실제 상황에 대한 고려 

#### 13.5 보안에 대한 고려사항 

#### 13.6 추가 정보 
 
### 14장 보안 HTTP 

#### 14.1 HTTP를 안전하게 만들기 

#### 14.1.1 HTTPS 

#### 14.2 디지털 암호학 

#### 14.3 대칭키 암호법 

#### 14.4 공개키 암호법 

#### 14.5 디지털 서명 

#### 14.6 디지털 인증서 

#### 14.7 HTTPS의 세부사항 

#### 14.8 진짜 HTTPS 클라이언트 

#### 14.9 프락시를 통한 보안 트래픽 터널링 

#### 14.10 추가 정보 388

## IV. 엔터티, 인코딩, 국제화 
 
### 15장 엔터티와 인코딩 

#### 15.1 메시지는 컨테이너, 엔터티는 화물 

#### 15.2 Content-Length: 엔터티의 길이 

#### 15.3 엔터티 요약 

#### 15.4 미디어 타입과 차셋(Charset) 

#### 15.5 콘텐츠 인코딩 

#### 15.6 전송 인코딩과 청크 인코딩 

#### 15.7 시간에 따라 바뀌는 인스턴스 

#### 15.8 검사기와 신선도 

#### 15.9 범위 요청 

#### 15.10 델타 인코딩 

#### 15.11 추가 정보 
 
### 16장 국제화 

#### 16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원 

#### 16.2 문자집합과 HTTP 

#### 16.3 다중언어 문자 인코딩에 대한 지침 

#### 16.4 언어 태그와 HTTP 

#### 16.5 국제화된 URI 

#### 16.6 기타 고려사항 

#### 16.7 추가 정보 
 
### 17장 내용 협상과 트랜스코딩 

#### 17.1 내용 협상 기법 

#### 17.2 클라이언트 주도 협상 

#### 17.3 서버 주도 협상 

#### 17.4 투명 협상 

#### 17.5 트랜스코딩 

#### 17.6 다음 단계 

#### 17.7 추가 정보 

## V. 콘텐츠 발행 및 배포 
 
### 18장 웹 호스팅 

#### 18.1 호스팅 서비스 

#### 18.2 가상 호스팅 

#### 18.3 안정적인 웹 사이트 만들기 

#### 18.4 웹 사이트 빠르게 만들기 

#### 18.5 추가 정보 

### 19장 배포 시스템 

#### 19.1 배포 지원을 위한 FrontPage 서버 확장 

#### 19.2 WebDAV와 공동 저작 

#### 19.3 추가 정보 

### 20장 리다이렉션과 부하 균형 

#### 20.1 왜 리다이렉트인가? 

#### 20.2 리다이렉트 할 곳 

#### 20.3 리다이렉션 프로토콜의 개요 

#### 20.4 일반적인 리다이렉션 방법 

#### 20.5 프락시 리다이렉션 방법 

#### 20.6 캐시 리다이렉션 방법 

#### 20.7 인터넷 캐시 프로토콜

#### 20.8 캐시 배열 라우팅 프로토콜 

#### 20.9 하이퍼텍스트 캐싱 프로토콜 

#### 20.10 추가 정보 

### 21장 로깅과 사용 추적 

#### 21.1 로그란 무엇인가? 

#### 21.2 로그 포맷 

#### 21.3 적중 계량하기 

#### 21.4 개인 정보 보호에 대해 

#### 21.5 추가 정보