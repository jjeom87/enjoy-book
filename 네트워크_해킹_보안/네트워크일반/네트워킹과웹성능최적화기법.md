# 구글 엔지니어에게 듣는 네트워킹과 웹 성능 최적화 기법

## 1부 네트워킹 기초
### 1장 레이턴시와 대역폭 이해의 첫걸음
#### 속도는 하나의 특징이다
* 레이턴시 : 패킷을 전송하는 곳에서부터 전달받는 곳까지 이동하는 데 걸리는 시간
* 대역폭 : 논리적인 혹은 물리적인 통신 경로의 최대 처리량
#### 레이턴시의 구성요소
* 전파지연 (propagation delay) : 메시지가 송신측(Sender)에서 수신측(Receiver)으로 이동하는데 필요한 시간. 총 이동 거리 대비 신호가 이동하는 속도로 측정된다.
* 전송지연 (transmission delay) : 링크롤 패킷을 모든 비트를 내보내는 데 필요한 시간. 패킷의 길이 대비 링크의 데이터 전송 속도로 측정된다.
* 프로세싱 지연 (processing delay) : 패킷 해더를 처리하고 비트 수준의 에러를 체크하고 패킷의 목적지를 알아내는 데 필요한 시간.
* 큐잉 지연 (queuing delay) : 패킷이 처리될 때까지 큐(queue)에서 대기하는 시간
#### 빛의 속도와 전파 지연
* 광섬유의 보편적인 굴절률은 1.4 ~ 1.6
* 사용자들을 잘 붙잡아 두는 동시에 최고의 사용자 경험을 제공하기 위해서 애플리케이션은 수백 밀리초 이내에 응답할 수 있어야 함
#### 최종 마일 레이턴시
* 최종 마일 레이턴시는 인터넷 제공업체, 사용되는 기술, 네트워크의 토폴로지, 시간대에 따라 변경됨
#### 코어 네트워크의 대역폭
* 광섬유는 파장 분할 다중화를 통해 각 섬유마다 다른 파장의 빛을 이동시킬 수 있으므로 대역폭에 있어서는 확실한 이점을 가짐
* 광섬유 링크의 총 대역폭은 다중 송신되는 채널의 수에 채널별 데이터 전송률을 곱한 만큼의 값
#### 네트워크 가장자리에서의 대역폭
* 접속자 수가 많거나 하드웨어 오류 혹은 네트워크를 향한 디도스(DDOS) 공격 같은 여러가지 원인으로 인해 네트워크가 정체될 수 있음
#### 높은 대역폭과 낮은 레이턴시 제공
* 대역폭과 빛의 속도라는 한계점을 분명하게 인식하여 프로토콜과 네트워킹 코드를 설계하고 최적화해야만 애플리케이션 성능을 향상 시킬 수 있음
### 2장 TCP의 구성요소
* IP(Internet Protocol)는 호스트에서 호스트로의 라우팅과 주소할당 기능을 제공
* TCP(Transmission Control Protocol) 신뢰성을 보장해주는 네트워크 기능을 제공
* TCP는 신뢰할 수 없는 채널 위에 신뢰성을 구축한 추상 계층
* 네트워크 통신 구현에 필요한 유실 데이터 재전송, 전송 순서 확인, 혼잡 제어 및 회피 데이터 무결성 확인 같은 복잡한 기능을 투명하게 처리하여 애플리케이션 구현을 한결 쉽게 만듬
* TCP 스트림의 특징 중 하나가, 전송된 모든 바이트는 수신된 모든 바이트와 한 치의 오차 없이 동일
* 클라이언트에서 전송한 바이트 순서대로 도착
* TCP는 신속한 데이터 전송보다는 정확한 데이터의 전송에 더 특화
* HTTP 표준은 전송 프로토콜로서 오직 TCP만을 명시하고 있지 않음
#### 3-Way 핸드셰이크
* SYN : 클라이언트가 무작위로 시퀀스 번호 X를 고르고 SYN 패킷을 보낸다. 그 밖의 다른 TCP 플래그나 옵션 값들을 포함할 수 있다.
* SYN ACK : 서버가 시퀀스 번호 X를 1만큼 증가시키고, 무작위 시퀀스 번호 y를 고른다. 서버 또한 플래그와 옵션 값들을 추가한 후 응답을 보낸다.
* ACK : 클라이언트가 X와 Y를 모두 1만큼 증가시킨 후 마지막 ACK 패킷을 보냄으로써 핸드셰이크 과정을 종료한다.
* 3-Way 핸드셰이크가 끝나면 애플리케이션 데이터가 클라이언트와 서버 사이에 오고 갈 수 있음
* 3-Way 핸드셰이크로 인해 발생하는 지연이 크기 떄문에, 새로운 TCP 커넥션을 맺는 것보다 기존에 연결되어 있는 TCP 커넥션을 재사용하는 것이 TCP에서 작동하는 애플리케이션을 최적화하는 데에 아주 중요한 역할을 함
#### 혼잡 제어 및 회피
##### 흐름제어
* 흐름 제어는 송신자가 수신자에게 처리하지 못할 만큼의 많은 데이터를 전송하는 것을 미리 방지하는 매커니즘
* 리시브 윈도를 통지하여 수신 데이터를 저장할 버퍼 공간의 크기를 서로에게 알려줌
* 일단 커넥션이 이루어지면 양쪽에서 자신들의 시스템 기본 설정값을 이용하여 rwnd 값을 초기화함
##### 느린 시작
* 혼잡 윈도 크기 : 클라이언트로부터 응답 확인 신호를 받기 전에 송신자 측에서 지정하는 최대 송신 데이터량
* 서버와 클라이언트는 어떻게 혼잡 윈도 크기의 최적값을 알아내는 것일까?
* 커넥션의 초반에는 천천히 시작해서 ACK 패킷을 받으면서 점점 윈도 사이즈를 늘려 나가는 것
* 느린 시작이 최대로 사용할 수 있는 대역폭에 제한을 둠으로써 용량이 작은 데이터를 전송하는 데에는 부작용으로 다가옴
##### 혼잡 회피
* 패킷 손실이 일어나지 않는 경우는 없고 그보다 패킷 손실이 언제 발생하는가를 파악하는 것이 더 중요
* 암묵적으로 판단하기에 패킷 손실이 일어났다는 것은 네트워크 혼잡이 일어났다는 신호
* 이동 경로의 어딘가에서 정체가 일어난 링크나 라우터가 패킷을 손실을 막기 위해 원도 사이즈를 조정
* 일단 혼잡 윈도가 리셋되면, 혼잡 회피는 더 이상의 손실을 최소화 하기 위해 얼마나 윈도 크기를 늘려야 할지를 지정
#### 대역폭 지연 곱
* 데이터 링크의 허용량과 종단 간 지연을 곱한 값, 결과값은 ACK를 받지 않고 이동할 수 있는 데이터의 최대 양
#### Head-of-Line 블로킹
* 수신자에게 이동 중인 패킷 하나가 소실되면 다른 모든 패킷들은 소실된 패킷이 재전송될 때까지 수신자 쪽 TCP 버퍼에서 대기
* TCP 계층 내에서 이루어지기 때문에 애플리케이션에서는 TCP의 데이터 재전송 여부나 큐에 들어있는 패킷 버퍼를 살펴볼 수가 없음
* 애플리케이션 입장에서는 그저 소켓에서 데이터를 읽으려 했을 때 전달 지연을 겪게 될 뿐
* HOL 블로킹의 
** 장점
*** 애플리케이션이 패킷의 재배치나 재조합에 관여할 필요가 없기 때문에 애플리케이션의 코드 자체는 훨씬 간단해짐
** 단점
*** 패킷이 도착하는 시간이 들쭉날쭉 (jitter) 해서 레이턴시를 예측하기 어렵다는 점
#### TCP의 최적화
##### 서버 설정 조정하기
* 사용하는 호스트를 최신 시스템 버전으로 업그레이드
* TCP의 초기 혼잡 원도 크기 증가
* 느린 시작 다시 시작하기
* 윈도 스케일링
* TCP Fast Open
##### 애플리케이션의 동작 튜닝하기
* 비트를 보내지 않는 것보다 빠른 방법은 없다. 즉, 더 적은 수의 비트를 전송
* 데이터를 빨리 이동하게 할 수는 없지만 이동 거리를 줄일 수는 있다.
* TCP 커넥션 재사용은 성능 향상에 매우 중요하다.
##### 성능 체크리스트
* 서버 커널을 최신버전으로 업그레이드하라.
* 혼잡 윈도 크기를 10으로 설정하라.
* 유휴 상태 후 느린 시작을 비활성화하라.
* 윈도 스케일링을 활성화하라.
* 전송 데이터를 압축하라.
* 서버를 사용자와 가까운 곳에 배치하여 왕복 시간을 줄여라.
* 기존 TCP 거넥션을 가능한 한 재사용하라.
### 3장 UDP의 구성요소
* 데이터그램 : 전송 네트워크 계층에서 보장하는 신뢰 기반의 데이터 교환에 의존하지 않고, 충분한 양의 정보를 발신지에서 목적지까지 스스로 운반할 수 있는 독립적인 데이터 개체.
#### Null 프로토콜 서비스
* 메시지를 무사히 운반할 수 있다는 보장 없음
* 메시지를 순서대로 운반할 수 없음
* 커넥션 상태 트래킹 없음
* 혼잡 제어 없음
#### UDP와 네트워크 주소 변환기
* IPv4 주소 부족 문제를 해결하기 위해 1994년 중반에 IP Network Address Translator (RFC 1631) 스펙이 처음으로 소개
* 네트워크 끝에 NAT 기기를 설치해서, 로컬 IP와 포트 번호를 한 개 이상의 고유 공용 IP와 포트 번호에 짝지어 관리
##### 연결 상태 타임아웃
* UDP에서 NAT 변환 작업을 할 때 가장 큰 문제는 데이터 운반을 위해 라우팅 레이블을 관리
* UDP는 커넥션 상태 정보가 없으므로 참조할 수 있는 것이 없음
##### NAT 통과
* NAT 안쪽에 위치한 내부 클라이언트가 자신의 공용 IP를 모름
* 공용 IP를 안다고 해서 무조건 UDP로 데이터를 전송할 수 있는 것은 아님
* NAT의 공용 IP에 도착하는 모든 패킷은 반드시 목적지 포트를 포함해야 하고, 그 값이 NAT 테이블 내에 있어야 하며, 이를 내부 수신 호스트 IP와 포트 튜플로 변환할 수 있어야 함
##### STUN, TURN 그리고 ICE
* STUN (Session Traversal Utilities for NAT) : 호스트 애플리케이션이 네트워크상의 NAT 기기를 발견하고 현재의 커넥션에 지정된 공용 IP와 포트 튜플을 알아낼 수 있게 하는 프로토콜
* TURN (Traversal Using Relays around NAT) : STUN 실패했을 때 UDP를 버리고 TCP로 전환하는 기능\
* ICE (Interactive Connectivity Establishment) : 네트워크 참여자 간에 가장 효율적인 터널을 찾을 수 있는 프로토콜
#### UDP 최적화
* 인터넷 경로 상황에 폭넑게 대응할 수 있어야 한다.
* 데이터 전송률을 조절할 수 있어야 한다.
* 모든 트래픽의 혼잡 제어를 수행할 수 있어야 한다.
* TCP와 비슷한 대역폭을 사용해야 한다.
* 패킷 손실이 있을 때에는 재전송 카운터를 중단해야 한다.
* Path MTU를 넘어서는 데이터그램을 전송해서는 안 된다.
* 데이터그램 손실, 중복, 재정렬을 처리할 수 있어야 한다.
* 최대 전송지연 2분까지 감당할 수 있도록 설계해야 한다.
* IPv4 UDP 체크섬과 IPv6 체크섬을 반드시 활성화해야 한다.
* 필요한 경우 최소 15초 간격으로 킵얼라이브를 사용할 수 있다.
### 4장 전송 계층 보안
* SSL 프로토콜은 넷스케이프에서 전자상거래 보안을 강화하기 위해 처음 개발됨
* 암호화, 인증처리, 데이터무결성 등 여러 보안 기제가 필요한데, SSL 프로토콜은 TCP의 바로 위애서 작동함 (세션계층 ,TLS)
* SSL의 명칭이 TLS(Transport Layer Security, 전송 계층 보안)로 변경 
#### 암호화, 인증 그리고 무결성
* 암호화 : 한 컴퓨터에서 다른 컴퓨터로 보내는 데이터를 타인이 알아볼 수 없도록 하는 매커니즘
* 인증 : 제공된 식별 정보의 진위 여부를 확인하는 메커니즘
* 무결성 : 메시지가 무단으로 변경되었거나 위조되었는지 확인하는 메커니즘
#### TLS 핸드셰이크
* 클라이언트와 서버가 TLS를 통해 애플리케이션 데이터를 주고받기 전에, 먼저 암호화된 터널을 형성해야 함
* 모든 TLS 커넥션이 TCP 핸드셰이크에 추가로 최대 두 번의 왕복 시간을 요구함
##### 애플리케이션 계층 프로토콜 협상(ALPN) ??
* TLS 핸드셰이크 과정에서 애플리케이션 프로토콜 협상할 수 있게 하는 TLS 확장
##### 서버 이름 표시 (Server Name Indication, SNI)
* 서버 이름 표시는 TLS 핸트셰이크가 시작될 때 클라이언트가 연결하려는 호스트 명을 지정 할 수 있다. 
따라서 웹 서버가 서버 이름 표시 호스트 명을 살펴보고 해당 인증서를 선택하여 핸트세이크를 진행 할 수 있음
#### TLS 세션 재개
* TSL는 여러 커넥션 사이에서 동일한 비밀키 데이터를 재개하거나 공유할 수 있음
##### 세션 식별자 (ID)
* 서버가 TLS 협상 도중에 "ServerHello" 메세지의 일부로 32바이트 세션 식별자를 생성하고 전송하도록 하는 장치
##### 세션 티켓
* 세션 티켓 교체 메커니즘을 사용하면 서버가 각 클라이언트마다 고유 세션 상태를 보유하지 않음
* 클라이언트가 서버에게 세션 티켓 지원 여부를 알려주면, TLS 핸드셰이크의 마지막 교환 단계에서 서버가 자신만의 비밀키로 모든 세션 데이터를 암호화하여 세션 티켓 레코드를 포함
* 세션 티켓은 클라이언트가 보관
#### 신뢰 사슬(Chain of Trust)과 인증기관
* 수동으로 지정된 인증서 : 모든 브라우저와 운영체제에는 사용자가 신뢰하는 인증서를 수동으로 불러올 수 있는 기능이 있다. 그 인증서를 어떤 경로로 얻어서 신뢰성을 확인할지는 모두 사용자에게 달려 있다.
* 인증기관 : 인증기관(CA)은 인증서의 사용자와 그 인증서를 의존하고 있는 단체 모두가 신뢰하고 있는 제3의 단체다.
* 브라우저와 운영체제 : 모든 운영체제와 브라우저는 잘 알려진 인증기관의 목록을 보유하고 있다. 따라서 해당 소프트웨어 판매업체가 관리하고 있는 신뢰할 만한 단체의 목록을 자동적으로 신뢰하게 된다.
#### 인증서 폐기
* 인증서의 개인키가 노출되거나, 인증기관 자체가 해킹 공격을 당하는 경우, 혹은 인증서를 교체해야 하거나 소속 기관이 바뀌는 경우처럼 사요한 이유로도 인증서를 폐기할 수 있음
##### 인증서 폐기 리스트 (Certificate Revocation List, CRL)
* 각 인증기관은 폐기된 인증서의 시리얼 넘버를 리스트로 만들어 주기적으로 발표
##### 온라인 인증 상태 프로토콜(OSCP)
* 폐기된 인증서의 시리얼 넘버를 모두 보유하고 있는 CRL과는 달리, OCSP에서는 클라이언트가 직접 인증서 데이터베이스에 쿼리를 날려 시리얼 넘버의 유효성을 실시간으로 체크
#### TLS 레코드 프로토콜
