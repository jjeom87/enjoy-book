# 도메인 주도 설계 구현

## 1장 DDD를 시작하며
* DDD란 프로젝트의 진로를 막는 어떤 무겁고, 압축되고, 의식이 거창한 과정이 아니다.
* 비즈니스 영역의 깊은 통찰을 얻도록 도와줄 것이며, 테스트 가능하고, 변형 가능하고, 정리되어 있으며, 정교하게 만들어진 고품질의 소프트웨어 모델을 만들게 해줄 것
* **DDD는 전략적인 동시에 전술적인 모델링 도구로서 중요한 비즈니스 목적을 달성시킬 수 있는 양질의 소프트웨어를 설계하게 해줄 것**

### 나도 DDD 할 수 있을까?

### 내가 왜 DDD를 해야 할까?
* 설계는 코드이며, 코드가 설계다.
* DDD는 전략적이고 전술적인 설계를 다룰 수 있는 온전한 소프트웨어 개발 기술을 제공한다.

#### 비즈니스 가치를 제공하는 것은 어려울 수 있다
* 일반적인 비즈니스 소프트웨어의 개발 VS 진정한 비즈니스 가치를 제공하는 소프트웨어의 개발

#### DDD가 해줄 수 있는 일

#### 도메인의 복잡성과 씨름하기

#### 무기력증과 기억 상실

#### 왜 무기력증이 일어나는가

#### 무기력증이 당신의 모델에 한 일을 보라.

### DDD는 어떻게 하는가?
* 유비쿼터스 언어는 소프트웨어 모델 자체에 특정 핵심 비즈니스 도메인의 개념과 용어를 포작하는 데 사용되는 팀의 패턴

#### 유비쿼터스지만 보편적이지는 않다.

### DDD를 사용하는 데서 오는 비즈니스 가치
* 어떤 기술이나 기법을 사용할 때의 가장 훌륭한 정당화는 비즈니스에 가치를 제공하는 경우
1. 조직이 그 도메인에 유용한 모델을 얻는다.
2. 정교하고 정확하게 비즈니스를 정의하고 이해한다.
3. 도메인 전문가가 소프트웨어 설계에 기여한다.
4. 사용자 경험이 개선된다.
5. 순수한 모델 주변에 명확한 경계가 생긴다.
6. 엔터프라이즈 아키텍처의 구성이 좋아진다.
7. 애자일하고, 반복적이고, 지속적인 모델링이 사용된다.
8. 전략적인 동시에 전술적인 새로운 도구가 적용된다.

#### 1. 조직이 그 도메인에 유용한 모델을 얻는다.

#### 2. 정교하고 정확하게 비즈니스를 정의하고 이해한다.

#### 3. 도메인 전문가가 소프트웨어 설계에 기여한다.

#### 4. 사용자 경험이 개선된다.

#### 5. 순수한 모델 주변에 명확한 경계가 생긴다.

#### 6. 엔터프라이즈 아키텍처의 구성이 좋아진다.

#### 7. 애자일하고, 반복적이고, 지속적인 모델링이 사용된다.

#### 8. 전략적인 동시에 전술적인 새로운 도구가 적용된다.

### DDD 적용의 난관
* 유비쿼터스 언어를 만드는 데 드는 시간과 노력을 계산하는 것
* 도메인 전문가를 시작부터 참여시키고 프로젝트 내내 함께하는 것
* 도메인 내의 해결책에 관한 개발자의 사고방식을 바꾸는 것

#### 도메인 모델링의 합리화

#### DDD는 무겁지 않다

### 소설과 한 바구니의 현실

### 마무리

## 2장 도메인, 서브도메인, 바운디드 컨텍스트

### 큰 그림

#### 서브도메인과 바운디드 컨텍스트의 활용

#### 핵심 도메인에 집중하기

### 왜 전략적 설계가 엄청나게 필수적인가

### 현실의 도메인과 서브도메인

### 바운디드 컨텍스트 이해하기

#### 모델 그 이상을 위해

#### 바운디드 컨텍스트의 크기

#### 기술적 컴포넌트로 정렬하기

### 샘플 컨텍스트

#### 협업 컨텍스트

#### 식별자와 액세스 컨텍스트

#### 애자일 프로젝트 관리 컨텍스트

### 마무리

## 3장 컨텍스트 맵

### 컨텍스트 맵이 필수적인 이유

#### 컨텍스트 맵 그리기

#### 프로젝트와 조직 관계

#### 세 가지 컨텍스트를 매핑하기

#### 협업 컨텍스트

#### 애자일 프로젝트 관리 컨텍스트

#### 식별자와 액세스 컨텍스트의 통합

#### 협업 컨텍스트와 통합

###마무리

## 4장 아키텍처

### 성공한 CIO와의 인터뷰

### 계층

#### 의존성 역행 원리

### 헥사고날 또는 포트와 어댑터

### 서비스 지향

### REST: 표현 상태 전송(Representational State Transfer)

#### 스테판 틸코프의 참여

#### 아키텍처 스타일으로서의 REST

#### 레스트풀 HTTP 서버의 주요 특징

#### 레스트풀 HTTP 클라이언트의 주요 특징

#### REST와 DDD

#### 왜 REST인가?

### 커맨드-쿼리 책임 분리

#### CQRS의 영역 살펴보기

#### 결국은 일관성이 유지되는 쿼리 모델 다루기

### 이벤트 주도 아키텍처

#### 파이프와 필터

#### 장기 실행 프로세스(사가라 불리는)

#### 이벤트 소싱

### 데이터 패브릭과 그리드 기반 분산 컴퓨팅

#### 웨스 윌리암스 기고

#### 데이터 복제

#### 이벤트 주도 패브릭과 도메인 이벤트

#### 지속적 쿼리

#### 분산 처리

### 마무리

## 5장 엔터티

### 엔터티를 사용하는 이유

### 고유 식별자

#### 사용자가 식별자를 제공한다

#### 애플리케이션이 식별자를 생성한다

#### 영속성 메커니즘이 식별자를 생성한다.

#### 또 하나의 바운디드 컨텍스트가 식별자를 할당한다

#### 식별자 생성의 시점이 문제가 될 때

#### 대리 식별자

#### 식별자 안정성

### 엔터티의 발견과 그들의 내부적인 특성

#### 엔터티와 속성을 알아내기

#### Digging for Essential Behavior

#### 역할과 책임

#### 생성

#### 유효성 검사

### 마무리

## 6 값 객체

### 값의 특징

#### 측정, 수량화, 설명

#### 불변성

#### 개념적 전체

#### 대체성

#### 값 등가성

#### 부작용이 없는 행위

### 미니멀리즘으로 통합하기

### 값으로 표현되는 표준 타입

### 값 객체의 테스트

### 구현

### 값 객체의 저장

#### 데이터 모델 누수의 부정적 영향을 거부하라

#### ORM과 단일 값 객체

#### ORM과 한 열로 직렬화되는 여러 값

#### ORM과 데이터베이스 엔터티로 지원되는 여러 값

#### ORM과 조인 테이블로 지원되는 여러 값

#### ORM과 상태로서의 열거형 객체

### 마무리

## 7 서비스

### 도메인 서비스란 무엇인가(하지만 먼저 도메인 서비스가 아닌 것은 무엇인가)

### 서비스가 필요한지 확인하자

### 도메인에서 서비스를 모델링하기

#### 분리된 인터페이스가 꼭 필요할까

#### 계산 프로세스

#### 변환 서비스

#### 도메인 서비스의 미니 계층 사용하기

### 서비스의 테스트

### 마무리

## 8 도메인 이벤트

### 언제 그리고 왜 도메인 이벤트를 사용할까?

### 이벤트의 모델링

#### 애그리게잇의 특성과 함께하기

#### 식별자

### 도메인 모델에서 이벤트를 발행하기

#### 발행자

#### 구독자

### 뉴스를 원격 바운디드 컨텍스트로 전파하기

#### 메시징 인프라의 일관성

#### 자치 서비스와 시스템

#### 지연시간 허용

### 이벤트 저장소

### 저장된 이벤트의 전달을 위한 아키텍처 스타일

#### 레스트풀 리소스로써 알림을 발행하기

#### 메시징 미들웨어를 통한 알림 발행

### 구현

#### NotificationLog의 발행

#### 메시지에 기반한 알림 발행하기

### 마무리

## 9 모듈

### 모듈로 설계하기

### 기본 모듈 명명 규칙

### 모델을 위한 모듈 명명 규칙

### 애자일 프로젝트 관리 컨텍스트의 모듈

### 다른 계층 속의 모듈

### 바운디드 컨텍스트보다 모듈

### 마무리

## 10 애그리게잇

### 스크럼 핵심 도메인에서 애그리게잇 사용하기

#### 첫 번째 시도: 큰 클러스터의 애그리게잇

#### 두 번째 시도: 다수의 애그리게잇

### 규칙: 진짜 고정자를 일관성 경계 안에 모델링하라

### 규칙: 작은 애그리게잇으로 설계하라

#### 유스케이스를 전부 믿지는 말라

### 규칙: ID로 다른 애그리게잇을 참조하라

#### 애그리게잇이 ID 참조를 통해 서로 함께 동작하도록 해보자

#### 모델 탐색

#### 확장성과 분산

### 규칙: 경계의 밖에선 결과적 일관성을 사용하라

#### 누가 해야 하는 일인지 확인하자

### 규칙을 어겨야 하는 이유

#### 첫 번째 이유: 사용자 인터페이스의 편의

#### 두 번째 이유: 기술적 메커니즘의 부족

#### 세 번째 이유: 글로벌 트랜잭션

#### 네 번째 이유: 쿼리 성능

#### 규칙을 지키기

### 발견을 통해 통찰 얻기

#### 설계를 다시 한 번 생각해보자

#### 애그리게잇 비용의 예측

#### 일반적인 사용 시나리오

#### 메모리 소비

#### 또 다른 설계 대안 살펴보기

#### 결과적 일관성의 구현

#### 이는 팀원이 할 일인가?

#### 결정의 시간

### 구현

#### 고유 ID와 루트 엔터티를 생성하라

#### 값 객체 파트를 선호하라

#### '데메테르의 법칙’과 ‘묻지 말고 시켜라’를 사용하기

#### 낙관적 동시성

#### 의존성 주입을 피하라

### 마무리

## 11 팩토리

### 도메인 모델 내의 팩토리

### 애그리게잇 루트상의 팩토리 메소드

#### CalendarEntry 인스턴스 생성하기

#### Discussion 인스턴스 생성하기

### 서비스의 팩토리

### 마무리

## 12 리파지토리

### 컬렉션 지향 리파지토리

#### 하이버네이트 구현

#### 탑링크 구현에 대한 고려

### 영속성 지향의 리파지토리

#### 코히어런스 구현

#### 몽고DB 구현

### 추가적인 행동

### 트랜잭션의 관리

#### 경고

### 타입 계층구조

### 리파지토리 대 데이터 액세스 객체

### 리파지토리의 테스트

#### 인메모리 구현으로 테스트하기

### 마무리

## 13 바운디드 컨텍스트의 통합

### 통합의 기본

#### 분산 시스템은 근본적으로 다르다

#### 시스템 경계에 걸친 정보의 교환

### 레스트풀 리소스를 사용한 통합

#### 레스트풀 리소스의 구현

#### 부패 방지 계층을 통한 REST 클라이언트의 구현

### 메시징을 사용한 통합

#### 제품 소유자와 팀 멤버의 정보를 계속해서 제공받는 것

#### 당신은 책임을 감당할 수 있는가

#### 장기 실행 프로세스와 책임의 회피

#### 프로세스 상태 머신과 타임아웃 트래커

#### 메시징이나 시스템을 활용할 수 없을 때

#### 좀 더 복잡한 프로세스 설계하기

### 마무리

## 14 애플리케이션

### 사용자 인터페이스

#### 도메인 객체의 렌더링

#### 애그리게잇 인스턴스로부터 데이터 전송 객체를 렌더링하기

#### 애그리게잇 내부 상태를 발행하기 위해 중재자를 사용하자

#### 도메인 페이로드 객체로부터 애그리게잇 인스턴스를 렌더링하라.

#### 애그리게잇 인스턴스의 상태 표현

#### 유스케이스 최적 리파지토리 쿼리

#### 다수의 개별 클라이언트를 처리하기

#### 변환(Rendition) 어댑터와 사용자 편집의 처리

### 애플리케이션 서비스

#### 애플리케이션 서비스 예제

#### 결합이 분리된 서비스 출력

### 여러 바운디드 컨텍스트 묶기

### 인프라

### 엔터프라이즈 컴포넌트 컨테이너

### 마무리

## 15 애그리게잇과 이벤트 소싱: A+ES

### 애플리케이션 서비스의 내부

### 커맨드 핸들러

### 람다 구문

### 동시성 제어

### A+ES의 구조적 자유

### 성능

### 이벤트 저장소의 구현

### 관계형으로 저장하기

### 블롭(BLOB)으로 저장하기

### 집중된 애그리게잇

### 읽기 모델 투영

### 애그리게잇 설계와 함께 사용하기

### 이벤트 강화

### 지원 도구와 패턴

#### 이벤트 직렬화기

#### 이벤트 불변성

#### 값 객체

### 계약 생성

### 단위 테스트와 명세

### 함수형 언어에서의 이벤트 소싱
