# 도메인주도설계
* 소프트웨어 요소의 일정 부분이 모델의 요소에 밀접하게 대응하는 설계. 또한 서로 긴밀한 관계에 있는 모델과 구현을 함께 개발하는 과정.

![도메인주도설계](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_0-1.png)

## 01부 동작하는 도메인 모델 만들기
* **사용자가 프로그램을 사용하는 대상 영역이 바로 해당 소프트웨어의 도메인**
* **모델은 지식을 선택적으로 단순화히고 의식적으로 구조화한 형태다.**
* **도메인 모델은 어떤 특정한 다이어그램이 아니라 다이어그램이 전달하고자 하는 아이디어**
* 도메인 모델은 단지 도메인 전문가의 머릿속에만 존재하는 지식이 아니라 해당 지식을 엄격하게 구성하고 선택적으로 추상화한 것
* 신중하게 작성된 코드나 우리가 쓰는 문장이 그렇듯 우리는 다이어그램을 이용해 모델을 표현히코 전달할 수 있음
* 도메인 모델링은 가능한 한 '사실적인' 모델을 만드는 문제가 아니댜 현실 세계에 실재하는 사물에 대한 도메인에서도 모델은 인위적 창조물
* 단순히 필요한 결과를 내는 소프트웨어 메커니즘을 만드는 것도 아님
* 모델은 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태

### 도메인 주도 설계에서의 모델의 유용성
1. 모델과 핵심 설계는 서로 영향을 주며 구체화
2. 모델은 모든 팀 구성원이 사용하는 언어의 중추
3. 모델은 지식의 정수만을 뽑아낸 것
  * 모델은 도메인 지식을 조직화하고 가장 중요한 요소를 구분하는 팀의 합의된 방식
* 목표
  * **기술보다는 도메인에 대한 모델에 집중해 더 나은 소프트웨어를 만들어내는 것**

### 소프트웨어의 본질
* 소프트웨어의 본질은 해당 소프트웨어의 사용자를 위해 도메인에 관련된 문제를 해결하는 능력
* 도메인 업무는 무질서하고 컴퓨터 과학자로서의 능력에 보탬이 될 것 같지 않은 복잡하고 새로운 지식을 많이 요구
* *개발자들이 통찰력을 추구하고 효과적인 모델을 만드는 데 활용할 수 있는 체계적인 사고방식과 불규칙하게 뻗어 나가는 소프트웨어 애플리케이션에 질서를 부여할 수 있는 설계 기법이 있다. 이러한 기술을 연마한다면 심지어 처음으로 접하는 익숙지 않은 도메인에서도 여러분은 훨씬 더 가치 있는 개발자로 거듭날 것이다.*

### 01장 지식 탐구
* 도메인 전문가와 개발자가 함께 지식을 면밀히 검토하면서 모델을 정제

#### 효과적인 모델링의 요소
1. 모델과 구현의 연계.
2. 모델을 기반으로 하는 언어 정제.
3. 풍부한 지식이 담긴 모델 개발.
4. 모델의 정제.
5. 브레인스토밍과 실험.

#### 지식 탐구
* 효과적으로 도메인 모델링을 수행하는 사람들도 지식을 면밀히 탐구
1. 엄청난 양의정보 속에서 아주 미미한 관련성을 찾아냄
2. 전체를 이해할 수 있는 간결한 관점을 찾아 체계적인 아이디어들을 차례로 시도
3. 그 과정에서 수많은 모델이 시도 거부 변형
4. 모든 세부사항에 들어 맞는 일련의 추상적 개념이 나타나면 비로소 성공에 이름
5. 이렇게 해서 뽑아낸 정수는 가장 적절한 것으로 밝혀진 특정 지식을 엄밀하게 표현한 것
* 도메인 전문가들은 자신이 알고 있는 지식의 정수만을 추출해내야 하므로 스스로 이해하는 바를 자주 정제하고, 그리하여 소프트웨어 프로젝트에서 요구하는 개념적 엄밀함(conceptual rigor)을 이해하게 됨
* 모델이 점점 향상되면서 모델은 프로젝트 내내 계속해서 흘러가는 정보들을 조직화하는 도구로 자리잡음
* 모델은 결코 완벽해질 수 없으며, 다만 계속 발전해나갈 뿐
* 모델은 쉽게 구현하고 이해하기에 충분할 만큼 엄밀해야함

#### 지속적인 학습
* **소프트웨어를 작성하기 시작할 때 우리는 충분히 알지 못한 상태에서 시작한다.**
* **우리는 스스로 얼마나 알지 못하는가를 깨닫지 못하는 것이다.**
* 생산성이 매우 뛰어난 팀은 지속적인 학습을 바탕으로 의식적으로 지식을 함양

#### 풍부한 지식이 담긴 설계
* 모델에 포착돼 있는 지식은 단순한 "명사 찾기" 이상
* 도메인에 관련된 엔티티 만큼 업무 활동과 규칙도 도메인에 중요한데, 어떠한 도메인에도 다양한 범주의 개념이 존재한다

##### 예제

###### 감춰진 개념 추출하기
* 예약 애플리케이션의 책임이 각 Cargo(화물)를 하나의 Voyage(운항)와 연관관계를 맺고, 것을 기록 관리하는 것

![도메인주도설계](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_1-8.png)

```java
public int makeBooking(Cargo cargo, Voyage voyage) {
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

* 초과예약(overbooking)

![도메인주도설계](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_1-9.png)

```java
public int makeBooking(Cargo cargo, Voyage voyage) {
    double maxBooking = voyage.capacity() * 1.1;
    if ((voyage.bookedCargoSize() + cargo.size()) > maxBooking)
        return=1;
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

* 정책이란 잘 알려진 STRATEGY(Gamma et al. 1995) 디자인 패턴의 또 다른 이름

* 초과예약 별개의 정책

![도메인주도설계](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_1-10.png)

```java
public int makeBooking(Cargo cargo, Voyage voyage) {
    if (!overbookingPolicy.isAllowed(cargo, voyage)) return -1;
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

* Overbooking Policy(초과예약 정책)

```java
public boolean isAllowed(Cargo cargo, Voyage voyage) {
    return (cargo.size() + voyage.bookedCargoSize()) <= (voyage.capacity() * 1.1);
}
```

* "디스틸레이션"에서는 중요한 것에만 집중하고 나머지는 축소하거나 분리하는 방법

#### 심층 모델
* 도메인 전문가의 주된 관심사와 도메인과 가장 관련이 깊은 지식을 적확하게 표현한 것.
* 심층 모델은 도메인의 피상적 측면과 초보적인 수준의 해석을 탈피함.
* 유용한 모델은 겉으로 드러나 있는 경우가 거의 없음
* 도메인과 애플리케이션의 요구사항을 이해하게 되면서 대체로 처음에 중요하게 생각했던 피상적인 모델 요소를 버리거나 관점을 바꿈
* 처음에는 나타나기 힘들지만 문제의 핵심을 관통하는 포착하기 힘든 추상화가 서서히 나타나기 시작

### 02장 의사소통과 언어 사용
* 모델 기반 의사소통은 통합 모델링 언어(Unified Modeling Language, UML)상의 다이어그램으로 한정돼서는 안 됨
* 모델을 가장 효과적으로 사용하려면 모든 의사소통 수단에 스며들 필요가 있음

#### UBIQUITOUS LANGUAGE (보편 언어)
* 도메인 모델에 따라 구조화되어 모든 팀원이 소프트웨어와 팀의 모든 활동을 연계하는데 사용하는 언어
* 공통 언어가 없는 프로젝트에서는 개발자가 도메인 전문가를 위해 자신들의 언어를 번역
* 도메인 전문가도 개발자 간의, 그리고 다른 도메인 전문가 간의 언어를 번역
* 프로젝트에서 사용하는 언어가 분열되면 심각한 문제가 발생한다. 도메인 전문가는 자신의 전문 용어를 사용하고 기술적인 업무를 맡은 팀원들은 설계 측면에서 도메인에 관한 토론에 적합한 자신들만의 언어를 사용
* 일상적인 토론에서 쓰이는 용어가 코드(궁극적으로 가장 중요한 소프트웨어 프로젝트 산출물)에 녹아든 용어와 단절된다.
* 같은 사람인데도 말할 때나 글을 쓸 때 서로 다른 용어를써서 도메인의 가장 간결히고 명확한 표현이 일시적인 형태로 나타났다가 코드나 문서에도 담기지 않는 결과가 나타나기도 함
* 번역은 의사소통을 무디게 하고 지식 탐구를 빈약하게 만듬
* 일부 사람들만 쓰는 언어는 모두의 필요를 충족하지 못히므로 공통 언어가 될 수 없음
* UBIQUITOUS LANGUAGE를 구성하는 어휘에는 클래스와 주요한 연산의 이름
* 모델을 언어의 근간으로 사용하라. 팀 내 모든 의사소통과 코드에서 해당 언어를 끊임없이 적용하는데 전념하라.
* 다이어그램과 문서에서, 그리고 특히 말할 때 동일한 언어를 사용하라.
* 대안 모델을 반영하는 대안이 되는 표현을 시도해 봄으로써 어려움을 해소하라.
* 새로운 모델에 맞게끔 클래스, 메서드, 모듈의 이름을 다시 지으면서 코드를 리팩터링하라.
* 일상적으로 쓰는 단어의 의미에 동의를 이끌어내는 것과 같은 방식으로 대화할 때 쓰는 용어의 혼란도 해결하라.
* UBIQUITOUS LANGUAGE의 변화가 곧 모델의 변화라는 것을 인식하라.
* 도메인 전문가는 도메인을 이해하는 데 부자연스럽고 부정확한 용어나 구조에 대해 반대 의사를 표명해야 한다.
* 개발자는 설계를 어렵게 만드는 모호함과 불일치를 찾아내는 데 촉각을 곤두세워야 한다.

##### 예제

###### 화물의 운송 항로 고안하기
* 시나리오1 : 도메인에 대한 최소한의 추상화

![도메인주도설계](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_2-1.png)

* 시나리오2 : 논의를 돕는 풍성한 도메인 모델

![도메인주도설계](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_2-2.png)

#### 크게 소리내어 모델링하기
* 시스템에 관해 이야기를 주고받을 때 모델을 사용하라.
* 모델의 요소와 싱호작용을 이용하고 모델이 허용하는 범위에 개념을 조합하면서 시나리오를 큰 소리로 말해보라.
* 표현해야 할 것을 더 쉽게 말하는 방법을 찾아낸 다음 그러한 새로운 아이디 어를 다이어 그램과 코드에 적용하라.

#### 한 팀, 한 언어
* 수준 높은 도메인 전문가도 해당 모델을 이해하지 못한다면 모델이 뭔가 잘못된 것이다.
* UBIQUITOUS LANGUAGE가 마련되면 개발자 간의 대화, 도메인 전문가 간의 논의, 코드 자체에 포함된 표현까지 이 모든 것이 공유된 도메인 모델에서 비롯된 동일한 언어를 기반

![도메인주도설계](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_2-3.png)

#### 문서와 다이어그램
* 간결히고 형식에 얽매이지 않은 UML 다이어그램은 논의의 구심점 역할을 할 수 있음
* 설계의 생생한 세부사항은 코드에 담김
* 모델은 다이어그램이 아니라는 점을 항상 명심

##### 글로 쓴 설계 문서
* **문서는 코드와 말을 보완하는 역할을 해야 한다**
* 문서는 코드가 이미 잘 히고 있는 것을 하려고 해서는 안 된다.
* **문서는 유효한 상태를 유지하고 최신 내용을 담고 있어야 한다**
* 문서는 프로젝트 활동과 관련을 맺고 있어야 한다.

##### 실행 가능한 기반
* 올바르게 실행되는 것뿐만 아니라 올바른 의미를 전달하는 코드를 작성히자면 엄청나게 세심한 노력을 기울어야 한다.

#### 설명을 위한 모델
* 모델이 구현, 설계, 의사소통의 기초가 돼야 한다는 것
* 모델은 도메인을 가르치는 도구로도 아주 유용할 수 있다.
* 다른 모델이 필요한 이유 가운데 특별한 한 가지는 바로 범위 때문
* 설명을 위한 모델이 꼭 객체 모델일 필요는 없으며, 오히려 그렇지 않을 때가 일반적으로 가장 좋다.

#### 예제

##### 해운 활동과 항로

![운송 항로를 나타내는 클래스 다이어그램](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_2-4.png)

![운송 항로에 대한 설명을 위한 모델](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_2-5.png)

### 03장 모델과 구현의 연계

#### MODEL-DRIVEN DESIGN (모델 주도 설계)
* 소프트웨어 요소의 일정 부분이 모델의 요소에 밀접하게 대응하는 설계 또한 서로 긴밀한 관계에 있는 모델과 구현을 함께 개발하는 과정.
* 설계 혹은 설계의 주된 부분이 도메인 모델과 대응하지 않는다면 그 모델은 그다지 가치가 없으며 소프트웨어의 정확힘도 의심스러워진다.
* 동시에 모델과 설계 기능 사이의 복잡한 대응은 이해하기 힘들고, 실제로 설계가 변경되면 유지보수가 불가능해진다. 분석과 설계가 치명적으로 동떨어 지고, 그에 따라 각자의 활동에서 얻은 통찰력이 서로에게 전해지지 않는다.
* 모델로부터 설계와 기본적인 책임 할당에 사용한 용어를 도출하라. 코드를 작성할 때 그러한 용어를 사용하면 코드가 모델을 표현한 것이 되고, 코드의 변경이 곧 모델의 변경으로 이어질 수 있다. 그 효과는 프로젝트의 나머지 활동에도 퍼져나가야 한다.
* 구현을 모델과 그대로 묶으려면 보통 객체지향 프로그래밍과 같은 모델링 패러다임을 지원하는 소프트웨어 개발 도구와 언어가 필요하다.

#### 모델링 패러다임과 도구 지원
* 객체지향 프로그래밍은 모델링 패러다임에 근거히고 모델의 구성요소에 대한 구현을 제공하기 때문에 매우 효과적
* 객체 설계에서의 진정한 도약은 코드가 모델의 개념을 표현할 때 나옴
* 도메인의 중요한 개념만 추출해서 간결하고 예리한 모델로 표현하려면 리팩터링과 지식 탐구의 과정을 수차례에 걸쳐 반복해야 할 것

##### 예제

###### 기계적인 설계
* 풍부한 기능과 싱호작용을 원한다면 그에 상응하는 대가를 빠짐 없이 치러야 할 것

###### 모델 주도 설계
* 도메인의 중요한 개념만 추출해서 간결하고 예리한 모델로 표현하려면 리팩터링과 지식 탐구의 과정을 수차례에 걸쳐 반복

#### 내부 드러내기: 왜 모델이 사용자에게 중요한가
* 설계가 사용자와 도메인 전문가의 기본적인 관심사를 반영하는 모델에 기반을두면 설계의 골격이 다른 설계 접근법에 비해 더 큰 범위에 걸쳐 사용자에게 드러날 수 있음
* 모델이 드러나면 사용자가 소프트웨어의 잠재력을 좀더 많이 접하게 되어 일관성 있고 예상 가능한 행위가 나타날 것

#### HANDS-ON MODELER (실천적 모델러)
* 각기 전문화된 역할이 있지만 분석과 모델링, 설계, 프로그래밍에 대한 책임을 지나치게 구분하는 것은 MODEL-DRIVEN DESIGN과 상충
* 코드를 작성하는 사람이 모델에 책임을 느끼지 못하거나 애플리케이션을 대싱으로 모델이 동작하게 만드는 법을 모른다면 그 모델은 소프트웨어와 무관
* 코드의 변경이 곧 모델의 변경이라는 점을 개발자가 인식하지 못하면 리팩터링은 모델을 강화하기보다는 약화시킬 것
* 한편으로 모델러가 구현 프로세스와 분리돼 있을 경우, 구현상의 제약조건을 감안하는 능력을 결코 갖추지 못하거나 금방 잃어버릴 것
* 모델이 효과적인 구현을 뒷받침하고 핵심 도메인 지식을 추상화한다는 MODEL-DRIVEN DESIGN의 기본적인 제약조건은 절반쯤 사라지고, 결과로 나타나는 모델은 실용적이지 못할 것
* MODEL-DRIVEN DESIGN을 코드로 만드는 과정의 미묘한 사항들은 협업을 통해 알 수 있는데, 설계지가 구현을 하지 못해 개발자와 업무의 단절이 생기면 숙련된 설계자의 지식과 솜씨는 결코 다른 개발자에게 전해지지 못할 것
* 모델에 기여하는 모든 기술자는 프로젝트 내에서 수행하는 일차적 역할과는 싱콴없이 코드를 접하는 데 어느 정도 시간을 투자해야만 함
* 코드를 변경하는 책임이 있는 모든 이들은 코드를통해 모델을 표현하는 법을 반드시 배워야 한다. 모든 개발자는 모델에 관한 일정 수준의 토의에깊이 관여해야 하고 도메인 전문가외도 접촉
* 다른 방식으로 모델에 기여하는 사람들은 의식적으로 코드를 접하는 사람들과 UBIQUITOUS LANGUAGE를 토대로 모델의 아이디어를 나누는 데 적극 참여

## 02부 모델 주도 설계의 기본 요소

### 04장 도메인의 격리
* 시스템에서 도메 인과 관련이 적은 기능으로부터 도메인 객체를 분리할 필요가 있음
* 도메인 개념을 다른 소프트웨어 기술에만 관련된 개념과 혼동하거나, 또는 시스템이라는 하나의 큰 덩어리 안에서 도메인을 전혀 바라보지 못하는 문제를 방지

#### LAYERED ARCHITECTURE (계층형 아키텍처)

![계층형 아키텍처](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_4-0.png)

* 소프트웨어 시스템의 관심사, 특히 도메인 계층을 격리해서 관심사를 분리하는 기법.
* 도메인 계층 : LAYERED ARCHITECTURE 내에서 도메인 로직을 책임지는 설계와 구현에 해당하는 부분. 도메인 계층에는 도메인 모델에 대한 소프트웨어적 표현이 위치함.
* *도메인에 관련된 코드가 상당한 양의 도메인과 관련이 없는 다른 코드를 통해 널리 확산될 경우*
* **계층화의 핵심 원칙은 한 계층의 모든 요소는 오직 같은 계층에 존재하는 다른 요소나 계층상 "아래"에 위치한 요소에만 의존한다는 것이다.**

| -- | -- |
| 사용자 인터페이스 (또는 표현 계층) | 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 일을 책임진다. 간혹 사람이 아닌 다른 컴퓨터 시스템이 외부 행위자가 되기도 한다. |
| 응용 계층 | 소프트웨어가 수행할 작업을 정의하고 표현력 있는 도메인 객체가 문제를 해결하게 한다. 이 계층에서 책임지는 작업은 업무상 중요하거나 다른 시스템의 응용 계층과 상호작용하는데 필요한 것들이다. 이 계층은 얇게 유지된다. 여기에는 업무 규칙이나 지식이 포함되지 않으며, 오직 작업을 조경하고 아래에 위치한 계층에 포함된 도메인 객체의 협력자에게 작업을 위임한다. 응용 계층에서는 업무 상황을 반영하는 상태가 없지만 사용자나 프로그램의 작업에 대한 진행상황을 반영하는 상태를 가질 수는 있다. |
| 도메인 계층 (또는 모델 계층) | 업무 개념과 업무 상황에 관한 정보, 업무 규칙을 표현하는 일을 책임진다 이 계층에서는 업무 상황을 반영하는 상태를 제어하고 사용하며, 그와 갇은 상태 저장과 관련된 기술적인 세부사항은 인프라스트럭처에 위입한다 이 계층은 업무용 소프트웨어의 핵심이다. |
| 인프라스트럭처 계층 | 상위 계층을 지원하는 일반화된 기술적 기능을 제공한댜 이러한 기능에는 애플리케이션에 대한 메시지 전송, 도메인 영속화, UI에 위젯을 그리는 것 등이 있다 또한 인프라스트럭처 계층은 아키텍처 프레임워크를 통해 네 가지 계층에 대한 상호작용 패턴을 지원할 수도 있다. |

* 복잡한 프로그램을 여러 개의 계층으로 나눠라.
* 응집력 있고 오직 아래에 위치한 계층에만 의존하는 각 계층에서 설계를 발전시켜라. 표준 아키텍처 패턴에 따라 상위 계층과의 결합을 느슨하게 유지하라.
* 도메인 모델과 관련된 코드는 모두 한 계층에 모으고 사용자 인터페이스 코드나 애플리케이션 코드, 인프라스트럭처 코드와 격리하라.
* 도메인 객체(표현이나 저장, 애플리케이션 작업을 관리하는 등의 책임에서 자유로운)는 도메인 모델을 표현하는 것에만 집중할 수 있다.
* 모델은 진화를 거듭해 본질적인 업무 지식을 포착해서 해당 업무 지식이 효과를 발휘할 수 있을 만큼 풍부하고 명확해질 것이다.

##### 예제

###### 온라인 뱅킹 기능을 여러 계층으로 나누기

![객체는 자신이 속한 계층에 맞는 책임을 수행하며, 같은 계층에 존재하는 객체와 더 결합된다.](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_4-1.png)

##### 계층 간 관계 설정
* 각 계층은 설계 의존성을 오직 한 방향으로만 둬서 느슨하게 결합된다.
* 상위 계층은 하위 계층의 공개 인터페이스를 호출하고 하위 계층에 대한 침조를 가지며(최소한 임시로리도), 그리고 일반적으로 관례적인 상호작용 수단을 이용해 하위 계층의 구성요소를 직접적으로 사용하거나 조작할 수 있다.
* 보통 인프라스트럭처 계층에서는 도메인 계층에서 어떤 활동이 일어나게 하지 않는다.

##### 아키텍처 프레임워크
* *침습적인 형태의 인프라스트럭처*
* 프레임워크를 적용할 때 팀은 프레임워크의 목적에 집중해야 하는데, 그러한 프레임워크의 목적은 도메인 모델을 표현하고 해당 도메인 모델을 이용해 중요한 문제를 해결하는 구현을 만들어내는 데 있다.

#### 도메인 계층은 모델이 살아가는 곳
* 도메인 모델은 일련의 개념을 모아놓은 것
* 도메인 계충은 그러한 모델과 설계 요소에 직접적으로 관계돼 있는 모든 것들을 명시한 것
* 도메인 계층은 업무 로직에 대한 설계와 구현으로 구성
* MODEL-DRIVEN DESIGN에서는 도메인 계층의 소프트웨어 구성물이 모델의 개념을 반영
* 도메인 주도 설계의 전제 조건은 도메인 구현을 격리하는 것

#### SMART UI(지능형 UI) "안티 패턴"
* 도메인 주도 설계 접근법과는 서로 양립할 수 없는 싱호배타적인 길에 놓인 접근법
* 아키텍처에서 응집력 있는 도메인 설계가 시스템의 다른 부분과 느슨히케 결합될 수 있게 도메인 관련 코드를 격리한다면 아마 그러한 아키텍처는 도메인 주도 설계를 지원할 수 있을 것

```
마찬가지로 MODEL-DRIVEN DESIGN을 하기로 한 팀은 처음부터 MODEL-DRIVEN DESIGN의 방식대로 설계할 필요가 있다.
물론 상당히 의욕적이고 경험이 많은 프로젝트 팀이라도 단순한 기능부터 시작해서 계속적인 반복주기를 토대로 개발을 진행해야 한다.
그렇게 처음에 시험 삼아 해보는 단계가 바로 도메인 계층이 격리된 MODEL-DRIVEN이 될 것이며, 그렇지 않으면 십중팔구 SMART UI에서 막힐 것이다.
```

#### 다른 종류의 격리
* 도메인을 격리할 때의 가장 좋은 점은 부수적인 것을 배 제히고 도메인 설계에만 집중할 수 있다는 것

### 05장 소프트웨어에서 표현되는 모델
* ENTITY와 VALUE OBJECT를 구분하는 가장 기본적인 방법
  * 어떤 객체가 연속성(continuity)과 식별성(identity, 각종 상태를 바팅으로 추적되거나 서로 다른 구현에 걸쳐 존재하는 것)을 지닌 것을 의미하는가?
  * 다른 뭔가의 상태를 기술하는 속성에 불과한가?
* 도메인 측면 중에는 객체보다는 행동(action)이나 연산(operation)으로 좀더 명확하게 표현되는 것 (SERVICE)

#### 연관관계
* 모델 내의 모든 팀책 가능한(traversable) 연관관계에 대해 그것과 동일한 특성을 지닌 메커니즘이 소프트웨어에도 있다.
* 연관관계를 좀더 쉽게 다루는 방법
  1. 탐색 방향을 부여한다.
  2. 한정자를 추가해서 사실상 다중성을 줄인다
  3. 중요하지 않은 연관관계를 제거한다
* *도메인을 이해하면 도메인 본연의 방향성이 드러날지도 모른댜*

![어떤 탐색 방향은 도메인의 본연적인 특성을 반영하기도 한다.](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_5-1.png)

* 다대다 연관관계의 탐색 방향을 제약하면 해당 연관관계는 사실상 훨씬 더 구현하기 쉬운 일대다 연관관계로 줄어듬

##### 예제

###### 증권계좌의 연관관계

![계층형 아키텍처](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_5-3.png)

```java

public class BrokerageAccount {
  String accountNumber;
  Customer customer;
  Set investments;

  public Customer getCuStomer() {
    return customer;
  }

  public Set getInvestments() {
    return investments;
  }
}

```

* Brokerage Account와 investments(투자) 간의 다중성을 줄이고 연관관계를 한정

![계층형 아키텍처](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_5-4.png)

```java

public class BrokerageAccount {
  String accountNumber;
  Customer customer;
  Map investments;

  public Customer getCuStomer() {
    return customer;
  }

  public Set getInvestments() {
    return (Investment)investments.get(stockSymbol);
  }
}

```

#### ENTITY (엔티티, 참조객체라고도 함)
* 근본적으로 속성이 아니라 연속성과 식별성의 맥락에서 정의되는 객체
* 수많은 객체는 본질적으로 해당 객체의 속성이 아닌 연속성과 식별성이 이어지느냐를 기준으로 정의 됨
* 어떤 객체를 일차적으로 해당 객체의 식별성으로 정의할 경우 그 객체를 ENTITY라 함
* ENTITY에는 모델링과 설계상의 특수한 고려사항이 포함돼 있음
* ENTITY는 자신의 생명주기 동안 형태와 내용이 급격하게 바뀔 수도 있지만 연속성은 유지해야 함
* 사실상 ENTITY를 추적하려면 ENTITY에 식별성이 정의돼 있어야 함
* ENTITY의 클래스 정의와 책임, 속성, 연관관계는 ENTITY에 포함된 특정 속성보다는 ENTITY의 정체성에 초점을 맞춰야 함
* ENTITY가 그렇게끼지 급격하게 변형되지 않거나 생명주기가 복잡하지 않더라도 의미에 따라 ENTITY를 분류한다면 모델이 더욱 투명해지고 구현은 견고해질 것임
* 식별성은 ENTITY의 미묘하고 의미 있는 속성이므로 언어에서 제공하는 자동화된 기능으로 대체할 수 없음
* 한 객체가 속성보다는 식별성으로 구분될 경우 모델 내에서 이를 해당 객체의 주된 정의로 삼아라
* 클래스 정의를 단순하게 히고 생명주기의 연속성과 식별성에 집중하라
* 객체의 형태나 이력에 관계없이 각 객체를 구별하는 수단을 정의하라
* 객체의 속성으로 객체의 일치 여부를 판단하는 요구사항에 주의하라
* 각 객체에 대해 유일한 결과를 반환하는 연산을 정의하라 이러한 연산은 객체에 유일함을 보장받는 기호를 덧붙여서 정의할 수 있을지도 모름
* 이 같은 식별 수단은 외부에서 가져오거나 시스템에서 자체적으로 만들어 내는 임의의 식별자일 수도 있지만, 모델에서 식별성을 구분하는 방법과 일치해야 함
* 모델은 동일하다는 것이 무슨 의미인지 정의해야 함
* *경기장의 좌석이 지정석과 일반석이 동시에 존재한다면 좌석은 어떻게 다뤄야 할까?*

##### ENTITY 모델링
* ENTITY의 가장 기본적인 책임은 객체의 행위가 명확하고 예측 가능해질 수 있게 연속성을 확립
* ENTITY는 별도로 분리돼 있을 때 자신의 책임을 가장 잘 수행
* ENTITY의 속성이나 행위에 집중하기보다는 ENTITY 객체를 해당 ENTITY 객체의 가장 본질적인 특징(특히 해당 ENTITY를 식별하고 탐색하며 일치시키는 데 널리 사용되는)만으로 정의

##### 식별 연산의 설계
* 식별에 사용되는 속성은 시스템의 상태(시스템이 분산돼 있거나 객 체가 저장돼 있는 경우에도)와 관계없이 해당 시스템 내에서 유일해야 함

```
그런데 이러한 모든 기술적 문제를 감안하더리도 "두 객체가 동일하다는 것이 무엇을 의미하는가?" 라는 근원적인 문제를 놓치기 쉽다.
ID를 지닌 각 객체를 표시하거나 두 인스턴스를 비교하는 연산을 작성히키는 쉽지만 이러한 ID나 연산이 도메인에 의미 있는 구분법에 부합하지 않는다면 문제를 더욱 혼란스럽게 만들 뿐이다.
이는 식별성 할당 연산에 간혹 사람이 개입할 때가 있기 때문이다.
수표장 확인 소프트웨어를 예로 들면, 소프트웨어에서 대부분 일치하는 내역을 제시하지만 최종 결정은 사용자가 내리게 되어 있다.
```
* *도메인에 의미 있는 구분법이란?*

#### VALUE OBJECT (값 객체)
* 일부 특징과 속성을 기술하지만 식별성 개념이 없는 객체
* 개념적 식별성을 갖지 않으면서 도메인의 서술적 측면을 나타내는 객체
* VALUE OBJECT는 다른 여러 객체를 조립한 것일 수도 있음
* VALUE OBJECT가 ENTITY를 참조할 수도 있음
* VALUE OBJECT는 여러 객체 간에 오가는 메시지의 매개변수로 전달되기도 함
* 모델에 포함된 어떤 요서의 속성에만 관심이 있다면 그것을 VALUE OBJECT로 분류하라
* VALUE OBJECT에서 해당 VALUE OB]ECT가 전하는 속성의 의미를 표현하게 하고 관련 기능을 부여하라
* VALUE OBJECT는 불변적(immutable)으로 다뤄라.
* VALUE OBJECT에는 아무런 식별성도 부여하지 말고 ENTITY를 유지하는 데 필요한 설계상의 복잡성을 피하라.

##### VALUE OBJECT의 설계
* 공유를 제한
  * 공간을 절약하거나 데이터베이스 내의 객체 수를 줄이는 것이 중요한 경우
  * 통신 부하가 낮은 경우(이를테면, 중앙집중형 서버)
  * 공유 객체의 불변성이 엄격하게 지켜지는 경우
* 변경가능성을 허용하는 경우
  * VALUE가 자주 변경되는 경우
  * 객체 생성이나 삭제에 비용이 많이 드는 경우
  * 교체(변경이아닌)로 인해 클리스터링이 제한되는 경우
  * VALUE를 공유할 일이 그리 많지 않거나 클리스터링을 향상시키기 위해서나 댜른 기술적인 이유로 공유가 보류된 경우

##### 예제

###### VALUE OBJECT를 활용한 데이터베이스 최적화
* 역정규화(denormalization) : 동일한 데이터에 대해 여러 개의 사본을 저장하는 기법
  * 저장 공간이나 유지보수의 단순함보다는 접근 시간이 더 중요한 경우에 종종 사용

##### VALUE OBJECT를 포함한 연관관계 설계
* 모델에 포함된 연관관계의 수가 더 적고 연관관계가 단순할수록 더 나은 모델이라 할 수 있음
* ENTITY 간의 양방향 연관관계는 유지하기는 어려울 수 있음
* VALUE OBJECT 간의 양방향 연관관계는 단순히 논리적으로 타당하지 않음

#### SERVICE(서비스)
* 캡슐화된 상태가 없으며, 모델에 홀로 존재하는 인터페이스로 제공되는 연산.
* 행위를 적절한 객체로 다듬는 것을 너무나도 쉽게 포기해서 점점 절차적 프로그래밍에 빠지는 것
* 세 가지 특징
  1. 연산이 원래부터 ENTITY나 VALUE OB]ECT의 일부를 구성하는 것이 아니라 도메인 개념과 관련돼 있다.
  2. 인터페이스가 도메인 모델의 외적 요소의 측면에서 정의된다.
  3. 연산이 상태를갖지 않는다.

##### SERVICE와 격리된 도메인 계층
* 도메인 계층에 속하는 SERVICE와 다른 계층에 속하는 것들을 구분하고, 그러한 구분을 분명하게 유지하는 책임을 나누는 데 주의
* 문헌상에서 논의되는 SERVICE는 대부분 순수하게 기술적이며 인프라스트럭처 계층
* 도메인 SERVICE, 응용 SERVICE, 인프라스트럭처 SERVICE
* *기술과 관련된 SERVICE* 에는 업무와 관련된 어떤 것도 포함돼서는 안 됨

| 응용 | 자금 이체 응용서비스 |
| 도메인 | 자금 이체 도메인 서비스 |
| 인프라스트럭처 | 통지 서비스 |

##### 구성 단위
* *도메인 계층의 인터페이스 구성 단위를 제어하는 수단*

##### SERVICE에 접근하기
* *J2EE와 CORBA와 같은 분산 시스템 아키텍처*

#### MODULE(모듈, 패키지라고도 함)

##### 기민한 MODULE

##### 인프라스트럭처 주도 패키지화의 함정

#### 모델링 패러다임
* 도메인에 담긴 개념을 찾아내는 특정 형식을 의미하며, 그러한 개념에 대한 소프트웨어적 유사물을 만들어 내는 도구와 결합됨 (예, 객체지향 프로그래밍과 로직 프로그래밍)

##### 객체 패러다임이 지배적인 이유

##### 객체 세계에서 객체가 아닌 것들

##### 패러다임이 혼재할 때 MODEL-DRIVEN DESIGN 고수하기

### 06장 도메인 객체의 생명주기

#### AGGREGATE (집합)
* 데이터 변경을 목적으로 하나의 단위로 다뤄지는 연관 객체의 모음 외부 참조는 루트로 지정된 AGGREGATE의 한 구성요소로 제한됨 일련의 일관성 규칙이 AGGREGATE의 경계 내에 적용됨

#### FACTORY (팩터리)
* 클라이언트를 위해 복잡한 생성 로직을 캡슐화히고 생성된 객체 타입을 추상화하는 메커니즘

##### FACTORY와 FACTORY의 위치 선정

##### 생성자만으로 충분한 경우
* 클래스가 타입인 경우. 클래스가 어떤 계층구조의 일부를 구성하지 않으며, 인터페이스를 구현하는 식으로 다형적으로 사용되지 않는 경우.
* 클라이언트가 STRATEGY를 선택하는 한 방법으로서 구현체에 관심이 있는 경우
* 클라이언트가 객체의 속성을 모두 이용할 수 있어서 클라이언트에게 노출된 생성자 내에서 객체 생성이 중첩되지 않는 경우
* 생성자가 복잡하지 않은 경우
* 공개 생성자가 FACTORY와 동일한 규칙을 반드시 준수해야 하는 경우 이때 해당 규칙은 생성된 객체의 모든 불변식을 충족하는 원자적인 연산이어야 한다.

##### 인터페이스 설계

##### 불변식 로직의 위치

##### ENTITY FACTORY와 VALUE OBJECT FACTORY
* 차이점
  * VALUE OBJECT는 불변적
  * ENTITY에는 식별성 할당과 관련된 쟁점이 있다는 것

##### 저장된 객체의 재구성
* FACTORY는 객체의 생성과 재구성이라는 생명주기 전이(transition)를 캡슐화
* 저장소에 들어갈 때와 저징소에서 나올 때 거치는 전이가 있다. 이러한 전이는 또 다른 도메인 설계 구조물인 REPOSITORY의 책임

#### REPOSITORY (리파지터리)
* 객체 컬렉션을 흉내내며, 저장·조화·검색 행위를 캡슐화하는 메커니즘
* 연관관계의 응집성과 검색의 분리는 상층 관계에 있다.
* 저장돼 있는 객체로부터 인스턴스를 만들어 내는 것을 재구성(reconstitution)이라고 한다.
* **도메인 주도 설계의 목표는 기술보다는 도메인에 대한 모델에 집중해 더 나은 소프트웨어를 만들어내는 것이다**
* AGGREGATE 내부에 존재하는 모든 객체는 루트에서부터 탐색을 토대로 접근하는 것 말고는 접근이 금지돼 있다는 점이다.

##### REPOSITORY에 질의하기

##### 클라이언트 코드가 REPOSITORY 구현을 무시한다 (개발자는 그렇지 않지만)

##### REPOSITORY 구현

##### 프레임워크의 활용

##### FACTORY와의 관계

#### 관계형 데이터베이스를 위한 객체 설계

### 07장 언어의 사용(확장 예제)

#### 화물 해운 시스템 소개

![도메인주도설계](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_7-1.png)

#### 도메인 격리: 응용 기능 소개
* 도메인의 책임이 시스템의 다른 부분과 섞이는 것을 방지하고자 LAYERED ARCHITECTURE를 적용해 도메인 계층을 구별

#### ENTITY와 VALUE OBJECT의 구분

##### 역할과 그 밖의 속성
* 역할은 그것이 한정하는 연관관계에 관한 사항을 전해주지만 이력이나 연속성을 지니고 있지는 않다.

#### 해운 도메인의 연관관계 설계

![도메인주도설계](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_7-2.png)

#### AGGREGATE의 경계

![도메인주도설계](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_7-3.png)

#### REPOSITORY의 선정
* 전제는 모두 바뀔 수 있으므로 만약 전제가 바뀌었다면 REPOSITORY를 추가할 것

![도메인주도설계](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_7-4.png)

#### 시나리오 연습

##### 예제 애플리케이션 기능: 화물의 목적지 변경

##### 예제 애플리케이션 기능: 반복 업무

#### 객체 생성

##### Cargo에 대한 FACTORY와 생성자

##### Handling Event 추가

#### 리팩터링할 시간: Cargo AGGREGATE의 설계 대안

#### 해운 모델의 MODULE

#### 새로운 기능 도입: 할당량 검사

##### 두 시스템의 연계

##### 모델 강화: 업무 분야 나누기

##### 성능 최적화

#### 최종 검토

## 03부 더 심층적인 통찰력을 향한 리팩터링
1. 정교한 도메인 모델은 만들 수 있으며, 노력을 들일 만한 가치가 있다.
2. 해당 도메인을 학습하는 개발자와 도메인 전문가의 긴밀한 참여와 반복적인 리팩터링 과정 없이 유용한 모델을 개발하기란 쉽지 않다.
3. 유용한 모델을 효과적으로 구현하고 사용하려면 정교한 설계 기술이 필요할지도 모른다.

### 리팩터링 수준

### 심층 모델
* 심층모델(deep model)이란 도메인의 피상적인 측면은 배제하고 도메인 전문가의 주요 관심사와 가장 적절한 지식을 알기 쉽게 표현하는 모델

### 심층 모델/유연한 설계

### 발견 과정

### 08장 도약

#### 도약에 관한 일화

##### 괜찮은 모델이기는 하지만……

##### 도약

##### 더 심층적인 모델

##### 냉정한 결정

##### 결말

#### 기회

#### 기본에 집중하라

#### 후기 : 연이은 새로운 통찰력의 출현
* 심층 모델로의 진정한 도약을 거치고 나면 새로운 설계의 명확성과 단순함이 새로운 UBIQUITOUS LANGUAGE를 기빈으로 한 개선된 의사소통과 결합되어 또 다른 모델링 도약으로 이어지는 사례가 자주 발생

### 09장 암시적인 개념을 명확하게
* 개발자들이 토의 중에 단서를 얻거나 설계상에 암시적으로 존재하는 개념을 인지하면 도메인 모델과 관련 코드를 대량으로 변환하게 되며, 그 후 하나 이상의 객체와 객체 간의 관계를 활용해 모델 내에 해당 개념을 명확하게 표현하게 된다.

#### 개념 파헤치기

##### 언어에 귀 기울여라

##### 예제

###### 해운 모델의 누락된 개념에 귀 기울이기

##### 어색한 부분을 조사하라

##### 예제

###### 이자 수익 예제 - 어려운 방식으로 접근하기

##### 모순점에 대해 깊이 고민하라

##### 서적을 참고하라

##### 시도하고 또 시도하라

#### 다소 불명확한 개념의 모델링

##### 명시적인 제약조건
* 제약조건을 자체적인 메서드로 분리하면 제약조건에 의도를 드러내는 이름을 부여해서 설계 내에 제약 조건을 명확하게 표현할 수 있음
* 제약조건이 객체가 담당하는 기본 책임을 모호하게 만들거나 제약조건이 도메인과 관련된 대화에서는 중요한 개념으로 디뤄지지만 모델 내에 명확하게 표현돼 있지 않다면 제약조건을 명시적인 객체로 분리하거나, 나아가 일련의 객체와 관계의 집합으로 모델링할 수 있음

```java
class Bucket {
  private float capacity;
  private float contents;

  public void pourIn(float addedVolume) {
    if(contents + addedVolume > capacity) {
      contents = capacity;
    } else {
      contents = contents + addedVolume;
    }
  }
}
```

```java
class Bucket {
  private float capacity;
  private float contents;

  public void pourIn(float addedVolume) {
    float volumePresent = contents + addedVolume;
    contents = constrainedToCapacity(volumePresent);
  }

  private float constrainedToCapacity(float volumePlacedIn) {
    if (volumePlacedIn > capacity) return capacity;
    return volumePlacedIn;
  }
}
```

* 제약조건을 포함한 객체의 설계가 어딘가 잘못돼 있음을 나타내는 조짐
1. 제약조건을 평가하려면 해당 객체의 정의에 적합하지 않은 데이터가 필요하다.
2. 관련된 규칙이 여러 객체에 걸쳐 나타나며, 동일한 계층구조에 속하지 않는 객체 간에 중복 또는 상속 관계를 강요한다.
3. 설계와 요구사항에 관한 다양한 논의는 제약조건에 초점을 맞춰 이뤄지지만 정작 구현 단계에서는 절차적인 코드에 묻혀 명시적으로 표현되지 않는다.

##### 예제

###### 설계 검토: 초과 예약 정책

##### 도메인 객체로서의 프로세스

#### SPECIFICATION (명세)

##### SPECIFICATION의 적용과 구현

### 10장 유연한 설계
* 심층 모델에 내재된 힘을 클라이언트 개발자에게 맡겨 예상되는 결과를 효과적으로 보여주는 명확하고 유연한 표현을 만드는 설계.
* 마찬가지로 중요한 점은 유연한 설계가 동일한 심층 모델을 활용해 구현자가 설계 자체를 본떠 다른 형태로 만들어 새로운 통찰력을 쉽게 받아들일 수 있다는 것임.

![도메인주도설계](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_10-1.png)

#### INTENTION-REVEALING INTERFACE (의도를 드러내는 인터페이스)
* 클래스와 메서드, 그리고 다른 구성요소의 이름이 그것을 만든 최초 개발자의 의도와 클라이언트 개발자에게 부여되는 가치를 전달하는 설계.

#### SIDE-EFFECT-FREE FUNCTION (부수효과가 없는 함수)
* 연산은 크게 명령(command)과 질의(query)라는 두 가지 범주로 나눔
* 질의는 변수 안에 저장된 데이터에 접근하거나, 저장된 데이터를 기반으로 계산을 수행해서 시스템으로부터 정보를 얻는 연산을 의미
* 명령(또는 변경자(modifier)라고도 한다)은 변수의 값을 변경하는 등의 작업을 통해 시스템의 상태를 변경하는 연산을 의미
* 부수효과를 일으키지 않으면서 결과를 반환하는 연산을 함수(function)함

#### ASSERTION (단정)
* 프로그램의 동작방식과는 독립적으로 프로그램이 어느 시점에 지녀야 할 정확한 상태를 나타내는 문장. 일반적으로 ASSERTION은 연산의 결과나 설계 구성요소의 불변식을 명시함

#### CONCEPTUAL CONTOUR (개념적 윤곽)
* 도메인을 중요 영역올 나누는 것과 관련한 직관을 감안해서 설계요소(연산,인터페이스, 클래스, AGGREGATE)를 응집력 있는 단위로 분해하라
* 계속적인 리팩터링을 토대로 변경되는 부분과 변경되지 않는 부분을 나누는 중심 축을 식별하고, 변경을 분리하기 위한 패턴을 명확하게 표현하는 CONCEPTUAL CONTOUR를 찾아라
* 우선적으로 확실한 지식 영역을 구성하는 도메인의 일관성 있는 측면과 모델을 조화시켜라

#### STANDALONE CLASS (독립형 클래스)
* 시스템의 기본 기능과 기본 라이브러리를 제외하고 다른 어떤 것도 참조하지 않은 상태에서 이해하고 테스트할 수 있는 클래스.

#### CLOSURE OF OPERATION (연산의 닫힘)

#### 선언적 설계
* 특성에 대한 정확한 기술이 실제로 소프트웨어를 제어하는 수단이 되는 프로그래밍의 한 형태. 실행 가능한 명세.

##### 도메인 특화 언어

#### 선언적인 형식의 설계

##### SPECIFICATION을 선언적인 형식으로 확장하기

#### 받음각

##### 서브 도메인으로 분할하라

##### 가능하다면 정립된 정형화를 활용하라

### 11장 분석 패턴의 적용

### 12장 모델과 디자인 패턴의 연결

#### STRATEGY (POLICY라고도 함)

#### COMPOSITE (복합체)

#### 그렇다면 FLYWEIGHT는?
* 기술적인 문제에 대한 기술적인 해법뿐 아니라 개념적인 도메인에 관한 해법도 제공해야 한다는 것이 디자인 패턴을 도메인 패턴으로 적용하기 위한 유일한 요구사항

### 13장 더 심층적인 통찰력을 향한 리팩터링

#### 시작

#### 조사팀

#### 선행 기술

#### 개발자를 위한 설계

#### 타이밍

#### 위기를 기회로

## 04부 전략적 설계
* 시스템의 큰 부분에 적용되는 모델링과 설계 결정, 이러한 결정은 전체 프로젝트에 영향을 주며 팀 수준에서 내려야 함.

### 14장 모델의 무결성 유지

#### BOUNDED CONTEXT (제한된 컨텍스트)
* 특정 모델에 포함된 범위가 정해진 적용 가능성 컨텍스트를 제한하면(BOUNDING CONTEXT) 팀원이 어떤 것이 일관성을 지녀야 하고, 어떤 것을 독립적으로 개발할 수있는가를 분명하게 이해하고 이해한 바를 서로 공유할 수 있음.

##### BOUNDED CONTEXT 안의 균열 인식

#### CONTINUOUS INTEGRATION (지속적인 통합)

#### CONTEXT MAP (컨텍스트 맵)
* 프로젝트와 관련된 BOUNDED CONTEXT 및 BOUNDED CONTEXT와 모델 간의 실제 관계를 표현한 것.

##### CONTEXT 경계에서의 테스트

##### CONTEXT MAP의 조직화와 문서화

#### BOUNDED CONTEXT 간의 관계

#### SHARED KERNEL (공유 커널)

#### CUSTOMER/SUPPLIER DEVELOPMENT TEAM (고객/공급자 개발 팀)

#### CONFORMIST (준수자)
* CONFORMIST는 동일한 모델을 이용하는 영역과 추가를 통해 모델을 확장한 영역, 다른 모델이 영향을 미치는 영역을 보유한다는 점에서 SHARED KERNEL과 유사
* 저수준 인터페이스를 사용하면 데이터를 표현하고 데이터의 값과 관계를 제약하는 모델의 힘이 사라지는 동시에 새로운 시스템에 자신의 모델에서 사용하지도 않는 용어를 사용해서 원시 데이터를 해석해야 하는 부담마저 생김

#### ANTICORRUPTION LAYER (오류 방지 계층)

##### ANTICORRUPTION LAYER의 인터페이스 설계

##### ANTICORRUPTION LAYER의 구현

##### 교훈적인 이야기

#### SEPARATE WAYS (각자의 길)

#### OPEN HOST SERVICE (공개 호스트 서비스)

#### PUBLISHED LANGUAGE (공표된 언어)

#### 코끼리 통일하기

#### 모델의 컨텍스트 전략 선택

##### 팀 의사결정 또는 그 이상

##### 우리 자신을 컨텍스트에 배치하기

##### 경계의 변형

##### 변경할 수 없다는 사실을 인정하기: 외부 시스템의 묘사

##### 외부 시스템과의 관계

##### 설계 중인 시스템

##### 개별 모델의 특수한 요구사항 충족하기

##### 배치

##### 타협점

##### 프로젝트가 이미 진행 중일 때

#### 변형

##### CONTEXT 병합: SEPARATE WAYS → SHARED KERNEL

##### CONTEXT 병합: SHARED KERNEL → CONTINUOUS INTEGRATION

##### 레거시 시스템의 단계적 폐기

##### OPEN HOST SERVICE → PUBLISHED LANGUAGE

### 15장 디스틸레이션
* 더욱 가치 있고 유용한 형태로 본질을 추출할 목적으로 혼합물에서 구성요소를 분리하는 과정 소프트웨어 설계에서는 모델 내의 핵심적인 측면에 대한 추상화, 또는 CORE DOMAIN이 부각되도록 큰 시스템을 분할하는 것을 의미
* 디스틸레이션(distillation)은 혼합된 요소를 분리해서 본질을좀더 값지고 유용한 형태로 뽑아내는 과정

#### CORE DOMAIN (핵심 도메인)
* 규모가 큰 시스템을 설계할 때는 시스템에 기여하는 구성요소가 무수히 많은데, 모두 복잡하고 성공에 절대적이어서 진정한 업무 자산에 해당하는 도메인의 본질적인 측면이 가려지거나 방치될 수 있다.
* 모델을 요약하라.
* CORE DOMAIN을 찾아 그것을 지원하는 다수의 모델과 코드로부터 쉽게 구별할 수 있는 수단을 제공하라.
* 가장 가치 있고 전문화된 개념을 부각시켜라 CORE를 작게만들어라.

##### CORE 선택

##### 누가 그 일을 할 것인가?

#### 디스틸레이션의 단계적 확대

#### GENERIC SUBDOMAIN (일반 하위 도메인)

##### 일반화가 재사용 가능하다는 의미는 아니다
* 재사용이 일어나긴 해도 그것이 항상 코드 재사용에 해당하는 건 아니다. 모델 재사용은 종종더 나은 수준의 재사용인데, 바로 공표된 설계나 모델을 사용할 때처럼 말이다.
* 재사용을 목표로 설계할 일은 거의 없더리도 일반 개념의 범위 내에서 설계를 유지하는 것과 관련해서는 엄격해야 한다.

##### 프로젝트 위험 관리
* 애자일 프로세스에서는 일반적으로 가장 위험스러운 업무를 먼저 다루는 식으로 위험을 관리할것을 요구한다.
* 디스틸레이션 패턴은 CORE DOMAIN의 정수를 추출하기 위해 모델과 코드를 변경하는 법을 보여준다.

#### DOMAIN VISION STATEMENT (도메인 비전 선언문)
* DOMAIN VISION STATEMENT는 모델과 코드 자체의 디스틸레이션 과정에서 개발팀을 줄곧 공통적인 방향으로 향하게 할 이정표로 사용될 수 있다.
* DOMAIN VISION STATEMENT는 비기술 관련 팀원, 관리조직, 심지어 고객괴도 공유할 수 있다.
* DOMAIN VISION STATEMENT는 팀 내에서 방향성을 공유하게 만들어준다.

#### HIGHLIGHTED CORE (강조된 핵심)
* 어떤 모델에서 특별히 중요한 부분을 그것을 구체화한 구현과 함께 표시할 필요가 있는데, 이러한 표시는 모델에 대한 설명이지 반드시 모델 자체의 한 부분일 필요는 없다.

##### 디스틸레이션 문서
* CORE DOMAIN를 기술하고 설명하는 문서
* 디스틸레이션 문서는 완전한 설계 문서가 아니다.
* CORE DOMAIN과 CORE의 구성요소 사이에서 일어나는 싱호작용을 기술하는 (3에서 7페이지 가량의) 매우 간결한 문서를 작성하라
* 문서를 모든 이들이 알아야 할 사항을 묘사하는 시각을 공유하는 수단이자 모든 팀원이 모델과 코드에 대한 탐구를 시작하는 지침서로 사용한다.

##### 표시된 CORE
* 모델의 주요 저징소 안에 있는 CORE DOMAIN의 구성요소에 대해 그것의 역할을 설명하려 하지 말고 표시하라.
* CORE를 비롯해 CORE와 지원 기능과의 관계를 분명하게 보여주는 모델 내비게이션을 제공
* 개발자가 힘들이지 않고도 CORE의 안과 밖을 알 수 있게 하라.

##### 프로세스 도구로서의 디스틸레이션 문서

#### COHESIVE MECHANISM (응집력 있는 메커니즘)
* 메커니즘을 캡슐화하는 것은 객체지향 설계의 표준 원칙

##### GENERIC SUBDOMAIN과 COHESIVE MECHANISM

##### MECHANISM이 CORE DOMAIN의 일부인 경우

#### 선언적 형식의 디스틸레이션

#### SEGREGATED CORE (분리된 핵심)

##### SEGREGATED CORE를 만드는 데 드는 비용

##### 발전하는 팀의 의사결정

#### ABSTRACT CORE (추상화된 핵심)
* 모델의 가장 근본적인 개념을 식별해서 그것을 별도의 클래스나 추상 클래스, 또는 인터페이스로 추출하라.
* 이 추상 모델이 중요 컴포넌트 간에 발생하는 싱호작용을 대부분 표현할 수있게끔 설계하라 특화되고 세부적인 구현 클래스는 하위 도메인을 기준으로 정의된 자체적인 MODULE에 남겨둔 상태에서 이 추상적이면서 전체적인 모델을 자체적인 MODULE에 배치하라.

#### 심층 모델의 디스틸레이션
* 심층 모델로의 도약은 그러한 도약이 일어나는 모든 곳에 가치를 제공하지만 전체 프로젝트의 궤도를 변경할 수 있는 것은 바로 CORE DOMAIN에 있다.

#### 리팩터링의 대상 선택
1. 고통 주도적 리팩터링에서는 문제의 근원에 CORE DOMAIN이나, CORE와 지원 요소와의 관계가 관련돼 있는지 살핀다. 만약 그렇다면,이를 악물고 그 부분을 가장 먼저 고쳐야 한다.
2. 마음껏 리팩터링할퉤수 있는 상황이라면 제일 먼저 CORE DOMAIN을 더 잘 분해하고, CORE의 격리를 개선하며, 보조적인 하위 도메인이 GENERIC하게 만드는 데 집중한다.

### 16장 대규모 구조
* 전체 시스템에 대한 설계 패턴을 수립하는 일련의 고수준 개념이나 규칙, 또는 두 가지 모두를 의미. 시스템을 넓은 안목에서 논의하고 이해할 수 있게 하는 언어.
* 큰 시스템에 해당 시스템의 요소를 전체 설계에 걸친 패턴에서의 역할 측면에서 해석하게 할수 있는 지배적인 원칙이 없다면 개발자들은 나무만 보고 숲을 보지 못한다. 우리는 전체의 세부사항을 깊이 파고들지 않고도 전체의 각 부분이 담당하는 역할을 이해할 수 있어야 한다.
* “대규모 구조”는 넓은 시긱으로 시스템에 관해 토의히고 이해하게끔 돕는 언어다. 고수준 개념이나 규칙, 또는 둘 모두는 전체 시스템에 대한 설계 패턴을 확립한다.
* 전체 시스템을 포괄하고 각 부분의 책임을 자세히 알지 못해도 전체적인 관점에서 해당 부분의 위치를 어느 정도 이해하는 데 도움을 주는 규칙 또는 규칙과 관계의 패턴을 고안하라.

![대규모 구조의 패턴](/assets/images/books/컴퓨터공학/개발방법론/도메인주도설계/figure_16-1.png)

#### EVOLVING ORDER (발전하는 질서)

#### SYSTEM METAPHOR (시스템 은유)
* 소프트웨어 설계는 매우 추상적이고 파악하기 힘든 경향이 있다. 개발자와 사용자 모두 시스템을 이해하고 시스템을 전체적으로 바라보는 시각을 공유할 구체적인 수단이 필요하다.

##### "미숙한 은유"와 그것이 필요 없는 이유

#### RESPONSIBILITY LAYER (책임 계층)

##### "운영" 책임

##### "기능" 책임

##### "의사결정 지원" 책임
* 프로젝트에서 코드가 최종적인 설계 서라면 계층별로 클래스를 열어보거나, 아니면 최소한 계층별로 클래스를 보여주는 도구가 있으면 도움될 것이다.

##### 이 구조가 어떻게 진행 중인 설계에 영향을 주는가?

##### 적절한 계층의 선택

#### KNOWLEDGE LEVEL (지식 수준)

#### PLUGGABLE COMPONENT FRAMEWORK (착탈식 컴포넌트 프레임워크)

#### 구조는 얼마나 제약성을 지녀야 하는가?

#### 잘 맞아떨어지는 구조를 향한 리팩터링

##### 최소주의

##### 의사소통과 자기 훈련

##### 재구조화가 유연한 설계를 낳는다

##### 디스틸레이션은 부하를 줄인다

### 17장 전략의 종합

#### 대규모 구조와 BOUNDED CONTEXT와의 결합

#### 대규모 구조와 디스틸레이션과의 결합

#### 평가 먼저

#### 누가 전략을 세우는가?

##### 애플리케이션 개발에서 창발하는 구조

##### 고객(애플리케이션 개발팀) 중심의 아키텍처 팀

#### 전략적 설계 결정을 위한 6가지 필수 요소
* 의사결정은 팀 전체에 퍼져야 한다
* 의사결정 프로세스는 피드백을 흡수해야 한다
* 계획은 발전을 감안해야 한다
* 아키텍처 팀에서 가장 뛰어나고 똑똑한 사람들을 모두 네려가서는 인 된다
* 전략적 설계에는 최소주의와 겸손이 필요하다
* 객체는 전문가. 개발자는 다방면에 지식이 풍부한 사람

##### 기술 프레임워크도 마찬가지다

##### 종합계획을 조심하라
