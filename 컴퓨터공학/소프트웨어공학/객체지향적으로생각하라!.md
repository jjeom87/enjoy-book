# 객체지향적으로 생각하라!

## Chapter 1 객체지향 개념 소개
### 절차지향과 OO 프로그래밍
* 객체(object)란 데이터와 행위를 모두 가지고 있는 실체(엔티티, entity)
* 객체는 다른 소프트웨어 개발 패러다임을 교체하는 것이라기보다는 한 단계 발전된 반응
* 객체에서 메서드는 데이터에 대한 연산과 기타 작업을 수행하기 위해 사용
* 캡슐화라고 부르는 방법을 통해, 즉 속성과 메서드를 통일한 엔터티에 결합함으로써 Math 객체에 있는 데이터에 대한 엑세스를 제어할 수 있음
* 여러 작업을 수행하는 커다란 객체를 만드는 것보다는 특정 작업을 하는 작은 객체를 만드는 것이 낫음
### 절차지향에서 객체지향 개발로 이동
#### 절차지향 프로그래밍
* 절차지향 프로그래밍에서는 보통 한 시스템에 있는 데이터를 그 데이터를 사용하는 연산으로 부터 분리
#### OO 프로그래밍
* OO 프로그래밍의 근본적인 장점은 데이터와 그 데이터를 이용하는 연산이 모두 객체안에 캡슐로 쌓인다는 점
### 객체란 정확히 무엇인가?
* 객체는 OO 프로그램을 구성하는 블록
* OO 기술을 사용하는 프로그램은 기본적으로 객체 집합
#### 객체 데이터
* 객체 내에 저장된 데이터는 객체의 상태를 나타냄
* OO 프로그램밍 용어에서는 이 데이터를 속성(attribute)이라 함
#### 객체 행위
* 객체의 행위(behavior)는 객체가 할 수 있는 일
* OO 프로그래밍 용어에서 이런 행위는 메서드에 포함되어 있으며 메시지를 보내서 메서드를 호출할 수 있음
### 클래스란 정확히 무엇인가?
* 클래스는 객체에 대한 청사진
* 객체의 인스턴스를 만들 때 객체를 구성하는 기초로 클래스를 사용
#### 클래스는 객체 템플릿이다
* 클래스는 이 클래스를 사용하여 만드는 객체가 소유하는 속성과 행위를 정의
* 객체를 만들기 전에 클래스를 설계
#### 속성
* 클래스마다 속성을 정의해야만 속성이 클래스에서 인스턴스가 생긴 각 객체의 상태를 저장할 수 있음
#### 메서드
* 메서드는 클래스의 필요한 행위를 구현
* 클래스에서 인스턴스가 생긴 모든 객체는 클래스가 정의한 대로 메서드를 가짐
* 메서드는 다른 객체에서 호출한 행위를 구현하거나 클래스의 기초적인 내부 행위를 제공 할 수 있음
* 모든 경우에 객체 내에 있는 속성에 대한 엑세스는 객체 자체가 제어
* 다른 객체가 직접 속성을 변경해서는 안됨
#### 메시지
* 객체 간 의사소통 메커니즘
### UML을 사용하여 클래스 다이어그램 모델 만들기
### 캡슐화와 데이터 은닉
* 좋은 OO 설계에서 객체는 다른 객체에 상호작용해야 하는 인터페이스만 드러내어야 함
* 캡슐화는 객체에 속성과 행위가 같이 포함된다는 사실로 정의
* 데이터 은닉은 캡슐화의 중요한 일부
#### 인터페이스
* 인터페이스가 객체 간 의사소통하는 근본적인 방법을 정의한다는 것
* 클래스를 설계할 때마다 객체를 올바로 인스턴스로 만들고 운영하기 위하여 인터페이스를 지정
* 객체가 제공하는 행위는 전송된 메시지가 제공된 인터페이스 중 하나를 사용하여 호출
#### 구현
* 사용자는 구현의 어떤 부분도 볼수 없어야 하며, 객체와의 상호작용은 클래스 인터페이스를 통해서만 이루어짐
#### 인터페이스/구현 패러다임의 실제 예
#### 인터페이스/구현 패러다임의 모델
* 구현을 변경해야 할 경우, 사용자는 동일한 기능을 얻지만 구현은 변경됨
### 상속
* OO 설계는 보다 중요한 진전을 이루어서 코드 재사용을 쉽게 할 뿐만 아니라 클래스를 재구성하고 다양한 클래스의 공통점을 추려내어 전반적인 클래스 설계를 향상시키는 클래스 간 관계를 정의
* OO 프로그래밍에서 중요한 설계 이슈 중 하나는 다양한 클래스의 공통점을 추려내는 것
#### 상위 클래스와 하위 클래스
* 상위 클래스 또는 부모 클래스에는 상속의 대상이 되는 클래스에 공통적인 모든 속성과 행위가 포함됨
#### 추상화
* 상속의 강점은 추상화와 정리 기술
#### Is-a 관계
* 하위 클래스가 상위 클래스로부터 상속할 때 상위 클래스가 할 수 있는 모든 것을 할 수 있음
### 다형성
* 상위 계층 구조에서 모든 하위 클래스는 상위 클래스에서 인터페이스를 상속
* 각각의 하위 클래스가 구분된 엔터티이기 때문에 각각은 동일한 메시지에 대해 별도의 응답이 필요할 수 있음
### 조합
* 객체는 흔히 다른 객체로 구성 또는 조합됨
#### 추상화
* 조합을 사용하여 우리는 다른 클래스에 있는 클래스를 결합하여 클래스를 구성할 수 있음
#### Has-a 관계
* 상속 관계를 이미 논의한 이유로 is-a 관계라고 하며, 조합 관계는 has-a 관계라는 용어로 표현
### 결론
* 캡슐화 : 데이터와 행위를 단일 객체에 캡슐화하는 것은 OO 개발에서 우선적으로 중요함
* 상속 : 클래스는 다른 클래스로부터 상속할 수 있고 상위 클래스에서 정의한 속성과 메서드를 활용할 수 있음
* 다형성 : 다형성은 비슷한 객체가 다른 방식으로 동일한 메시지에 반응할 수 있다는 의미
* 조합 : 조합은 다른 객체로부터 객체를 구성할 수 있다는 의미
## Chapter 2 객체 관점에서 생각하는 방법
* 인터페이스와 구현 간에 차이가 있다는 점을 인식
* 보다 추상적으로 생각
* 사용자에게 가능한 최소한의 인터페이스만 제공
### 인터페이스와 구현 간의 차이가 있다는 점을 인식
* 올바로 구성된 클래스는 인터페이스와 구현이라는 두 부분으로 설계됨
### 인터페이스
* 제일 원칙으로서 클래스에 대한 인터페이스는 사용자가 알 필요가 있는 내용만 포함
### 구현
* 구현의 자세한 내용은 사용자에게 숨김
* 구현이 변경된다고 해서 반드시 사용자 코드가 변경되어야 하는 것은 아니라는 점
### 인터페이스/구현 예
* OO 설계는 반복적인 과정이기에 처음부터 정확하게 해야만 하는 것은 아님
### 인터페이스를 설계할 때 추상적으로 생각하기
* OO 프로그래밍의 주요 이점 중 하나는 클래스를 재사용할 수 있다는 점
* 일반적으로 재사용 가능한 클래스는 구체적이기보다는 보다 추상적인 인터페이스를 갖는 경향이 있음
* 구체적인 인터페이스는 아주 상세한 경향이 있는 반명 추상적인 인터페이스는 보다 일반적임
### 사용자에게 가능한 최소한의 인터페이스를 제공
* 클래스를 설계할 때 가장 중요한 규칙은 항상 사용자에게 클래스 내부 동작에 대해서 가능한 적은 정보를 제공
  * 사용자에게 절대적으로 필요한 것만 제공한다.
  * 공개 인터페이스는 사용자가 엑세스할 수 있는 것을 정의한다.
  * 정보 시스템 관점이 아니라 사용자 관점에서 클래스를 설계하는 것이 매우 중요하다.
  * 클래스를 설계할 때 요구 사항을 점검하고 개발자가 아니라 실제로 클래스를 사용할 사람들과 함께 설계하도록 한다.
### 사용자 확인
* 객체에 메시지를 보내는 모든 객체를 사용자로 고려
### 객체 행위
* 모든 사용자 관점에서 각 객체의 목적과 제대로 수행하기 위해 무슨 일을 해야 하는지를 확인해야 함
### 환경적 제약 사항
* 환경적 제약 사항은 거의 대부분이 변수
### 공개 인터페이스 확인
* 객체 행위 및 환경에 대한 모든 정보를 수집하면 각 사용자 객체에 대한 공개 인터페이스를 확인해야 함
* 이론적으로 구현으로 간주되는 모든 것은 사용자가 클래스와 인터페이스하는 방법에 영향을 주지 않고 변경할 수 있다는 의미
### 구현 확인
* 사용자가 객체를 보는 방법을 나타내는 것이 인터페이스라면 구현은 객체의 실체 핵심 구성 재료
### 결론
* 자심만의 방식으로 OO 사고를 설명하는 방법을 생각해보도록 하자
## Chapter 3 고급 객체지향 개념
### 생성자
* 컴파일러는 메서드 이름이 클래스 이름과 같다는 것을 인식하고 메서드를 생성자로 간주
#### 언제 생성자를 호출하는가?
* 새 객체를 만들 때 가장 먼저 발생하는 일 중 하나가 생성자를 호출하는 것
#### 생성자 내부에는 무엇이 있는가?
* 생성자의 가장 중요한 기능 중 하나는 새로운 키워드를 만났을 때 할당된 메모리를 초기화하는 것일 것
#### 기본 생성자
* 생성자를 제공하지 않으면 시스템에서 대신하여 기본 생성자를 제공
* 클래스에 속성이 있는 경우에는 항상 초기화하는 것이 좋음
#### 다중 생성자 사용
#### 메서드 오버로딩
* 오버로딩은 메서드 서명이 매번 다르기만 하면 프로그램머가 계속해서 동일한 메소드 이름을 사용할 수있도록 함
* 서명은 메서드 이름과 매개변수 목록으로 구성
#### UML을 사용하여 클래스 모델링
#### 상위 클래스가 생성되는 방법
#### 생성자 설계
* 설계하는 동안 모든 속성의 안정적인 상태를 확인한 다음, 생성자에서 안정적인 상태로 설정하는 것이 바람직함
### 오류 처리
#### 문제를 무시한다
#### 문제를 점검하고 응용 프로그램을 취소한다
#### 문제를 점검하고 복구를 시도한다
#### 예외 던지기
### 범위의 개념
#### 로컬 속성
#### 객체 속성
#### 클래스 속성
### 연산자 오버로딩
### 다중 상속
### 객체 연산
### 결론
## Chapter 4 클래스 해부
### 클래스의 이름
### 주석
### 속성
### 생성자
### 접근자
### 공개 인터페이스 메서드
### 비공개 구현 메서드
### 결론
## Chapter 5 클래스 설계 지침
### 현실 세계 시스템 모델링
### 공개 인터페이스 확인
#### 최소한의 공개 인터페이스
#### 구현 은닉
### 견고한 생성자(또는 소멸자) 설계
### 오류 처리를 클래스 속에 설계
#### 클래스 문서 작성 및 주석 사용
#### 협력하기 위한 객체 구성
### 재사용을 고려한 설계
### 확장성을 고려하여 설계
#### 서술형 이름 사용
#### 이식 불가 코드 추상화
#### 객체 복사 및 비교 방법 제공
#### 가능한 작은 범위 유지
#### 클래스가 스스로 책임지도록 한다
### 유지보수를 고려하여 설계
#### 반복 사용
#### 인터페이스 테스트
### 객체 지속성 사용
#### 객체 직렬화와 마샬링
### 결론
## Chapter 6 객체를 사용한 설계
### 설계 지침
#### 적합한 분석 수행
#### 작업 명세서(SOW) 개발
#### 요구 사항 수집
#### 사용자 인터페이스 원형 개발
#### 클래스 확인
#### 각 클래스의 책임 역할 결정
#### 클래스가 상호 협업하는 방법 결정
#### 시스템을 설명하는 클래스 모델 작성
### 사례 연구: 블랙잭 예제
#### CRC 카드 사용
#### 블랙잭 클래스 확인
#### 클래스의 책임 역할 확인
#### UML 유스케이스: 협업 확인
#### 처음 통과한 CRC 카드
#### UML 클래스 다이어그램: 객체 모델
#### 사용자 인터페이스 원형 작성
### 결론
## Chapter 7 상속과 조합
### 객체 재사용
### 상속
#### 일반화 및 특수화
#### 설계상 결정
### 조합
#### UML을 사용하여 조합 표시
### 캡슐화가 OO의 기본이 되는 이유
#### 상속이 캡슐화를 약화시키는 방법
#### 다형성에 대한 자세한 예제
#### 객체 책임 역할
### 결론
## Chapter 8 프레임워크와 재사용: 인터페이스와 추상 클래스를 이용한 설계
### 코드: 재사용할 것인가? 재사용하지 않을 것인가?
### 프레임워크란 무엇인가?
### 계약이란 무엇인가?
#### 추상 클래스
#### 인터페이스
#### 한 곳에 묶기
#### 컴파일러 증명
#### 계약 체결
#### 시스템 플러그인 포인트
### E-비즈니스 예제
#### E-비즈니스 문제
#### 재사용하지 않는 접근 방법
#### E-비즈니스 솔루션
#### UML 객체 모델
### 결론
## Chapter 9 객체 구성
### 조합 관계
### 단계별 구성
### 조합의 유형
#### 집합
#### 연관
#### 연관과 집합을 함께 사용하기
### 의존 관계 피하기
### 카디널리티
#### 다중 객체 연관
#### 선택적 연관
### 하나로 결합하기: 예제
### 결론
## Chapter 10 UML을 이용한 객체 모델 생성
### UML이란?
### 클래스 다이어그램의 구조
### 속성과 메서드
#### 속성
#### 메서드
### 액세스 표시
### 상속
### 인터페이스
### 조합
#$## 집합
#$## 연관
### 카디널리티
### 결론
## Chapter 11 객체와 이식 가능한 데이터: XML
### 이식 가능 데이터
### 확장 가능 마크업 언어(XML)
### XML과 HTML
### XML과 객체지향 언어
### 두 회사 간 데이터 공유
### DTD를 사용하여 문서 유효성 확인
### DTD를 XML 문서에 통합
### CSS의 사용
### 결론
## Chapter 12 지속 객체: 직렬화와 관계형 데이터베이스
### 지속 객체 기초
### 객체를 플랫 파일로 저장
#### 파일 직렬화
#### 다시 살펴보는 구현 및 인터페이스
#### 메서드는 어떤가?
### 직렬화 과정에서 XML 사용
### 관계형 데이터베이스에 기록
#### 관계형 데이터베이스 액세스
#### 드라이버 로딩
#### 연결 맺기
### SQL 문
### 결론
## Chapter 13 객체와 인터넷
### 분산 컴퓨팅의 발전
### 객체 기반 스크립팅 언어
### JavaScript 유효성 확인 예제
### 웹 페이지에 있는 객체
#### JavaScript 객체
#### 웹 페이지 컨트롤
#### 사운드 플레이어
#### 동영상 플레이어
#### Flash
### 분산 객체와 엔터프라이즈
#### CORBA
#### 웹 서비스 정의
#### 웹 서비스 코드
#### Invoice.cs
#### Invoice.vb
### 결론
## Chapter 14 객체와 클라이언트/서버 응용 프로그램
### 클라이언트/서버 접근 방법
### 독자 표준 접근 방법
#### 직렬화된 객체 코드
#### 클라이언트 코드
#### 서버 코드
#### 독자 표준 클라이언트/서버 예제 실행
### 독자 표준이 아닌 접근 방법
#### 객체 정의 코드
#### 클라이언트 코드
#### 서버 코드
#### 독자 표준이 아닌 클라이언트/서버 예제 실행
### 결론
## Chapter 15 설계 패턴
### 왜 설계 패턴인가?
### Smalltalk 모델/뷰/컨트롤러
### 설계 패턴의 유형
#### 생성 패턴
#### 구조 패턴
#### 행동 패턴
### 안티패턴
### 결론