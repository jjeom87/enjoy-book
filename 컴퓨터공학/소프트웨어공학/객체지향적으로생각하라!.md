# 객체지향적으로 생각하라!

## Chapter 1 객체지향 개념 소개
### 절차지향과 OO 프로그래밍
* 객체(object)란 데이터와 행위를 모두 가지고 있는 실체(엔티티, entity)
* 객체는 다른 소프트웨어 개발 패러다임을 교체하는 것이라기보다는 한 단계 발전된 반응
* 객체에서 메서드는 데이터에 대한 연산과 기타 작업을 수행하기 위해 사용
* 캡슐화라고 부르는 방법을 통해, 즉 속성과 메서드를 통일한 엔터티에 결합함으로써 Math 객체에 있는 데이터에 대한 엑세스를 제어할 수 있음
* 여러 작업을 수행하는 커다란 객체를 만드는 것보다는 특정 작업을 하는 작은 객체를 만드는 것이 낫음
### 절차지향에서 객체지향 개발로 이동
#### 절차지향 프로그래밍
* 절차지향 프로그래밍에서는 보통 한 시스템에 있는 데이터를 그 데이터를 사용하는 연산으로 부터 분리
#### OO 프로그래밍
* OO 프로그래밍의 근본적인 장점은 데이터와 그 데이터를 이용하는 연산이 모두 객체안에 캡슐로 쌓인다는 점
### 객체란 정확히 무엇인가?
* 객체는 OO 프로그램을 구성하는 블록
* OO 기술을 사용하는 프로그램은 기본적으로 객체 집합
#### 객체 데이터
* 객체 내에 저장된 데이터는 객체의 상태를 나타냄
* OO 프로그램밍 용어에서는 이 데이터를 속성(attribute)이라 함
#### 객체 행위
* 객체의 행위(behavior)는 객체가 할 수 있는 일
* OO 프로그래밍 용어에서 이런 행위는 메서드에 포함되어 있으며 메시지를 보내서 메서드를 호출할 수 있음
### 클래스란 정확히 무엇인가?
* 클래스는 객체에 대한 청사진
* 객체의 인스턴스를 만들 때 객체를 구성하는 기초로 클래스를 사용
#### 클래스는 객체 템플릿이다
#### 속성
#### 메서드
#### 메시지
### UML을 사용하여 클래스 다이어그램 모델 만들기
### 캡슐화와 데이터 은닉
#### 인터페이스
#### 구현
#### 인터페이스/구현 패러다임의 실제 예
#### 인터페이스/구현 패러다임의 모델
### 상속
#### 상위 클래스와 하위 클래스
#### 추상화
#### Is-a 관계
### 다형성
### 조합
#### 추상화
#### Has-a 관계
### 결론
## Chapter 2 객체 관점에서 생각하는 방법
### 인터페이스와 구현 간의 차이가 있다는 점을 인식
### 인터페이스
### 구현
### 인터페이스/구현 예
### 인터페이스를 설계할 때 추상적으로 생각하기
### 사용자에게 가능한 최소한의 인터페이스를 제공
### 사용자 확인
### 객체 행위
### 환경적 제약 사항
### 공개 인터페이스 확인
### 구현 확인
### 결론
### 참고 도서
## Chapter 3 고급 객체지향 개념
### 생성자
#### 언제 생성자를 호출하는가?
#### 생성자 내부에는 무엇이 있는가?
#### 기본 생성자
#### 다중 생성자 사용
#### 생성자 설계
### 오류 처리
#### 문제를 무시한다
#### 문제를 점검하고 응용 프로그램을 취소한다
#### 문제를 점검하고 복구를 시도한다
#### 예외 던지기
### 범위의 개념
#### 로컬 속성
#### 객체 속성
#### 클래스 속성
### 연산자 오버로딩
### 다중 상속
### 객체 연산
### 결론
## Chapter 4 클래스 해부
### 클래스의 이름
### 주석
### 속성
### 생성자
### 접근자
### 공개 인터페이스 메서드
### 비공개 구현 메서드
### 결론
## Chapter 5 클래스 설계 지침
### 현실 세계 시스템 모델링
### 공개 인터페이스 확인
#### 최소한의 공개 인터페이스
#### 구현 은닉
### 견고한 생성자(또는 소멸자) 설계
### 오류 처리를 클래스 속에 설계
#### 클래스 문서 작성 및 주석 사용
#### 협력하기 위한 객체 구성
### 재사용을 고려한 설계
### 확장성을 고려하여 설계
#### 서술형 이름 사용
#### 이식 불가 코드 추상화
#### 객체 복사 및 비교 방법 제공
#### 가능한 작은 범위 유지
#### 클래스가 스스로 책임지도록 한다
### 유지보수를 고려하여 설계
#### 반복 사용
#### 인터페이스 테스트
### 객체 지속성 사용
#### 객체 직렬화와 마샬링
### 결론
## Chapter 6 객체를 사용한 설계
### 설계 지침
#### 적합한 분석 수행
#### 작업 명세서(SOW) 개발
#### 요구 사항 수집
#### 사용자 인터페이스 원형 개발
#### 클래스 확인
#### 각 클래스의 책임 역할 결정
#### 클래스가 상호 협업하는 방법 결정
#### 시스템을 설명하는 클래스 모델 작성
### 사례 연구: 블랙잭 예제
#### CRC 카드 사용
#### 블랙잭 클래스 확인
#### 클래스의 책임 역할 확인
#### UML 유스케이스: 협업 확인
#### 처음 통과한 CRC 카드
#### UML 클래스 다이어그램: 객체 모델
#### 사용자 인터페이스 원형 작성
### 결론
## Chapter 7 상속과 조합
### 객체 재사용
### 상속
#### 일반화 및 특수화
#### 설계상 결정
### 조합
#### UML을 사용하여 조합 표시
### 캡슐화가 OO의 기본이 되는 이유
#### 상속이 캡슐화를 약화시키는 방법
#### 다형성에 대한 자세한 예제
#### 객체 책임 역할
### 결론
## Chapter 8 프레임워크와 재사용: 인터페이스와 추상 클래스를 이용한 설계
### 코드: 재사용할 것인가? 재사용하지 않을 것인가?
### 프레임워크란 무엇인가?
### 계약이란 무엇인가?
#### 추상 클래스
#### 인터페이스
#### 한 곳에 묶기
#### 컴파일러 증명
#### 계약 체결
#### 시스템 플러그인 포인트
### E-비즈니스 예제
#### E-비즈니스 문제
#### 재사용하지 않는 접근 방법
#### E-비즈니스 솔루션
#### UML 객체 모델
### 결론
## Chapter 9 객체 구성
### 조합 관계
### 단계별 구성
### 조합의 유형
#### 집합
#### 연관
#### 연관과 집합을 함께 사용하기
### 의존 관계 피하기
### 카디널리티
#### 다중 객체 연관
#### 선택적 연관
### 하나로 결합하기: 예제
### 결론
## Chapter 10 UML을 이용한 객체 모델 생성
### UML이란?
### 클래스 다이어그램의 구조
### 속성과 메서드
#### 속성
#### 메서드
### 액세스 표시
### 상속
### 인터페이스
### 조합
#$## 집합
#$## 연관
### 카디널리티
### 결론
## Chapter 11 객체와 이식 가능한 데이터: XML
### 이식 가능 데이터
### 확장 가능 마크업 언어(XML)
### XML과 HTML
### XML과 객체지향 언어
### 두 회사 간 데이터 공유
### DTD를 사용하여 문서 유효성 확인
### DTD를 XML 문서에 통합
### CSS의 사용
### 결론
## Chapter 12 지속 객체: 직렬화와 관계형 데이터베이스
### 지속 객체 기초
### 객체를 플랫 파일로 저장
#### 파일 직렬화
#### 다시 살펴보는 구현 및 인터페이스
#### 메서드는 어떤가?
### 직렬화 과정에서 XML 사용
### 관계형 데이터베이스에 기록
#### 관계형 데이터베이스 액세스
#### 드라이버 로딩
#### 연결 맺기
### SQL 문
### 결론
## Chapter 13 객체와 인터넷
### 분산 컴퓨팅의 발전
### 객체 기반 스크립팅 언어
### JavaScript 유효성 확인 예제
### 웹 페이지에 있는 객체
#### JavaScript 객체
#### 웹 페이지 컨트롤
#### 사운드 플레이어
#### 동영상 플레이어
#### Flash
### 분산 객체와 엔터프라이즈
#### CORBA
#### 웹 서비스 정의
#### 웹 서비스 코드
#### Invoice.cs
#### Invoice.vb
### 결론
## Chapter 14 객체와 클라이언트/서버 응용 프로그램
### 클라이언트/서버 접근 방법
### 독자 표준 접근 방법
#### 직렬화된 객체 코드
#### 클라이언트 코드
#### 서버 코드
#### 독자 표준 클라이언트/서버 예제 실행
### 독자 표준이 아닌 접근 방법
#### 객체 정의 코드
#### 클라이언트 코드
#### 서버 코드
#### 독자 표준이 아닌 클라이언트/서버 예제 실행
### 결론
## Chapter 15 설계 패턴
### 왜 설계 패턴인가?
### Smalltalk 모델/뷰/컨트롤러
### 설계 패턴의 유형
#### 생성 패턴
#### 구조 패턴
#### 행동 패턴
### 안티패턴
### 결론