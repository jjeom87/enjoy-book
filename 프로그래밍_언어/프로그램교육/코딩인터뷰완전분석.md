# 코딩인터뷰 완전분석

## I. 면접 과정
* 분석 능력, 코딩 능력, 기술적 지식 및 컴퓨터 과학 기본, 경험, 문화와 얼마나 맞는지 / 의사 소통 능력

##### 면접의 방식은 왜 이래야 하는가

###### 부정 오류(false negative)도 괜찮다
* 회사는 훌륭한 사람을 놓치면 리크루팅 비용이 증가하기 때문에 피하지만 몇 명을 놓치는 것을 받아들임
* 회사는 긍정 오류의 경우를 더 걱정함

###### 문제풀이는 꽤 가치 있는 능력이다
* 머리가 좋은 게 전부는 아니지만 매력적인 요소임에는 틀림없음

###### 기초적인 자료구조와 알고리즘 지식은 유용하다
* 대다수의 문제풀이와 관련된 질문은 자료구조와 알고리즘을 바탕으로 이루어짐

###### 화이트보드가 무엇에 집중해야 하는지 알려준다
* 화이트보드의 좋은 점 중 하나는 큰 그림을 그리는데 도움을 줌
* 코드의 '핵심'에만 신경 쓰면 됨

###### 그렇다고 이 방법이 모든 회사와 모든 상황을 위한 것은 아니다
* 현실을 받아들이고, 주어진 것에 최선을 다하자

##### 어떤 문제를 출제하는가
* 어떤 면접관이 최근에 어떤 질문을 했는지가 더 적합한 질문이 될 것
* 구글의 알고리즘 문제와 페이스북의 알고리즘 문제는 근본적으로 동일

##### 모든 것은 상대적이다
* 면접관은 같은 문제를 풀었던 다른 지원자들의 역량과 상태적인 비교를 통해 평가를 내림

##### 자주 받는 질문

###### 면접 후에 아무 연락을 받지 못했어요. 떨어진 건가요?

###### 탈락한 후에 재지원할 수 있나요?

## II. 장막 너머

##### 마이크로소프트 면접

##### 아마존 면접

##### 구글 면접

##### 애플 면접

##### 페이스북 면접

##### 팰런티어 면접

## III. 특별한 상황에서의 면접

##### 경력자

##### 테스터 혹은 SDET

##### PM

##### 개발 책임자와 관리자

##### 스타트업

##### 기업 인수 및 인재 영입

##### 면접관의 입장

## IV. 면접 전에

##### 적절한 경험 쌓기

##### 탄탄한 이력서 작성하기

##### 준비 절차

## V. 행동 문제

##### 대비 요령

##### 기술적 프로젝트에 대한 이해

##### 행동 질문에 대한 대처 요령

##### 그러니까, 당신에 대해 말해보세요

## VI big-O

##### 비유하기

##### 시간 복잡도
* 점근적 실행 시간(asymptotic runtime), 또는 big-O 시간에 대한 개념
* 온라인 전송 : O(s), s는 파일의 크기. 파일의 크기가 증가함에 따라 전송 시간 또한 선형적으로 증가
* 비행기를 통한 전송 : 파일 크기에 관계업싱 O(1). 상수 시간 만큼 소요

###### big-O, big-Θ, big-Ω
* O (big-O) : 학계에서 big-O는 시간의 상한을 나타냄
* Ω (big-Omega) : 학계에서 Ω는 등가 개념 혹은 하한을 나타냄
* Θ (big theta) : 학계에서 Θ는 O와 Ω 둘 다 의미

###### 최선의 경우, 최악의 경우, 평균적인 경우
* 최선의 경우 : 모든 원소가 동일한 퀵 정렬의 수행 시간 O(N)
* 최악의 경우 : 배열에서 가장 큰 원소가 계속해서 축이 된 경우 큌 정렬의 수행 시간 O(N²)
* 평균적인 경우 : O(NlogN)

###### 최선의/최악의/평균적인 경우와 big-O/Θ/Ω 사이의 관련성
* big-O, big-Ω, big-Θ는 각각 상한, 하한, 딱 맞는 수행 시간을 의미

##### 공간 복잡도
* 공간 복잡도는 시간 복잡도와 평행선을 달리는 개념
* 재귀 호출에서 사용하는 스택 공간 또한 공간 복잡도 계산에 포함

##### 상수항은 무시하라
* big-O는 단순히 증가하는 비율을 나타내는 개념
* 특수한 입력에 한해 O(N) 코드가 O(1) 코드보다 빠르게 동작하는 것은 매우 가능성 있는 얘기
* O(2*N)으로 표기 되어야 할 알고리즘을 실제로는 O(N)으로 표기

##### 지배적이지 않은 항은 무시하라
* O(N² + N)은 O(N²)
* O(N + logN)은 O(N)
* O(5*2ⁿ + 1000^100)은 ○(2ⁿ)

##### 여러 부분으로 이루어진 알고리즘: 덧셈 vs. 곱셈
* 덧셈 수행 시간: O(A+B)
```
for (int a : arrA) {
  print(a);
}

for (int b : arrB) {
  print(b);
}
```
* 곱셈 수행 시간: O(A*B)
```
for (int a : arrA) {
  for(int b : arrB) {
    print(a + "," + b);
  }
}
```

##### 상환 시간

##### log N 수행 시간

##### 재귀적으로 수행 시간 구하기

##### 예제 및 연습 문제

###### 예제 1

```java
void foo(int[] array) {
  int sum = 0;
  int product = 1;

  for (int i; i < array.length; i++) {
    sum += array[i];
  }

  for (int i; i < array.length; i++) {
    product *= array[i];
  }
  System.out.println(sum + "," + product);
}
```
* O(n)

###### 예제 2

## VII. 기술적 문제

### 준비하기

### 알고 있어야 할 것들

### 실제 문제 살펴보기

### 최적화 및 문제풀이 기술 #1: BUD를 찾으라

### 최적화 및 문제풀이 기술 #2: 스스로 풀어보라 DIY(Do It Yourself)

### 최적화 및 문제풀이 기술 #3: 단순화, 일반화하라

### 최적화 및 문제풀이 기술 #4: 초기 사례(base case)로부터 확장하기(build)

### 최적화 및 문제풀이 기술 #5: 자료구조 브레인스토밍

### 가능한 최선의 수행 시간(Best Conceivable Runtime(BCR))

### 오답에 대한 대처법

### 알고 있던 문제가 면접에 나왔을 때

### 면접용으로 ‘완벽한’ 언어

### 어떤 코드가 좋아 보이나

### 포기하지 말라

## VIII. 합격한 뒤에

### 합격 또는 거절 통지에 대처하는 요령

### 입사 제안 평가

### 연봉 협상

### 입사 후

## IX. 면접 문제

### 자료구조

#### 01 배열과 문자열

##### 해시테이블

##### ArrayList와 가변 크기 배열

##### StringBuilder

##### 면접 문제

#### 02 연결리스트

##### 연결리스트 만들기

##### 단방향 연결리스트에서 노드 삭제

##### Runner 기법

##### 재귀 문제

##### 면접 문제

#### 03 스택과 큐

##### 스택 구현하기

##### 큐 구현하기

##### 면접 문제

#### 04 트리와 그래프

##### 트리의 종류

##### 이진 트리 순회

##### 이진 힙(최소힙과 최대힙)

##### 트라이(접두사 트리)

##### 그래프

##### 면접 문제

### 개념과 알고리즘

#### 05 비트 조작

##### 손으로 비트 조작 해보기

##### 비트 조작을 할 때 알아야 할 사실들과 트릭들

##### 2의 보수와 음수

##### 산술 우측 시프트 vs. 논리 우측 시프트

##### 기본적인 비트 조작: 비트값 확인 및 채워넣기

##### 면접 문제

#### 06 수학 및 논리 퍼즐

##### 소수

##### 확률

##### 입을 열라

##### 규칙과 패턴을 찾으라

##### 최악의 경우는?

##### 알고리즘적 접근법

##### 면접 문제

#### 07 객체 지향 설계

##### 접근법

##### 디자인 패턴

##### 면접 문제

#### 08 재귀와 동적 프로그래밍

##### 접근법

##### 재귀적 해법 vs. 순환적 해법

##### 동적계획법 & 메모이제이션

##### 면접 문제

#### 09 시스템 설계 및 규모 확장성

##### 문제를 다루는 방법

##### 시스템 설계: 단계별 접근법

##### 규모 확장을 위한 알고리즘: 단계별 접근법

##### 시스템 설계의 핵심 개념

##### 데이터베이스 분할(샤딩)

##### 시스템 설계 시 고려할 점

#####  ‘완벽한’ 시스템은 없다

##### 연습 문제

##### 면접 문제

#### 10 정렬과 탐색

##### 널리 사용되는 정렬 알고리즘

##### 면접 문제

#### 11 테스팅

##### 면접관이 평가하는 것

##### 실제 세계에서 객체 테스트하기

##### 소프트웨어 테스팅

##### 함수 테스트

##### 문제 해결에 관한 문제

##### 면접 문제

### 지식 기반 문제

#### 12 C와 C++

##### 클래스와 상속

##### 생성자와 소멸자

##### 가상 함수

##### 가상 소멸자

##### 기본값

##### 연산자 오버로딩

##### 포인터와 참조

##### 템플릿

##### 면접 문제

#### 13 자바

##### 언어 자체 질문에 대한 접근법

##### 오버로딩 vs. 오버라이딩

##### 컬렉션 프레임워크

##### 면접 문제

#### 14 데이터베이스

##### SQL 문법과 그 변종들

##### 비정규화 vs. 정규화 데이터베이스

##### SQL 문

##### 소규모 데이터베이스 설계

##### 대규모 데이터베이스 설계

##### 면접 문제

#### 15 스레드와 락

##### 자바의 스레드

##### 동기화와 락

##### 교착상태와 교착상태 방지

##### 면접 문제

##### 추가 연습문제

#### 16 중간 난이도 연습문제

#### 17 어려운 연습문제

## X. 해법

### 자료구조

#### 01 배열과 문자열 해법

#### 02 연결리스트 해법

#### 03 스택과 큐 해법

#### 04 트리와 그래프 해법

### 개념과 알고리즘

#### 05 비트 조작 해법

#### 06 수학 및 논리 퍼즐 해법

#### 07 객체 지향 설계 해법

#### 08 재귀와 동적 프로그래밍 해법

#### 09 시스템 설계 및 규모 확장성 해법

#### 10 정렬과 탐색 해법

#### 11 테스팅 해법

### 지식 기반

#### 12 C와 C++ 해법

#### 13 자바 해법

#### 14 데이터베이스 해법

#### 15 스레드와 락 해법

### 추가 연습문제

#### 16 중간 난이도 연습문제 해법

#### 17 어려운 연습문제 해법

## XI. 고급 주제

### 유용한 수학

### 위상정렬

### 다익스트라 알고리즘

### 해시테이블에서 충돌을 해결하는 방법

### 선형 탐사법을 이용한 개방 주소법

### Rabin-Karp 부분 문자열 탐색 알고리즘

### AVL 트리

### 레드-블랙 트리

### MapReduce

### 추가 공부거리

## XII. 코드 라이브러리

### HashMapList[T, E]

### TreeNode(이진 탐색 트리)

### LinkedListNode(연결리스트)

### Trie & TrieNode

## XIII. 힌트

### 01 자료구조 힌트

### 02 개념 및 알고리즘 힌트

### 03 지식 기반 문제 힌트

### 04 추가 연습 문제 힌트
