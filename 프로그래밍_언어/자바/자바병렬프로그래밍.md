# 자바 병렬 프로그래밍

### 1장 개요
#### 작업을 동시에 실행하는 일에 대한 (아주) 간략한 역사
* 프로세스끼리는 서로 통신을 할 수도 있는데 소켓, 시그널 핸들러, 공 유메모리, 세마포어, 파일등의 비교적 큰단위의 다양한통신수단이 제공
* 운영체제를 개발하게 된 몇 가지 요인
 * 자원 활용 
   * 프로그램은 때로 입출력과 같이 외부 동작이 끝나기를 기다려야 송}는 경우 가 많은데 기다리는 동안은 유용한 일을 처리하지 못함 
   * 하나의 프로그램이 기다리는 동안 다른 프로그램을 실행하도록 지원하는 편이 더 효율적
 * 공정성 
   * 여러 시용자와 프로그램이 컴퓨터 내 자원에 대해 통일한 권한을 가질 수 있음 
   * 한 번에 프로그램 하나를 끝까지 실행해 종료된 이후에야 다른 프로그램을 시작하 는 것보다는 더 작은 단위로 컴퓨터를 공유하는 방법이 바람직
 * 편의성
   * 때론 여러 작업을 전부 처리하는 프로그램 하나를 작성하는 것보다 각기 일을 하나씩 처리하고 필요할 때 프로그램 간에 조율랜 프로그램을 여러 개 작성하는 편이 더 쉽고 바람직
* 자원 활용, 공정성, 편의성 등 프로세스 개념을 만들어내게 된 것과 같은 동기를 갖고 스레드가 고안
* 스레드로 인해 한 프로세스 안에 여러 개의 프로그램 제어흐름이 공존
* 스레드는 메모리 파일 핸들과 같이 프로세스에 할당된 자원을 공유
* 스레드는 각기 별도의 프로그램 카운터, 스택, 지역 변수를 가짐
* 현대 운영체제의 대부분은 프로세스가 아니라 스레드를 기본 단위로 CPU 자원의 스케줄을 정함
* 스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드는 같은 변수에 접근하고 같은 협 heap에 객체를 할당
* 공유 된 데이터에 접근하는 과정을 적절하게 동기화하지 않으면 다른 스레드가 사용 중인 변수를 순간적으로 수정해서 예상치 못한 결과
#### 스레드의 이점
##### 멀티프로세스 활용
* 제대로 설계하기만 한 다면 멀티스레드 프로그램은 가용한 프로세서 자원을 더 효율적으로 이용해서 처리 속도를 높일 수 있음
* I/O 때문에 대기 상태에 들어가는 동안에도 다른 스레드는 동작할 수 있기 때문에 애플리케이션이 계속 실행
##### 단순한 모델링
* 한 종류 일을 순차적으로 처리하는 프로그램은 작성하 기 쉽고 오류도 별로 생기지 않음
* 여러 종류의 일을 동시에 처리하는 프로그램 보다 태스트하기도 쉬움
##### 단순한 비동기 이벤트 처리
* 각 요청을 별개 스레드에서 처리하면 대기 상태에 들어가도 다른 스레드가 요청을 처리하는 데는 별 영향을 끼치지 않음
##### 더 빨리 반응하는 사용자 인터페이스
* 시간이 오래 걸릴 작업을 별도 스레드에서 실행했다면 이벤트 스레드는 계속 UI 이벤트를 처리할 수 있어 UI가 더 빨리 반응
#### 스레드 사용의 위험성
##### 안전성 위해 요소
* 스레드 안전성은 생각보다 미묘 
* 동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산의 순서가 때론 놀라울 만큼 예측하기가 어렵움
![UnsafeSequence.getNext 메소드가 잘못 동작하는 예](/images/프로그래밍_언어/자바/자바병렬프로그래밍/figure_1-1.png)
##### 활동성 위험
* 단일 스레드 프로그램에서는 나타나지 않는 추가적인 형태의 활동성 liveness 장애가 생길 수 있음
* 스레드에서 실행하는 작업의 상대적인 타이밍에 따라 활동성 문제점이 나타나기 때문에 개발이나 테스트 도중에 잘 드러나지는 않음
##### 성능 위험
* 멀티스레드 프로그램은 단일 스레드 프로그램에서 발생할 수 있는 모든 성능 위험뿐만 아니라, 스레드를 사용하기 때문에 생기는 추가 위험에도 노출
* 스레드가 많은 프로그램에서는 컨텍스트 스위칭 (다른 스레드가 실행될 수 있게 스케줄러가 현재 실행 중인 스레드를 잠시 멈출 때)이 더 빈번하고 그 때문에 상당한부담이 생김
#### 스레드는 어디에나
* 프로그램을 작성할 때 스레드를 직접 생성하지 않더라도 프로그램이 사용하는 프레임웍에서 스레드를 생성할 수도 있음
## 1부 기본 원리
### 2장 스레드 안전성
* 객체의 상태는 인스턴스나 static 변수 같은 상태 변수에 저장된 객체의 데이터
#### 스레드 안정성이란?
#### 단일 연산
#### 락
#### 락으로 상태 보호하기
#### 활동성과 성능
### 3장 객체 공유
#### 가시성
#### 공개와 유출
#### 스레드 한정
#### 불변셩
#### 안전 공개
### 4장 객체 구성
#### 스레드 안전한 클래스 설계
#### 인스턴스 한정
#### 스레드 안전성 위임
#### 스레드 안전하게 구현된 클래스에 기능 추가
#### 동기화 정책 문서화 하기
### 5장 프로그래밍 단위
#### 동기화된 컬렉션 클래스
#### 병렬 컬렉션
#### 블로킹 큐와 프로듀서-컨슈머 패턴
#### 블로킹 메소드, 인터럽터블 메소드
#### 동기화 클래스
#### 효율적이고 확장성 있는 결과 캐시 구현
## 2부 병렬 프로그램 구조 잡기
### 6장 작업 실행
#### 스레드에서 작업 실행
#### Executor 프레임웍
#### 병렬로 처리할 만한 작업
### 7장	중단 및 종료
#### 작업 중단
#### 스레드 기반 서비스 중단
#### 비정상적인 스레드 종료 상황 처리
#### JVM 종료
### 8장 스레드 풀 활용
#### 작업과 실행 정책 간의 보이지 않는 연결 관계
#### 스레드 풀 크기 조절
#### ThreadPoolExecutor 설정
#### ThreadPoolExecutor 상속
#### 재귀 함수 병렬화
### 9장 GUI 애플리케이션
#### GUI는 왜 단일 스레드로 동작하는가?
#### 짧게 실행되는 GUI 작업
#### 장시간 실행되는 GUI 작업
#### 데이터 공유 모델
#### 다른 형태의 단일 스레드 서브시스
## 3부	가용성, 성능, 테스트
### 10장	가용성을 최대로 높이기
#### 데드락
#### 데드락 방지 및 원인 추척
#### 그 밖의 활동성 문제점
### 11장	성능, 확장성
#### 성능에 대해
#### 암달의 법칙
#### 스레드와 비용
#### 락 경쟁 줄이기
#### 예제: Map 객체의 성능 분석
### 12장 병렬 프로그램 테스트
#### 정확성 테스트
#### 성능 테스트
#### 성능 측정의 함정 피하기
#### 보조적인 테스트 방
## 4부 고급 주제
### 13장 명시적인 락
#### Lock과 ReentrantLock
#### 성능에 대한 고려 사항
#### 공정성
#### synchronized 또는 ReentrantLock 선택
#### 읽기-쓰기 락
### 14장 전용 동기화 기능 구현
#### 상태 종속성 관리
#### 조건 큐 활용
#### 명시적인 조건 객체
#### 동기화 클래스의 내부 구조
#### AbstractQueuedSynchronizer
#### java.uitl.concurrent 패키지의 동기화 클래스에서 AQS 활용 모습
### 15장 단일 연산 변수와 넌블로킹 동기화
#### 락의 단점
#### 병렬 연산을 위한 하드웨어적인 지원
#### 단일 연산 변수 클래스
#### 넌블로킹 알고리즘
### 16장 자바 메모리 모델
#### 자바 메모리 모델은 무엇이며, 왜 사용해야 하는가?
#### 안전한 공개
#### 초기화 안전성