# 자바 병렬 프로그래밍

### 1장 개요
#### 작업을 동시에 실행하는 일에 대한 (아주) 간략한 역사
* 프로세스끼리는 서로 통신을 할 수도 있는데 소켓, 시그널 핸들러, 공 유메모리, 세마포어, 파일등의 비교적 큰단위의 다양한통신수단이 제공
* 운영체제를 개발하게 된 몇 가지 요인
 * 자원 활용 
   * 프로그램은 때로 입출력과 같이 외부 동작이 끝나기를 기다려야 송}는 경우 가 많은데 기다리는 동안은 유용한 일을 처리하지 못함 
   * 하나의 프로그램이 기다리는 동안 다른 프로그램을 실행하도록 지원하는 편이 더 효율적
 * 공정성 
   * 여러 시용자와 프로그램이 컴퓨터 내 자원에 대해 통일한 권한을 가질 수 있음 
   * 한 번에 프로그램 하나를 끝까지 실행해 종료된 이후에야 다른 프로그램을 시작하 는 것보다는 더 작은 단위로 컴퓨터를 공유하는 방법이 바람직
 * 편의성
   * 때론 여러 작업을 전부 처리하는 프로그램 하나를 작성하는 것보다 각기 일을 하나씩 처리하고 필요할 때 프로그램 간에 조율랜 프로그램을 여러 개 작성하는 편이 더 쉽고 바람직
* 자원 활용, 공정성, 편의성 등 프로세스 개념을 만들어내게 된 것과 같은 동기를 갖고 스레드가 고안
* 스레드로 인해 한 프로세스 안에 여러 개의 프로그램 제어흐름이 공존
* 스레드는 메모리 파일 핸들과 같이 프로세스에 할당된 자원을 공유
* 스레드는 각기 별도의 프로그램 카운터, 스택, 지역 변수를 가짐
* 현대 운영체제의 대부분은 프로세스가 아니라 스레드를 기본 단위로 CPU 자원의 스케줄을 정함
* 스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드는 같은 변수에 접근하고 같은 협 heap에 객체를 할당
* 공유 된 데이터에 접근하는 과정을 적절하게 동기화하지 않으면 다른 스레드가 사용 중인 변수를 순간적으로 수정해서 예상치 못한 결과
#### 스레드의 이점
##### 멀티프로세스 활용
* 제대로 설계하기만 한 다면 멀티스레드 프로그램은 가용한 프로세서 자원을 더 효율적으로 이용해서 처리 속도를 높일 수 있음
* I/O 때문에 대기 상태에 들어가는 동안에도 다른 스레드는 동작할 수 있기 때문에 애플리케이션이 계속 실행
##### 단순한 모델링
* 한 종류 일을 순차적으로 처리하는 프로그램은 작성하 기 쉽고 오류도 별로 생기지 않음
* 여러 종류의 일을 동시에 처리하는 프로그램 보다 태스트하기도 쉬움
##### 단순한 비동기 이벤트 처리
* 각 요청을 별개 스레드에서 처리하면 대기 상태에 들어가도 다른 스레드가 요청을 처리하는 데는 별 영향을 끼치지 않음
##### 더 빨리 반응하는 사용자 인터페이스
* 시간이 오래 걸릴 작업을 별도 스레드에서 실행했다면 이벤트 스레드는 계속 UI 이벤트를 처리할 수 있어 UI가 더 빨리 반응
#### 스레드 사용의 위험성
##### 안전성 위해 요소
* 스레드 안전성은 생각보다 미묘 
* 동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산의 순서가 때론 놀라울 만큼 예측하기가 어렵움
![UnsafeSequence.getNext 메소드가 잘못 동작하는 예](/images/프로그래밍_언어/자바/자바병렬프로그래밍/figure_1-1.png)
##### 활동성 위험
* 단일 스레드 프로그램에서는 나타나지 않는 추가적인 형태의 활동성 liveness 장애가 생길 수 있음
* 스레드에서 실행하는 작업의 상대적인 타이밍에 따라 활동성 문제점이 나타나기 때문에 개발이나 테스트 도중에 잘 드러나지는 않음
##### 성능 위험
* 멀티스레드 프로그램은 단일 스레드 프로그램에서 발생할 수 있는 모든 성능 위험뿐만 아니라, 스레드를 사용하기 때문에 생기는 추가 위험에도 노출
* 스레드가 많은 프로그램에서는 컨텍스트 스위칭 (다른 스레드가 실행될 수 있게 스케줄러가 현재 실행 중인 스레드를 잠시 멈출 때)이 더 빈번하고 그 때문에 상당한부담이 생김
#### 스레드는 어디에나
* 프로그램을 작성할 때 스레드를 직접 생성하지 않더라도 프로그램이 사용하는 프레임웍에서 스레드를 생성할 수도 있음
## 1부 기본 원리
### 2장 스레드 안전성
* 객체의 상태는 인스턴스나 static 변수 같은 상태 변수에 저장된 객체의 데이터
* 공유됐다는 것은 여러 스레드가 특정 변수에 접근할 수 있다는 뜻
* 변경할 수 있다 mutable 는 것은 해당 변수 값이 변경될 수 있다는 뜻
* 스레드 안전성이 마치 코드를 보호하는 것처럼 이해하는 경우가 많지만 실제로는 데이터에 제어 없이 동시 접근하는 걸 막으려는 의미임
* 객체를 스레드에 안전하게 만들려면 동기회를 통해 변경할 수 있는 상태에 접근하는 과정을 조율
* 스레드가 하나 이상 상태 변수에 접근하고 그 중 하나라도 변수에 값을 쓰면, 해당 변수에 접근할 때 관련된 모든 스레드가 동기화를 통해 조율
* 자바에서 동기화를 위한 기본 수단은 synchronized 키워드로서 배타적인 락을 통해 보호 기능을 제공
* volatile 변수 명시적 락 단일 연산 변수 atomic variable 를 사용하는 경우에도 ‘동기화’ 라는 용어를 사용
* 스레드 안전성을 확보하기 위해 나중에 클래스를 고치는 것보다는 애당초 스레드에 안전하게 설계하는 편이 훨씬 쉬움
* 캡슐화나 데이터 은닉 data hiding 같은 기법이 스레드에 안전한 클래스를 작성하는 데도 도움
#### 스레드 안정성이란?
* 정확성이란 클래스가 해당 클래스의 명세에 부합한다는 뜻
* 여러 스레드가 클래스에 접근할 때 계속 정확하게 동작하면 해당 클래스는 스레드 안전
* `여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케쥴하든 어디서 끼워 넣든, 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고 말한다.`
##### 예제: 상태 없는 서블릿
* 선언한 변수가 없고 다른 클래스의 변수를 참조하지도 않음
* 특정 계산을 위한 일시적인 상태는 스레드의 스택에 저장되는 지역 변수에만 저장
* 실행하는 해당 스레드에서만 접근할 수 있음
* `상태 없는 객체는 항상 스레드 안전하다.`
#### 단일 연산

```java
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
    private long count = O;
    public long getCount() { return count; }
    public void service(ServletRequest req, ServletResponse resp) {
        Biginteger i = extractFromRequest(req);
        Biginteger[] factors= factor(i);
        ++count;
        encdeintoResponse(resp, factors);
    }
}
```

* 값을 증가시키는 ++count는 한 줄짜리 간단한 코드인지라 단일 작업처럼 보이지만 실제로는 단일 연산이 아님
##### 경쟁 조건
* 상대적인 시점이나 또는 JVM이 여러 스레드를 교차해서 실행하는 상황에 따라 계산의 정확성이 달라질 때 나타남
* 가장 일반적인 경쟁 조건 형태는 잠재적으로 유효하지 않은 값을 참조해서 다음에 뭘 할지를 결정하는 점검 후 행동 형태의 구문
##### 예졔: 늦은 초기화 시 경쟁 조건
* 늦은 초기화는 특정 객체가 실제 필요할 때까지 초기화를 미루고 동시에 단 한 번만 초기화 되도록 하기 위한 것

```java
@NotThreadSafe
public class LazyinitRace {
    private ExpensiveObject instance = null;
    public ExpensiveObject getinstance() {
        if (instance == null) {
            instance =new ExpensiveObject();
        }
        return instance;
    }
}
```

##### 복합 동작
* 경쟁 조건을 피하려면 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 막을 방법이 있어야 하며, 이런 방법으로 보호해두면 특정 스레드에서 변수를 수정할 때 다른 스레드는 수정 도중이 아닌수정 이전이나 이후에만 
상태를 읽거나 변경을 가할 수 있다.

```java
@ThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
    private final AtomicLong count = new AtomicLong(0);
    public long getCount() { return count.get(); }
    public void service(ServletRequest req, ServletResponse resp) {
        Biginteger i = extractFromRequest(req);
        Biginteger[] factors= factor(i);
        count.incrementAndGet();
        encdeintoResponse(resp, factors);
    }
}
```

#### 락
* 상태를 일관성 있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야 한다.
##### 암묵적인 락
* 단일 연산 특성을 보장하기 위해 synchronized 라는 구문으로 사용할 수 있는 락을 제공
* 자바에서 암묵적 인 락은 뮤텍스 mutexes 또는 mutual exclusion lock(즉 상호 배제 락)로 동작
* 스레드 B가 가지고 있는 락을 스레드 A가 얻으려면 A는 B가 해당 락을 놓을 때까지 기다려야 한다. 만약 B가 락을 놓지 않으면, A는 영원히 기다릴 수밖에 없음

```java
@ThreadSafe
public class SynchronizedFactorizer implements Servlet {
    @GuardedBy("this")
    private BigInteger lastNumber;
    @GuardedBy("this")
    private BigInteger lastFactors;
    
    public synchronized void service(ServletRequest req, ServletResponse resp) {
        Biginteger i = extractFromRequest(req);
        if(i.equals(lastNumber)) {
            encdeintoResponse(resp, factors);
        } else {
        	Biginteger[] factors= factor(i);
        	lastNumber = i;
            lastFactors = factors;
            encdeintoResponse(resp, factors);
        }
    }
}
```

##### 재진입성 (?)
* 재진입 가능 reentrant 하기 때문에 특정 스레드가 자기가 이미 획득한 락을 다시 확보
* 재진입성은 확보 요청 단위가 아닌 스레드 단위로 락을 얻는다는 것을 의미
#### 락으로 상태 보호하기
* 락은 자신이 보호하는 코드 경로에 여러 스레드가 순차적으로 접근하도록 하기 때문에 , 공유된 상태에 배타적으로 접근할 수 있도록 보장하는 규칙을 만들 때 유용
* 객체의 암묵적인 락과그 객체의 상태 사이에 원천적인 관계는 없음
* 특정 객체의 변수를 항상 그 객체의 암묵적인 락으로 보호해야 하는 건 아님
* 특정 객체의 락을 얻는다고 해도 다른 스레드가 해당 객체에 접근하는 걸 막을 순 없음 
* 락을 얻으면 단지 다른 스레드가 동일한 락을 얻지 못하게 할 수 있음
* 모든 객체에 내장된 락이 있다는 점 때문에 매번 별도로 락 객체를 생성할 필요가 없음
* 메소드를 동기화하면 각 메소드의 작업을 단일 연산으로 만들지만, 여러 메소드가 하나의 복합 동작으로 묶일 땐 락을 사용해 추가로 동기화
#### 활동성과 성능
* 종종 단순성과 성능이 서로 상충할 때가 있다. 동기화 정책을 구현할 때는 성능을 위해 조급하게 단순성(잠재적으로 안전성을 훼손하면서)을 희생하고픈 유혹을 버려야 한다.
* 복잡하고 오래 걸리는 계산 작업, 네트웍 작업, 사용자 입출력 작업과 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 한 락을 잡지 말아라.
### 3장 객체 공유
#### 가시성
* `동기화 기능을 지정하지 않으면 컴파일러나 프로세서, JVM(자바 가상 머신) 등이 프로그램 코드가 실행되는 순서를 임의로 바꿔 실행하는 이상한 경우가 발생하기도 한다. 다시 말하자면, 동기화 되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 '반드시 이런 순서로 동작할 것이다'라고 단정지을 수 없다.`
* '여러 쓰레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용한다.'
##### 스테일 데이터
* 변수를 사용하는 모든 경우에 동기화를 시켜두지 않으면 해당 변수에 대한 최신 값이 아닌 다른 값을 사용하게 되는 경우가 발생
##### 단일하지 않는 64비트 연산
* 64비트를 사용하는 숫자형에 volatile 를 사용하지 않은 경우에는 난데없는 값마저 생길 가능성이 있음
* volatile 로 지정되지 않은 long이나 double 형의 64비트 값에 대해서는 메모리에 쓰거나 읽을 때 두번의 32비트 연산을 사용할 수 있도록 허용
##### 락과 가시성
`락은 상호 배제뿐만 아니라 정상적인 메모리 가시성을 확보하기 위해서도 사용한다. 변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상적인 값으로 활용하려면 동일한 락을 사용해 모두 동기화시켜야 한다.`
##### volatile 변수
* volatile 로 선언된 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해줌
* 특정 변수를 선언할 때 volatile 키워드를 지정하면, 컴파일러와 런타임 모두 '이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치 해서는 안 된다.'
* 스레드 A가 volatile 변수에 값을 써넣고 쓰레드 B가 해당 변수의 값을 읽어 사용한다고 할 때, 스레드 B가 volatile 변수의 값을 읽고 나면 스레드 A가 변수에 값을 쓰기 전에 볼 수 있었던 모든 변수의 값을 스레드 B도 모두 볼 수 있다는 점
* 락을 사용하면 가시성과 연산의 단일성을 모두 보장받을 수 있다. 하지만 volatile 변수는 연산의 단일성은 보장하지 못하고 가시성만 보장한다.
* 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재
* 해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어 있지 않다.
* 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없을 경우
#### 공개와 유출
* 클래스 내부의 상태 변수를 외부에 공개해야 한다면 객체 캡슐화 작업이 물거품이 되거나 내부 데이터의 안전성을 해칠 수 있음
* 특정 객체 하나를 공개한다고 해도, 그와 관련된 다른 객체까지 덩달아 공개하게 되는 경우도 있음
* 객체를 공개했을 때 그 객체 내부의 private이 아닌 변수나 메소드를 통해 불러올 수 있는 모든 객체는 함께 공개됨
##### 생성 메소드 안전성
* 생성 메소드를 실행하는 도중에는 this 변수가 외부에 유출되지 않게 해야 한다.
#### 스레드 한정 (?)
* 객체를 사용하는 스레드를 한정하는 방법으로 스레드 안전성을 확볼 할 수 있음
* 객체 인스턴스를 특정 스레드에 한정시켜두면, 해당하는 객체가 [CPJ 2.3.2]가 아니라 해도 자동으로 스레드 안전성을 확보
##### 스레드 한정 - 주먹구구식
* 특정 모듈의 기능을 단일 스레드로 동작하도록 구현한다면, 언어적인 지원 없이 직접 구현한 스레드 한정 기법에서 나타날 수 있는 오류의 가능성을 최소화할 수 있음
* 임시방편적인 스레드 한정 기법은 안전성을 완벽하게 보장할 수 있는 방법은 아니기 때문에 꼭 필요한 곳에만 제한적으로 사용
##### 스택 한정 (?)
* 스택 한정 기법은 특정 객체를 로컬 변수를 통해서만 사용할 수 있는 특별한 경우의 스레드 한정 기법
##### ThreadLocal
* 스레드 내부의 값과 값을 갖고 있는 객체를 연결해 스레드 한정 기법을 적용할 수 있도록 도와주는 좀더 형식적인 방법
* ThreadLocal 클래스에는 get과 set 메소드가 있는데 호출하는 스레드마다 다른 값을 사용할 수 있도록 관리해줌
#### 불변셩
* `불변 객체는 언제라도 스레드에 안전하다.`
* 불변 객체 조건
  * 생성되고 난 이후에는 객체의 상태를 변경할 수 없다.
  * 내부의 모든 변수는 final로 설정 돼야 한다.
  * 적절한 방법으로 생성돼야 한다(예를 들어 this 변수에 대한 참조가 외부로 유출되지 않아야 한다.)
##### final 변수
* `외부에서 반드시 사용할 일이 없는 변수는 private으로 선언하는 게 괜찮은 방법인 만큼, 나중에 변경할 일이 없다고 판단되는 변수는 final로 선언해두는 것도 좋은 방법이다.`
##### 예제: 불변 객체를 공개할 때 volatile 키워드 사용
* 여러 개의 변수를 묶어 사용하고자 할 때, 불변 객체가 아닌 일반 객체를 만들어 사용하면 락을 사용해서 연산의 단일성을 보장 할 수 있다.

```java
@Immutable
class OneValueCache {

    private final Biginteger lastNumber;
    private final Biginteger[] lastFactors;
    
    public OneValueCache(Biginteger i, Biginteger [] factors) {
        lastNumber = i;
        lastFactors = Arrays.copyOf(factors, factors.length) ;
    }
    
    public Biginteger[] getFactors(Biginteger i) {
        if (lastNunber == null || !lastNumber.equals(i)) {
            return null;
        } else {
            return Arrays.copyOf(lastFactors, lastFactors.length);
        }
    }
}
```

```java
@ThreadSafe
public class VolatileCachedFactorizer implements Servlet {
    
    private volatile OneValueCache cache = new OneValueCache (null, null);

    public void service(ServletRequest req, ServletResponse resp) {
        Biginteger i = extractFromRequest(req);
        Biginteger[] factors = cache.getFactors(i);
        if (factors == null) {
            factors= factor(i);
            cache = new OneValueCache(i, factors);
        }
        encodeintoResponse(resp, factors);
    }
}
```

#### 안전 공개
##### 적절하지 않은 공개 방법: 정상적인 객체도 문제를 일으킨다
* 특정 데이터를 여러 개의 스레드에서 사용하도록 공유할 때 적절한 동기화 방법을 적용하지 않는다면 굉장히 이상한 일이 발생할 가능성이 높다는 점을 알아두자
##### 불변 잭체와 초기화 안전성
`불변 객체는 별다른 동기화 방법을 적용하지 않았다 해도 어느 스레드에서건 마음껏 안전하게 사용할 수 있다. 불변 객체를 공개하는 부분에 동기화 처리를 하지 않았다 해도 아무런 문제가 없다.`
##### 안전한 공개 방법의 특성
* 객체를 안전하게 공개하려면 해당 객체에 대한 참조와 객체 내부의 상태를 외부의 스레드 에게 동시에 볼 수 있어야 한다. 올바르게 생성 메소드가 실행되고 난 객체는 다음과 같은 방법으로 안전하게 공개할 수 있다
  * 객체에 대한 참조를 static 메소드에서 초기화시킨다.
  * 객체에 대한 참조를 volatile 변수 또는 AtomicReference 클래스에 보관한다.
  * 객체에 대한 참조를 올바르게 생성된 클래스 내부의 final 변수에 보관한다.
  * 락을 시용해 올바르게 막혀 있는 변수에 객체에 대한 참조를 보관한다.
* 기본으로 제공하는 스레드 안전한 컬렉션은 API
  * HashTable, concurrentMap, synchronizedMap을 사용해 만든 Map 객체를 시용하면 그 안에 보관하고 있는 키와 값 모두를 어느 스레드에서라도 항상 안전하게 사용할수있다. 
  * 객체를 Vector, copyOnWriteArrayList, copyOnWriteArraySet 이나 synchronizedList 또는 synchronizedSet 메소드로 만든 컬렉션은 그 안에 보관하고 있는 객체를 어느 스레드에서라도 항상 안전하게 사용할 수 있다.
  * BlockingQueue나 ConcurrentLinkedQueue 컬렉션에 들어 있는 객체는 어느 스레드라도 항상 안전하게 사용할 수 있다.
##### 결과적으로 불변인 객체
* 처음 생성한 이후에 그 내용이 바뀌지 않도록 만들어진 클래스에 안전한 공개 방법을 사용하면 별다른 동기화 방법 없이도 다른 스레드에서 얼마든지 시용해도 아무런 문제가 발생하지 않음
##### 가변 객체
* 가변성에 따라 객체를 공개할 때 필요한 점을 살펴보면 다음과 같다.
  * 불변 객체는 어떤 방법으로 공개해도 아무 문제가 없다.
  * 결과적으로 불변인 객체는 안전하게 공개해야 한다.
  * 가변 객체는 안전하게 공개해야 하고 스레드에 안전하게 만들거나 락으로 동기화시켜야한다.
##### 객체를 안전하게 공유하기
* 스레드 한정 : 스레드에 한정된 객체는 완전하게 해당 스레드 내부에 존재하면서 그 스레드에서만 호출해 사용할 수 있다.
* 읽기 전용 객체를 공유 : 읽기 전용 객체를 공유해 사용한다면 동기화 작업을 하지 않더라도 여러 스레드에서 언제든지 마음껏 값을 읽어 사용할 수 있다. 물론 읽기 전용이기 때문에 값이 변경될 수는 없다. 불변 객체와 결과적으로 불변인
객체가 읽기 전용 객체에 해당한다고 볼 수 있다.
* 스레드에 안전한 객체를 공유 : 스레드에 안전한 객체는 객체 내부적으로 필수적인 동기화 기능이 만들어져 있기 때문에 외부에서 동기화를 신경 쓸 필요가 없고, 여러 스레드에서 마음껏 호출해 사용할 수 있다.
* 동기화 방법 적용 : 특정 객체에 동기화 방법을 적용해두면 지정한 락을 획득하기 전에는 해당 객체를 사용할 수 없다. 스레드에 안전한 객체 내부에서 사용하는 객체나 공개된 객체 가운데 특정 락을 확보해야 사용할 수 있도록 막혀 있는 객체
등에 동기화 방법이 적용되어 있다고 볼 수 있다.
### 4장 객체 구성
#### 스레드 안전한 클래스 설계
* 클래스가 스레드 안전성을 확보하도록 설계하고자 할 때에는 다음과 같은 세 가지를 고려해야 한다.
  * 객체의 상태를 보관하는 변수가 어떤 것인가?
  * 객체의 상태를 보관하는 변수가 가질 수 있는 값이 어떤 종류, 어떤 범위에 해당하는가?
  * 객체 내부의 값을 동시에 사용하고자 할 때, 그 과정을 관리할 수 있는 정책
* 동기화 정책 : 객체 내부의 여러 변수가 갖고 있는 현재 상태를 사용하고자 할 때 값이 계속해서 변하는 상황에서도 값을 안전하게 사용할 수 있도록 조절하는 방법 

```java
@ThreadSafe
public class Count {
    
    @GuardeBy("this") private long value = 0;

    public synchronized long getValue() {
    	return value;
    }
    
    public synchronized long increment() {
    	if(value == Long.MAX_VALUE)
    		throw new IllegalStateException("count overflow");
    	return ++value;
    }
}
```

##### 동기화 요구사항 정리
* 객체가 가질 수 있는 값의 범위와 변동 폭을 정확하게 인식하지 못한다면, 스러|드 안전성을 완벽하게 확보할 수 없다. 클래스의 상태가 정상적이라는 여러 가지 제약 조건이 있을 때 클래스의 상태를 정상적으로 유지하려면 여러 가지 
추가적인 동기화 기법을 적용하거나 상태 변수를 클래스 내부에 적절히 숨겨야 한다.
##### 상태 의존 연산
* wait와 notify를 사용하는 대신 세마포어나 블로킹 큐와 같이 현재 알려져 있는 여러 가지 라이브러리를 사용하는 편이 훨씬 간단
##### 상태 소유권
* 변수를 통해 객체의 상태를 정의하고자 할 때에는 해당 객체가 실제로 ‘소유하는’ 데이터만을 기준으로 삼음
#### 인스턴스 한정
* 데이터를 객체 내부에 캡슐화해 숨겨두면 숨겨진 내용은 해당 객체의 메소드에서만 사용 할 수 있기 때문에 숨겨진 데이터를 사용하고자 할 때에는 항상 지정된 형태의 락이 적용되는지 쉽고 정확하게 파악할 수 있다.

```java
@ThreadSafe
public class PersonSet {
    
    @GuardeBy("this") 
    private final Set<Person> mySet = new HashSet<Person>();

    public synchronized void addPerson() {
        return mySet.add(p);
    }
    
    public synchronized boolean containsPerson(Person p) {
        return mySet.contaions(p);
    }
}
```

* 인스턴스 한정 기법을 사용하면 프로그램을 다 뒤져보지 않고도 스레드 안전성을 확보하고 있는지 쉽게 분석해 볼 수 있기 때문에 스레드에 안전한 객체를 좀 더 쉽게 구현할 수 있다.
##### 자바 모니터 패턴
* 자바 모니터 패턴 : 객체는 변경가능한 데이터를 모두 객체 내부에 숨긴 다음 객체의 암묵적인 락으로 데이터에 대한 동시 접근을 막는다.
* 락을 객체 외부로 공개했다면 공개된 락을 사용하는 코드가 올바르게 의도한 대로 동작하는지 프로그램 전체를 모두 뒤져봐야 한다.
##### 예제: 차량 위치 추적
* 외부에서 변경 가능한 데이터를 요청할 경우 그에 대한 복사본을 넘겨주는 방법을 사용하면 스레드 안전성을 부분적이나마 확보할 수 있음
#### 스레드 안전성 위임
##### 예제: 위임 기법을 활용한 차량 추척
##### 독립 상태 변수
##### 위임할 때의 문제점
* `클래스가 서로 의존성 없이 독립적이고 스레드 안전한 두 개 이상의 클래스를 조합해 만들어져 있고 두 개 이상의 클래스를 한번에 처리하는 복합 연산 메소드가 없는 상태라면, 스레드 안전성을 내부 변수에게 모두 위임할 수 있음`
##### 내부 상태 변수를 외부에 공개
* `상태 변수가 스레드 안전하고, 클래스 내부에서 상태 변수의 값에 대한 의존성을 갖고 있지 않고 상태 변수에 대한 어떤 연산을 수행하더라도 잘못된 상태에 이를 가능성이 없다면, 해당 변수는 외부에 공개해도 안전`
##### 예제: 차량 추적 프로그램의 상태를 외부에 공개
#### 스레드 안전하게 구현된 클래스에 기능 추가
* 기존 클래스를 상속받아 기능을 추가하는 방법은 기존 클래스에 직접 기능을 추가하는 방법보다 문제가 생길 위험이 훨씬 많음
* 동기화를 맞춰야 할 대상이 두 개 이상의 클래스에 걸쳐 분산되기 때문
* 만약 상위 클래스가 내부적으로 상태 변수의 스레드 안전성을 보장하는 동기화 기법을 약간이라도 수정한다면 그 하위 클래스는 본의 아니게 적절한 락을 필요한 부분에 적용하지 못할 가능성이 높기 때문에 동기화가 깨질 수 있음
#### 동기화 정책 문서화 하기
* 구현한 클래스가 어느 수준까지 스레드 안전성을 보장하는지에 대해 충분히 문서를 작성해둬야 한다. 동기화 기법이나 정책을 잘 정리해두면 유지보수 팀이 원활하게 관리할 수 있다.
* 최소한 클래스가 스레드 안전성에 대해서 어디까지 보장하는지는 문서로 남김
* java.text.SimpleDateFormat 클래스는 스레드 동기화가 되어 있지 않음
##### 애매한 문서 읽어내기
### 5장 구성 단위
#### 동기화된 컬렉션 클래스
![getlast 메소드와 deletelast 메소드가 절묘하게 겹쳐져 동작해 ArraylndexOutOfBoundsExceptionO I 발생하는 모습](/images/프로그래밍_언어/자바/자바병렬프로그래밍/figure_5-1.png)
##### 동기화된 컬렉션 클래스의 문제점
* 반복문이 실행되는 도중에 예외 상황이 발생하는 경우 역시 클라이언트 측 락을 사용하면 예외 상황이 발생하지 않도록 정확하게 동기화시킬 수 있음
* 성능의측면에서 보자면 약간의 손해가 생길 가능성이 있음
##### Iterator와 ConcurrentModificationException
* 소모상태 staπation나 데드락의 위험이 있는 상태에서 컬렉션 클래스를 오랜 시간 동안 락으로 막아두고 있는 상태라면 전체 애플리케이션의 확장성을 해칠 수도 있음
* 반복문에서 락을 오래 잡고 있으면 있을수록 락을 확보하고자 하는 스레드가 대기 상태에 많이 쌓일 수 있고 대기 상태에 스레드가 적체되면 될수록 CPU 사용량이 급격하게 증가할 가능성이 높음
##### 숨겨진 Iterator
* `클래스 내부에서 필요한 변수를 모두 캡슐화하면 그 상태를 보존하기가 훨씬 편리한 것처럼, 동기화 기법을 클래스 내부에 캡슐화하면 동기화 정책을 적용하기가 쉬움`
#### 병렬 컬렉션
* 자바 5.0에는 해시 기반의 HashMap을 대치하면서 병렬성을 확보한 ConcurrentHashMap 클래스가 포함
* `기존에 사용하던 동기화 컬렉션 클래스를 병렬 컬렉션으로 교체하는 것만으로도 별다른 위험 요소 없이 전체적인 성능을 상당히 물어 올랄 수 있다.`
* 자바 5.0은 Queue와 BlockingQueue라는 두 가지 형태의 컬렉션 인터페이스를 추가
* BlockingQueue 클래스는 프로듀서 - 컨슈머 producer-consumer 패턴을 구현
##### ConcurrentHashMap
* ConcurrentHashMap은 락 스트라이핑 (lock striping) 이라 부르는 굉장히 세밀한 동기화 방법을 사용해 여러 스레드에서 공유하는 상태에 훨씬 잘 대응
* 값을 읽어가는 연산은 많은 수의 스레드라도얼마든지 동시에 처리할수있고 읽기 연산과쓰기 연산도동시에 처리할 수 있으며, 쓰기 연산은 제한된 개수만큼 동시에 수행
* 여러 스레드가 동시에 동작하는 환경에서 일반적으로 훨씬 높은 성능 결과를 볼 수 있으며, 이와 함께 단일 스레드 환경에서도 성능상의 단점을 찾아볼 수 없음
* ConcurrentHashMap이 만들어 낸 Iterator는 ConcurrentModificationException을 발생 시 키 지 않는다. 따라서 ConcurrentHashMap의 항목을 대상으로 반복문을 실행하는 경우에는 따로 락을 걸어 동기화해야 할 필요가 없음
* 작업 중인 애플리케이션에서 특정 Map을 완전히 독점해서 사용하는 경우가 있다면, 그 부분에 ConcurrentHashMap을 적용할 때는 충분히 신경을 기울임
##### Map 기반의 또 다른 단일 연산
* ‘없을 경우에만 추가하는 put-if-absent’ 연산
* ‘동일한 경우에만 제거하는 remove-if-equal' 연산 
* ‘동일한 경우에만 대치 하는 replace-if-equal’ 연산

```java
public interface ConcurrentMap<K,V> extends Map<K,V> {
    // key라는커가없는경우에만 value 추가
     V putIfAbsent (K key, V value);
    
    // key라는 키가 value 값을 갖고 있는 경우 제거
    boolean remove (K key, V value);
    
    // key라는 키가 oldValue 값을 갖고 있는 경우 newValue로 치환
    boolean replace(K key, V oldValue, V newValue);
    
    // key라는 키가 들어 있는 경우에만 newValue로 치환
    V replace(K key, V newValue);
}
```

##### CopyOnWriteArrayList
* 클래스는 동기화된 List 클래스보다 병렬성을 훨씬 높이고자 만들어졌다.
* 변경할 때마다 복재 하는 컬렉션 클래스는 불변 객체를 외부에 공개하면 여러 스레드가 동시에 사용하려는 환경에서도 별다른 동기화 작업이 펼요 없다는 개념을 바탕으로 스레드 안전성을 확보
* 컬렉션의 데이터가 변경될 때마다 복사본을 만들어내기 때문에 성능의 측면에서 손해를 볼 수 있고 특히나 컬렉션에 많은 양의 자료가 들어 있다면 손실이 클 수 있다.
* 변경할 때마다 복사하는 컬렉션은 변경 작업보다 반복문으로 읽어내는 일이 훨씬 빈번한 경우에 효과적이다.

#### 블로킹 큐와 프로듀서-컨슈머 패턴
* 블로킹 큐
  * 만약 큐가 가득 차 있다면 put 메소드는 값을 추가할 공간이 생길 때까지 대기
  * 반대로 큐가 비어 있는 상태라면 take 메소드는 뽑아낼 값이 들어올 때까지 대기
* 프로듀서-컨슈머 패턴은 ‘해야 할 일’ 목록을 가운데에 두고 작업을 만들어 내는 주체와 작업을 처리하는 주제를 분리시키는 설계 방법이다.
  * 개발 과정을 좀더 명확하게 단순화
  * 작업을 생성하는 부분과 처리하는 부분이 각각 감당할 수 있는 부하를 조절
* 프로듀서-컨슈머 패턴을 적용해 프로그램을 구현할 때 블로킹 큐를 사용하는 경우가 많음
* 블로킹 큐를 사용 하면 여러 개의 프로듀서와 여러 개의 컨슈머가 작동하는 프로듀서-컨슈머 패턴을 손쉽게 구현할 수 있다.
* 큐와 함께 스레드 풀을 사용하는 경우가 바로 프로듀서-컨슈머 패턴을 활용하는 가장 흔한 경우라고 볼 수 있다.
* `블로킹 큐는 애플리케이선이 안정적으로 동작하도록 만들고자 할 때 요긴하게 시용할 수있는 도구이다. 블로킹 큐를 사용하면 처리할 수 있는 양보다 훨샌 많은 업이 생겨 부하가 걸리는 상勳|서 챔료를 조절해 애플리케이션이 안정적으로 동작하도록 유도할 수 있다.`
* Linked.BlockingQueue
  * FIFO 형태의 큐 
  * LinkedList 대응
* ArrayBlockingQueue
  * FIFO 형태의 큐
  * ArrayList 대응
* PriorityBlockingQueue 
  * 기본 정렬 순서로 정렬
  * Comparator 인터페이스를 사용해 정렬
* SynchronousQueue
  * BlockingQueue 인터페이스를 구현
  * 큐에 항목이 쌓이지 않으며 따라서 큐 내부에 값을 저장할 수 있도록 공간을 할당 하지도 않음
  * 큐에 값을 추가하려는 스레드나 값을 읽어가려는 스레드의 큐를 관리

##### 예제: 데스크탑 검색
* 프로듀서-컨슈머 패턴
  * 멀티스레드를 사용하는 경우에 프로그램의 세부 기능을 쉽게 컴포넌트화 할 수 있다.
  * 성능의 측면에서도 이득을 많이 볼 수 있다.
  
##### 직렬 스레드 한정
* 프로듀서-컨슈머 패턴과 블로킹 큐는 가변 객체 (mutable object) 를 사용할 때 객체의 소유권을 프로듀서에서 컨슈머로 넘기는 과정에서 직렬 스레드 한정 (serial thread confinement) 기법을 사용한다.
* 스레드에 한정된 객체는 특정 스레드 하나만이 소유권을 가질 수 있는데, 객체를 안전한 방법으로 공개하면 객체에 대한 소유권을 이전(transfer) 할 수 있다.
* 객체 풀 (object pool) 은 직렬 스레드 한정 기법을 잘 활용하는 

##### 덱, 작업 가로채기
* 작업 가로채기 work stealing 라는 패턴을 적용할 때에는 텍을 그대로 가져다 사용할 수 있다.
* 프로듀서-컨슈머 패턴에서는 모든 컨슈머가 하나의 큐를 공유해 시용
* 작업 가로채기 패턴에서는 모든 컨슈머가 각자의 텍을 갖는다.

#### 블로킹 메소드, 인터럽터블 메소드
#### 동기화 클래스
#### 효율적이고 확장성 있는 결과 캐시 구현
## 2부 병렬 프로그램 구조 잡기
### 6장 작업 실행
#### 스레드에서 작업 실행
#### Executor 프레임웍
#### 병렬로 처리할 만한 작업
### 7장 중단 및 종료
#### 작업 중단
#### 스레드 기반 서비스 중단
#### 비정상적인 스레드 종료 상황 처리
#### JVM 종료
### 8장 스레드 풀 활용
#### 작업과 실행 정책 간의 보이지 않는 연결 관계
#### 스레드 풀 크기 조절
#### ThreadPoolExecutor 설정
#### ThreadPoolExecutor 상속
#### 재귀 함수 병렬화
### 9장 GUI 애플리케이션
#### GUI는 왜 단일 스레드로 동작하는가?
#### 짧게 실행되는 GUI 작업
#### 장시간 실행되는 GUI 작업
#### 데이터 공유 모델
#### 다른 형태의 단일 스레드 서브시스
## 3부 가용성, 성능, 테스트
### 10장 가용성을 최대로 높이기
#### 데드락
#### 데드락 방지 및 원인 추척
#### 그 밖의 활동성 문제점
### 11장 성능, 확장성
#### 성능에 대해
#### 암달의 법칙
#### 스레드와 비용
#### 락 경쟁 줄이기
#### 예제: Map 객체의 성능 분석
### 12장 병렬 프로그램 테스트
#### 정확성 테스트
#### 성능 테스트
#### 성능 측정의 함정 피하기
#### 보조적인 테스트 방
## 4부 고급 주제
### 13장 명시적인 락
#### Lock과 ReentrantLock
#### 성능에 대한 고려 사항
#### 공정성
#### synchronized 또는 ReentrantLock 선택
#### 읽기-쓰기 락
### 14장 전용 동기화 기능 구현
#### 상태 종속성 관리
#### 조건 큐 활용
#### 명시적인 조건 객체
#### 동기화 클래스의 내부 구조
#### AbstractQueuedSynchronizer
#### java.uitl.concurrent 패키지의 동기화 클래스에서 AQS 활용 모습
### 15장 단일 연산 변수와 넌블로킹 동기화
#### 락의 단점
#### 병렬 연산을 위한 하드웨어적인 지원
#### 단일 연산 변수 클래스
#### 넌블로킹 알고리즘
### 16장 자바 메모리 모델
#### 자바 메모리 모델은 무엇이며, 왜 사용해야 하는가?
#### 안전한 공개
#### 초기화 안전성