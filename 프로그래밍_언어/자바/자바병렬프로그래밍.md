# 자바 병렬 프로그래밍

### 1장 개요
#### 작업을 동시에 실행하는 일에 대한 (아주) 간략한 역사
* 프로세스끼리는 서로 통신을 할 수도 있는데 소켓, 시그널 핸들러, 공 유메모리, 세마포어, 파일등의 비교적 큰단위의 다양한통신수단이 제공
* 운영체제를 개발하게 된 몇 가지 요인
 * 자원 활용 
   * 프로그램은 때로 입출력과 같이 외부 동작이 끝나기를 기다려야 송}는 경우 가 많은데 기다리는 동안은 유용한 일을 처리하지 못함 
   * 하나의 프로그램이 기다리는 동안 다른 프로그램을 실행하도록 지원하는 편이 더 효율적
 * 공정성 
   * 여러 시용자와 프로그램이 컴퓨터 내 자원에 대해 통일한 권한을 가질 수 있음 
   * 한 번에 프로그램 하나를 끝까지 실행해 종료된 이후에야 다른 프로그램을 시작하 는 것보다는 더 작은 단위로 컴퓨터를 공유하는 방법이 바람직
 * 편의성
   * 때론 여러 작업을 전부 처리하는 프로그램 하나를 작성하는 것보다 각기 일을 하나씩 처리하고 필요할 때 프로그램 간에 조율랜 프로그램을 여러 개 작성하는 편이 더 쉽고 바람직
* 자원 활용, 공정성, 편의성 등 프로세스 개념을 만들어내게 된 것과 같은 동기를 갖고 스레드가 고안
* 스레드로 인해 한 프로세스 안에 여러 개의 프로그램 제어흐름이 공존
* 스레드는 메모리 파일 핸들과 같이 프로세스에 할당된 자원을 공유
* 스레드는 각기 별도의 프로그램 카운터, 스택, 지역 변수를 가짐
* 한 프로그램 내 여러 스레드를 동시에 여러 개의 CPU에 할당해 실행시킬 수 있음
* 현대 운영체제의 대부분은 프로세스가 아니라 스레드를 기본 단위로 CPU 자원의 스케줄을 정함
* 스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드는 같은 변수에 접근하고 같은 협 heap에 객체를 할당
* 공유 된 데이터에 접근하는 과정을 적절하게 동기화하지 않으면 다른 스레드가 사용 중인 변수를 순간적으로 수정해서 예상치 못한 결과
#### 스레드의 이점
##### 멀티프로세스 활용
* 제대로 설계하기만 한 다면 멀티스레드 프로그램은 가용한 프로세서 자원을 더 효율적으로 이용해서 처리 속도를 높일 수 있음
* I/O 때문에 대기 상태에 들어가는 동안에도 다른 스레드는 동작할 수 있기 때문에 애플리케이션이 계속 실행
##### 단순한 모델링
* 한 종류 일을 순차적으로 처리하는 프로그램은 작성하 기 쉽고 오류도 별로 생기지 않음
* 여러 종류의 일을 동시에 처리하는 프로그램 보다 태스트하기도 쉬움
##### 단순한 비동기 이벤트 처리
* 각 요청을 별개 스레드에서 처리하면 대기 상태에 들어가도 다른 스레드가 요청을 처리하는 데는 별 영향을 끼치지 않음
##### 더 빨리 반응하는 사용자 인터페이스
* 시간이 오래 걸릴 작업을 별도 스레드에서 실행했다면 이벤트 스레드는 계속 UI 이벤트를 처리할 수 있어 UI가 더 빨리 반응
#### 스레드 사용의 위험성
##### 안전성 위해 요소
* 스레드 안전성은 생각보다 미묘
* 동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산의 순서가 때론 놀라울 만큼 예측하기가 어렵움
![UnsafeSequence.getNext 메소드가 잘못 동작하는 예](/images/프로그래밍_언어/자바/자바병렬프로그래밍/figure_1-1.png)
##### 활동성 위험
* 단일 스레드 프로그램에서는 나타나지 않는 추가적인 형태의 활동성 liveness 장애가 생길 수 있음
* 스레드에서 실행하는 작업의 상대적인 타이밍에 따라 활동성 문제점이 나타나기 때문에 개발이나 테스트 도중에 잘 드러나지는 않음
##### 성능 위험
* 멀티스레드 프로그램은 단일 스레드 프로그램에서 발생할 수 있는 모든 성능 위험뿐만 아니라, 스레드를 사용하기 때문에 생기는 추가 위험에도 노출
* 스레드가 많은 프로그램에서는 컨텍스트 스위칭 (다른 스레드가 실행될 수 있게 스케줄러가 현재 실행 중인 스레드를 잠시 멈출 때)이 더 빈번하고 그 때문에 상당한부담이 생김
#### 스레드는 어디에나
* 프로그램을 작성할 때 스레드를 직접 생성하지 않더라도 프로그램이 사용하는 프레임웍에서 스레드를 생성할 수도 있음
## 1부 기본 원리
### 2장 스레드 안전성
* 스레드에 안전한 코드를 작성하는 것은 근본적으로 상태, 특히 공유되고 변경할 수 있는 상태에 대한 접근을 관리하는 것이다.
* 객체의 상태는 인스턴스나 static 변수 같은 상태 변수에 저장된 객체의 데이터
* 공유됐다는 것은 여러 스레드가 특정 변수에 접근할 수 있다는 뜻
* 객체의 상태에는 밖에서 보이는 동작에 영향을 끼치는 모든 데이터가 포함
* 변경할 수 있다 mutable 는 것은 해당 변수 값이 변경될 수 있다는 뜻
* 스레드 안전성이 마치 코드를 보호하는 것처럼 이해하는 경우가 많지만 실제로는 데이터에 제어 없이 동시 접근하는 걸 막으려는 의미임
* 객체를 스레드에 안전하게 만들려면 동기회를 통해 변경할 수 있는 상태에 접근하는 과정을 조율
* 스레드가 하나 이상 상태 변수에 접근하고 그 중 하나라도 변수에 값을 쓰면, 해당 변수에 접근할 때 관련된 모든 스레드가 동기화를 통해 조율
* 자바에서 동기화를 위한 기본 수단은 synchronized 키워드로서 배타적인 락을 통해 보호 기능을 제공
* volatile 변수 명시적 락 단일 연산 변수 atomic variable 를 사용하는 경우에도 ‘동기화’ 라는 용어를 사용
* 스레드 안전성을 확보하기 위해 나중에 클래스를 고치는 것보다는 애당초 스레드에 안전하게 설계하는 편이 훨씬 쉬움
* 캡슐화나 데이터 은닉 data hiding 같은 기법이 스레드에 안전한 클래스를 작성하는 데도 도움
#### 스레드 안정성이란?
* 정확성이란 클래스가 해당 클래스의 명세에 부합한다는 뜻
* 여러 스레드가 클래스에 접근할 때 계속 정확하게 동작하면 해당 클래스는 스레드 안전
* `여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케쥴하든 어디서 끼워 넣든, 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고 말한다.`
* 객체가 제대로 구현됐으면 어떤 일련의 작업도 해당 객체의 불변조건이나 후조건에 위배될 수 없다.
* `스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화한다.`
##### 예제: 상태 없는 서블릿
* 선언한 변수가 없고 다른 클래스의 변수를 참조하지도 않음
* 특정 계산을 위한 일시적인 상태는 스레드의 스택에 저장되는 지역 변수에만 저장
* 실행하는 해당 스레드에서만 접근할 수 있음
* 상태 없는 객체에 접근하는 스레드가 어떤 일을 하든 다른 스레드가 수행하는 동작의 정확성에 영향을 끼칠 수 없기 때문에 상태 없는 객체는 항상 스레드 안전한다.
* `상태 없는 객체는 항상 스레드 안전하다.`

#### 단일 연산

```java
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
    private long count = O;
    public long getCount() { return count; }
    public void service(ServletRequest req, ServletResponse resp) {
        Biginteger i = extractFromRequest(req);
        Biginteger[] factors= factor(i);
        ++count;
        encdeintoResponse(resp, factors);
    }
}
```

* 값을 증가시키는 ++count는 한 줄짜리 간단한 코드인지라 단일 작업처럼 보이지만 실제로는 단일 연산이 아님
##### 경쟁 조건
* 상대적인 시점이나 또는 JVM이 여러 스레드를 교차해서 실행하는 상황에 따라 계산의 정확성이 달라질 때 나타남
* 가장 일반적인 경쟁 조건 형태는 잠재적으로 유효하지 않은 값을 참조해서 다음에 뭘 할지를 결정하는 점검 후 행동 형태의 구문
##### 예졔: 늦은 초기화 시 경쟁 조건
* 늦은 초기화는 특정 객체가 실제 필요할 때까지 초기화를 미루고 동시에 단 한 번만 초기화 되도록 하기 위한 것

```java
@NotThreadSafe
public class LazyinitRace {
    private ExpensiveObject instance = null;
    public ExpensiveObject getinstance() {
        if (instance == null) {
            instance =new ExpensiveObject();
        }
        return instance;
    }
}
```

##### 복합 동작
* 점검 후 행동과 읽고 수정하고 쓰기 같은 일련의 동작을 복합 동작(compound action)이라고 한다.
* 스레드에 안전하기 위해서는 전체가 단일 연산으로 실행돼야 하는 일련의 동작을 지칭한다.
* 경쟁 조건을 피하려면 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 막을 방법이 있어야 하며, 이런 방법으로 보호해두면 특정 스레드에서 변수를 수정할 때 다른 스레드는 수정 도중이 아닌수정 이전이나 이후에만 상태를 읽거나 변경을 가할 수 있다.
* 상태 없는 클래스에 상태요소를 하나 추가할 때 스레드 안전한 객체 하나로 모든 상태를 관리한다면 해당 클래스는 스레드에 안전하다.

```java
@ThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
    private final AtomicLong count = new AtomicLong(0);
    public long getCount() { return count.get(); }
    public void service(ServletRequest req, ServletResponse resp) {
        Biginteger i = extractFromRequest(req);
        Biginteger[] factors= factor(i);
        count.incrementAndGet();
        encdeintoResponse(resp, factors);
    }
}
```

#### 락
* 상태를 일관성 있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야 한다.
##### 암묵적인 락
* 단일 연산 특성을 보장하기 위해 synchronized 라는 구문으로 사용할 수 있는 락을 제공
* 자바에서 암묵적 인 락은 뮤텍스 mutexes 또는 mutual exclusion lock(즉 상호 배제 락)로 동작
* 스레드 B가 가지고 있는 락을 스레드 A가 얻으려면 A는 B가 해당 락을 놓을 때까지 기다려야 한다. 만약 B가 락을 놓지 않으면, A는 영원히 기다릴 수밖에 없음

```java
@ThreadSafe
public class SynchronizedFactorizer implements Servlet {
    @GuardedBy("this")
    private BigInteger lastNumber;
    @GuardedBy("this")
    private BigInteger lastFactors;
    
    public synchronized void service(ServletRequest req, ServletResponse resp) {
        Biginteger i = extractFromRequest(req);
        if(i.equals(lastNumber)) {
            encdeintoResponse(resp, factors);
        } else {
        	Biginteger[] factors= factor(i);
        	lastNumber = i;
            lastFactors = factors;
            encdeintoResponse(resp, factors);
        }
    }
}
```

##### 재진입성 (?)
* 암묵적인 락은 재진입 가능 reentrant 하기 때문에 특정 스레드가 자기가 이미 획득한 락을 다시 확보할 수 있음
* 재진입성은 확보 요청 단위가 아닌 스레드 단위로 락을 얻는다는 것을 의미
* 재진입성을 구현하려면 각 락마다 확보 횟수와 확보한 스레드를 연결시켜 둠
* 재진입성 때문에 락의 동작을 쉽게 캡슐화할 수 있고 객체 지향 병렬 프로그램을 개발하기가 단순해짐

```java
public class Widget { 
  public synchronized void doSomething() { 
    ....
  }
}

public class LoggingWidget extends Widget { 
  public synchronized void doSomething() {
    System.out.println(toString() + " : calling doSomething");
    super.doSomething();
  }
}
```

#### 락으로 상태 보호하기
* 락은 자신이 보호하는 코드 경로에 여러 스레드가 순차적으로 접근하도록 하기 때문에 , 공유된 상태에 배타적으로 접근할 수 있도록 보장하는 규칙을 만들 때 유용
* 객체의 암묵적인 락과그 객체의 상태 사이에 원천적인 관계는 없음
* 특정 객체의 변수를 항상 그 객체의 암묵적인 락으로 보호해야 하는 건 아님
* 특정 객체의 락을 얻는다고 해도 다른 스레드가 해당 객체에 접근하는 걸 막을 순 없음 
* 락을 얻으면 단지 다른 스레드가 동일한 락을 얻지 못하게 할 수 있음
* 모든 객체에 내장된 락이 있다는 점 때문에 매번 별도로 락 객체를 생성할 필요가 없음
* 메소드를 동기화하면 각 메소드의 작업을 단일 연산으로 만들지만, 여러 메소드가 하나의 복합 동작으로 묶일 땐 락을 사용해 추가로 동기화
#### 활동성과 성능
* 종종 단순성과 성능이 서로 상충할 때가 있다. 동기화 정책을 구현할 때는 성능을 위해 조급하게 단순성(잠재적으로 안전성을 훼손하면서)을 희생하고픈 유혹을 버려야 한다.
* 복잡하고 오래 걸리는 계산 작업, 네트웍 작업, 사용자 입출력 작업과 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 한 락을 잡지 말아라.
### 3장 객체 공유
#### 가시성
* `동기화 기능을 지정하지 않으면 컴파일러나 프로세서, JVM(자바 가상 머신) 등이 프로그램 코드가 실행되는 순서를 임의로 바꿔 실행하는 이상한 경우가 발생하기도 한다. 다시 말하자면, 동기화 되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 '반드시 이런 순서로 동작할 것이다'라고 단정지을 수 없다.`
* '여러 쓰레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용한다.'
##### 스테일 데이터
* 변수를 사용하는 모든 경우에 동기화를 시켜두지 않으면 해당 변수에 대한 최신 값이 아닌 다른 값을 사용하게 되는 경우가 발생
##### 단일하지 않는 64비트 연산
* 64비트를 사용하는 숫자형에 volatile 를 사용하지 않은 경우에는 난데없는 값마저 생길 가능성이 있음
* volatile 로 지정되지 않은 long이나 double 형의 64비트 값에 대해서는 메모리에 쓰거나 읽을 때 두번의 32비트 연산을 사용할 수 있도록 허용
##### 락과 가시성
`락은 상호 배제뿐만 아니라 정상적인 메모리 가시성을 확보하기 위해서도 사용한다. 변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상적인 값으로 활용하려면 동일한 락을 사용해 모두 동기화시켜야 한다.`
##### volatile 변수
* volatile 로 선언된 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해줌
* 특정 변수를 선언할 때 volatile 키워드를 지정하면, 컴파일러와 런타임 모두 '이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치 해서는 안 된다.'
* 스레드 A가 volatile 변수에 값을 써넣고 쓰레드 B가 해당 변수의 값을 읽어 사용한다고 할 때, 스레드 B가 volatile 변수의 값을 읽고 나면 스레드 A가 변수에 값을 쓰기 전에 볼 수 있었던 모든 변수의 값을 스레드 B도 모두 볼 수 있다는 점
* volatile 변수만 사용해 메모리 가시성을 확보하도록 작성한 코드는 synchronized로 직접 동기화한 코드보다 훨씬 읽기가 어렵고, 따라서 오류가 발생할 가능성도 높다.
* 락을 사용하면 가시성과 연산의 단일성을 모두 보장받을 수 있다. 하지만 volatile 변수는 연산의 단일성은 보장하지 못하고 가시성만 보장한다.
* volatile 변수 사용
  * 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재
  * 해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어 있지 않다.
  * 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없을 경우
#### 공개와 유출
* 클래스 내부의 상태 변수를 외부에 공개해야 한다면 객체 캡슐화 작업이 물거품이 되거나 내부 데이터의 안전성을 해칠 수 있음
* 특정 객체 하나를 공개한다고 해도, 그와 관련된 다른 객체까지 덩달아 공개하게 되는 경우도 있음
* 객체를 공개했을 때 그 객체 내부의 private이 아닌 변수나 메소드를 통해 불러올 수 있는 모든 객체는 함께 공개됨
##### 생성 메소드 안전성
* 생성 메소드를 실행하는 도중에는 this 변수가 외부에 유출되지 않게 해야 한다.
#### 스레드 한정 (?)
* 객체를 사용하는 스레드를 한정하는 방법으로 스레드 안전성을 확볼 할 수 있음
* 객체 인스턴스를 특정 스레드에 한정시켜두면, 해당하는 객체가 [CPJ 2.3.2]가 아니라 해도 자동으로 스레드 안전성을 확보
##### 스레드 한정 - 주먹구구식
* 특정 모듈의 기능을 단일 스레드로 동작하도록 구현한다면, 언어적인 지원 없이 직접 구현한 스레드 한정 기법에서 나타날 수 있는 오류의 가능성을 최소화할 수 있음
* 임시방편적인 스레드 한정 기법은 안전성을 완벽하게 보장할 수 있는 방법은 아니기 때문에 꼭 필요한 곳에만 제한적으로 사용
##### 스택 한정 (?)
* 스택 한정 기법은 특정 객체를 로컬 변수를 통해서만 사용할 수 있는 특별한 경우의 스레드 한정 기법
##### ThreadLocal
* 스레드 내부의 값과 값을 갖고 있는 객체를 연결해 스레드 한정 기법을 적용할 수 있도록 도와주는 좀더 형식적인 방법
* ThreadLocal 클래스에는 get과 set 메소드가 있는데 호출하는 스레드마다 다른 값을 사용할 수 있도록 관리해줌
#### 불변성
* `불변 객체는 언제라도 스레드에 안전하다.`
* 불변 객체 조건
  * 생성되고 난 이후에는 객체의 상태를 변경할 수 없다.
  * 내부의 모든 변수는 final로 설정 돼야 한다.
  * 적절한 방법으로 생성돼야 한다(예를 들어 this 변수에 대한 참조가 외부로 유출되지 않아야 한다.)
##### final 변수
* `외부에서 반드시 사용할 일이 없는 변수는 private으로 선언하는 게 괜찮은 방법인 만큼, 나중에 변경할 일이 없다고 판단되는 변수는 final로 선언해두는 것도 좋은 방법이다.`
##### 예제: 불변 객체를 공개할 때 volatile 키워드 사용
* 서로 관련되어 있는 여러 개의 변수 값을 서로 읽거나 쓰는 과정에 경쟁 조건이 발생할 수 있는데, 불변 객체에 해당하는 변수를 모두 모아두면 경재 조건을 방지할 수 있다.
* 여러 개의 변수를 묶어 사용하고자 할 때, 불변 객체가 아닌 일반 객체를 만들어 사용하면 락을 사용해서 연산의 단일성을 보장 할 수 있다.

```java
@Immutable
class OneValueCache {

    private final Biginteger lastNumber;
    private final Biginteger[] lastFactors;
    
    public OneValueCache(Biginteger i, Biginteger [] factors) {
        lastNumber = i;
        lastFactors = Arrays.copyOf(factors, factors.length) ;
    }
    
    public Biginteger[] getFactors(Biginteger i) {
        if (lastNunber == null || !lastNumber.equals(i)) {
            return null;
        } else {
            return Arrays.copyOf(lastFactors, lastFactors.length);
        }
    }
}
```

```java
@ThreadSafe
public class VolatileCachedFactorizer implements Servlet {
    
    private volatile OneValueCache cache = new OneValueCache (null, null);

    public void service(ServletRequest req, ServletResponse resp) {
        Biginteger i = extractFromRequest(req);
        Biginteger[] factors = cache.getFactors(i);
        if (factors == null) {
            factors= factor(i);
            cache = new OneValueCache(i, factors);
        }
        encodeintoResponse(resp, factors);
    }
}
```

#### 안전 공개
##### 적절하지 않은 공개 방법: 정상적인 객체도 문제를 일으킨다
* 특정 데이터를 여러 개의 스레드에서 사용하도록 공유할 때 적절한 동기화 방법을 적용하지 않는다면 굉장히 이상한 일이 발생할 가능성이 높다는 점을 알아두자
##### 3.5.2 불변 객체와 초기화 안전성
* 불변 객체의 요구 조건
  * 상태를 변경할 수 없어야 함
  * 모든 필드의 값이 final로 선언돼야 함
  * 적절한 방법으로 생성
`불변 객체는 별다른 동기화 방법을 적용하지 않았다 해도 어느 스레드에서건 마음껏 안전하게 사용할 수 있다. 불변 객체를 공개하는 부분에 동기화 처리를 하지 않았다 해도 아무런 문제가 없다.`
##### 3.5.3 안전한 공개 방법의 특성
* 객체를 안전하게 공개하려면 해당 객체에 대한 참조와 객체 내부의 상태를 외부의 스레드 에게 동시에 볼 수 있어야 한다. 올바르게 생성 메소드가 실행되고 난 객체는 다음과 같은 방법으로 안전하게 공개할 수 있다
  * 객체에 대한 참조를 static 메소드에서 초기화시킨다.
  * 객체에 대한 참조를 volatile 변수 또는 AtomicReference 클래스에 보관한다.
  * 객체에 대한 참조를 올바르게 생성된 클래스 내부의 final 변수에 보관한다.
  * 락을 시용해 올바르게 막혀 있는 변수에 객체에 대한 참조를 보관한다.
* 기본으로 제공하는 스레드 안전한 컬렉션은 API
  * HashTable, concurrentMap, synchronizedMap을 사용해 만든 Map 객체를 시용하면 그 안에 보관하고 있는 키와 값 모두를 어느 스레드에서라도 항상 안전하게 사용할수있다. 
  * 객체를 Vector, copyOnWriteArrayList, copyOnWriteArraySet 이나 synchronizedList 또는 synchronizedSet 메소드로 만든 컬렉션은 그 안에 보관하고 있는 객체를 어느 스레드에서라도 항상 안전하게 사용할 수 있다.
  * BlockingQueue나 ConcurrentLinkedQueue 컬렉션에 들어 있는 객체는 어느 스레드라도 항상 안전하게 사용할 수 있다.
##### 결과적으로 불변인 객체
* 처음 생성한 이후에 그 내용이 바뀌지 않도록 만들어진 클래스에 안전한 공개 방법을 사용하면 별다른 동기화 방법 없이도 다른 스레드에서 얼마든지 시용해도 아무런 문제가 발생하지 않음
* 특정 객체를 안전한 방법으로 공개했을 경우, 해당 객체에 대한 참조를 갖고 객체를 불러와 사용하는 시점에는 공개하는 시점의 객체 상태를 정확하게 사용할 수 있고, 해당 객체 내부의 값이 바꾸지 않는 한 여러 스레드에서 동시에 값을 가져다 사용해도 동기화 문제가 발생하지 않는다.
`안전하게 공개한 결과적인 불변 객체는 별다른 동기화 작업 없이도 여러 스레드에서 안전하게 호출해 사용할 수 있다.`
##### 가변 객체
* 가변성에 따라 객체를 공개할 때 필요한 점을 살펴보면 다음과 같다.
  * 불변 객체는 어떤 방법으로 공개해도 아무 문제가 없다.
  * 결과적으로 불변인 객체는 안전하게 공개해야 한다.
  * 가변 객체는 안전하게 공개해야 하고 스레드에 안전하게 만들거나 락으로 동기화시켜야한다.
##### 객체를 안전하게 공유하기
* 스레드 한정 : 스레드에 한정된 객체는 완전하게 해당 스레드 내부에 존재하면서 그 스레드에서만 호출해 사용할 수 있다.
* 읽기 전용 객체를 공유 : 읽기 전용 객체를 공유해 사용한다면 동기화 작업을 하지 않더라도 여러 스레드에서 언제든지 마음껏 값을 읽어 사용할 수 있다. 물론 읽기 전용이기 때문에 값이 변경될 수는 없다. 불변 객체와 결과적으로 불변인
객체가 읽기 전용 객체에 해당한다고 볼 수 있다.
* 스레드에 안전한 객체를 공유 : 스레드에 안전한 객체는 객체 내부적으로 필수적인 동기화 기능이 만들어져 있기 때문에 외부에서 동기화를 신경 쓸 필요가 없고, 여러 스레드에서 마음껏 호출해 사용할 수 있다.
* 동기화 방법 적용 : 특정 객체에 동기화 방법을 적용해두면 지정한 락을 획득하기 전에는 해당 객체를 사용할 수 없다. 스레드에 안전한 객체 내부에서 사용하는 객체나 공개된 객체 가운데 특정 락을 확보해야 사용할 수 있도록 막혀 있는 객체
등에 동기화 방법이 적용되어 있다고 볼 수 있다.
### 4장 객체 구성
#### 4.1 스레드 안전한 클래스 설계
* 클래스가 스레드 안전성을 확보하도록 설계하고자 할 때에는 다음과 같은 세 가지를 고려해야 한다.
  * 객체의 상태를 보관하는 변수가 어떤 것인가?
  * 객체의 상태를 보관하는 변수가 가질 수 있는 값이 어떤 종류, 어떤 범위에 해당하는가?
  * 객체 내부의 값을 동시에 사용하고자 할 때, 그 과정을 관리할 수 있는 정책
* 동기화 정책 : 객체 내부의 여러 변수가 갖고 있는 현재 상태를 사용하고자 할 때 값이 계속해서 변하는 상황에서도 값을 안전하게 사용할 수 있도록 조절하는 방법 

```java
@ThreadSafe
public class Count {
    
    @GuardeBy("this") private long value = 0;

    public synchronized long getValue() {
    	return value;
    }
    
    public synchronized long increment() {
    	if(value == Long.MAX_VALUE)
    		throw new IllegalStateException("count overflow");
    	return ++value;
    }
}
```

##### 4.1.1 동기화 요구사항 정리
* 여러 스레드가 동시에 클래스를 사용하려 하는 상황에서 클래스 내부의 값을 안정적인 상태로 유지할 수 있다면 바로 스레드 안전성을 확보했다고 할 수 있다.
* 상태 범위 : 객체와 변수가 가질 수 있는 가능한 값의 범위
* 객체가 가질 수 있는 값의 범위와 변동 폭을 정확하게 인식하지 못한다면, 스레드 안전성을 완벽하게 확보할 수 없다. 클래스의 상태가 정상적이라는 여러 가지 제약 조건이 있을 때 클래스의 상태를 정상적으로 유지하려면 여러 가지 추가적인 동기화 기법을 적용하거나 상태 변수를 클래스 내부에 적절히 숨겨야 한다.
* 여러 개의 변수를 통해 클래스의 상태가 올바른지 아닌지를 정의한다면 연산을 단일 연산으로 구현해야 한다.
##### 4.2.1 상태 의존 연산
* 현재 조건에 따라 동작 여부가 결정되는 연산을 상태 의존 state-dependent 연산이라고 한다.
* wait와 notify를 사용하면 특정 상태가 원하는 조건에 다다를 때까지 효율적으로 기달릴 수 있다.
* wait와 notify를 사용하는 대신 세마포어나 블로킹 큐와 같이 현재 알려져 있는 여러 가지 라이브러리를 사용하는 편이 훨씬 간단
##### 4.1.3 상태 소유권
* 변수를 통해 객체의 상태를 정의하고자 할 때에는 해당 객체가 실제로 ‘소유하는’ 데이터만을 기준으로 삼음
* 클래스는 일반 메소드나 생성 메소드로 넘겨받은 객체에 대한 소유권을 갖지 않는다는 게 일반적인 모양이지만, 넘겨받은 객체의 소유권을 확보하도록 메소드를 특별하게 작성하면 소유권을 확보할 수도 있다.
* 컬렉션 클래스에서는 ‘소유권 분리’ 의 형태를 사용하는 경우도 많다. 소유권 분리는 컬렉션 클래스를 놓고 볼 때 컬렉션 내부의 구조에 대한 소유권은 컬렉션 클래스가 갖고, 컬렉션에 추가되어 있는 객체에 대한 소유권은 컬렉션을 호출해 사용하는 클라이언트 프로그램이 갖는 구조이다.
#### 4.2 인스턴스 한정
* 객체를 적절하게 캡슐화하는 것으로도 스레드 안전성을 확보할 수 있는데, 이런 경우 흔히 '한정'이라고 단순하게 부르기도 하는 '인스턴스 한정' 기법을 활용하는 셈이다.
* `데이터를 객체 내부에 캡슐화해 숨겨두면 숨겨진 내용은 해당 객체의 메소드에서만 사용 할 수 있기 때문에 숨겨진 데이터를 사용하고자 할 때에는 항상 지정된 형태의 락이 적용되는지 쉽고 정확하게 파악할 수 있다.`

```java
@ThreadSafe
public class PersonSet {
    
    @GuardeBy("this") 
    private final Set<Person> mySet = new HashSet<Person>();

    public synchronized void addPerson() {
        return mySet.add(p);
    }
    
    public synchronized boolean containsPerson(Person p) {
        return mySet.contaions(p);
    }
}
```

* `인스턴스 한정 기법을 사용하면 프로그램을 다 뒤져보지 않고도 스레드 안전성을 확보하고 있는지 쉽게 분석해 볼 수 있기 때문에 스레드에 안전한 객체를 좀 더 쉽게 구현할 수 있다.`
##### 4.2.1 자바 모니터 패턴
* 자바 모니터 패턴 : 객체는 변경가능한 데이터를 모두 객체 내부에 숨긴 다음 객체의 암묵적인 락으로 데이터에 대한 동시 접근을 막는다.
* 락을 객체 외부로 공개했다면 공개된 락을 사용하는 코드가 올바르게 의도한 대로 동작하는지 프로그램 전체를 모두 뒤져봐야 한다.

```java
@ThreadSafae
public class PrivateLock {
    private final Object myLock = new Object();
    @GuardedBy("myLock") Widget widget;
    
    void someMethod() {
    	synchronized (myLock) {
    		// widget 변수의 값을 읽거나 변경
    	}
    }
}
```

##### 4.2.2 예제: 차량 위치 추적
* 외부에서 변경 가능한 데이터를 요청할 경우 그에 대한 복사본을 넘겨주는 방법을 사용하면 스레드 안전성을 부분적이나마 확보할 수 있음
#### 4.3 스레드 안전성 위임
* 대부분의 객체가 둘 이상의 객체를 조합해서 사용하는 합성(composite) 객체이다.
* 클래스를 구현할 때 바닥부터 새로 만들거나 이미 만들어져 있지만 스레드 안전성이 없는 객체를 조합해 만들면서 스레드 안전성을 확보하고자 한다면 자바 모니터 패턴을 유용하게 사용할 수 있다.
##### 4.3.1 예제: 위임 기법을 활용한 차량 추척
* 모든 동기화 작업은 concurrentHashMap에서 담당하고, Map에 들어 있는 모든 값은 불변 상태이다.
* 위임 기능을 적용한 버번은 언제든지 가장 최신의 차량 위치를 실시간으로 확인할 수 있는 동적인 데이터를 넘겨준다.
##### 4.3.2 독립 상태 변수
* 독립적이라는 의미는 변수가 서로의 상태 값에 대한 연관성이 없다는 말이다.
##### 4.3.3 위임할 때의 문제점
* `클래스가 서로 의존성 없이 독립적이고 스레드 안전한 두 개 이상의 클래스를 조합해 만들어져 있고 두 개 이상의 클래스를 한번에 처리하는 복합 연산 메소드가 없는 상태라면, 스레드 안전성을 내부 변수에게 모두 위임할 수 있음`
##### 4.3.4 내부 상태 변수를 외부에 공개
* `상태 변수가 스레드 안전하고, 클래스 내부에서 상태 변수의 값에 대한 의존성을 갖고 있지 않고 상태 변수에 대한 어떤 연산을 수행하더라도 잘못된 상태에 이를 가능성이 없다면, 해당 변수는 외부에 공개해도 안전`
##### 4.5.5 예제: 차량 추적 프로그램의 상태를 외부에 공개
```java
@ThreadSafe
public class SafePoint {

    @GuardedBy("this") private int x, y;

    private SafePoint(int[] a) { this(a[O], a[1]);}
    
    public SafePoint(SafePoint p) { this(p.get()); }
    
    public SafePoint (int x, int y) {
        this.set(x, y);
    }

    public synchronized int [] get () {
        return new int[] { x, y };
    }
    public synchronized void set (int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
* 변경 불가능한 클래스 대신 스레드 안전하고 변경 가능한 SafePoint 클래스를 사용
#### 4.4 스레드 안전하게 구현된 클래스에 기능 추가
* 기존 클래스에 직접 추가하는 방법이 가장 안전
* 기존 클래스를 상속받아 기능을 추가하는 방법은 기존 클래스에 직접 기능을 추가하는 방법보다 문제가 생길 위험이 훨씬 많음
* 만약 상위 클래스가 내부적으로 상태 변수의 스레드 안전성을 보장하는 동기화 기법을 약간이라도 수정한다면 그 하위 클래스는 본의 아니게 적절한 락을 필요한 부분에 적용하지 못할 가능성이 높기 때문에 동기화가 깨질 수 있음
##### 4.4.1 호출하는 측의 동기화
* 도우미 클래스를 다로 구현해서 추가 기능을 구현

```java
@ThreadSafe
public class ListHelper<E> {

	public List<E> list = Collections.synchronizedList(new ArrayList<E>());
    
	public boolean putIfAbsent(E x) {
        synchronized (list) {
            boolean absent = !list.contains (x);
        if (absent)
            list.add(x);
        return absent;
        }
    }
}
```

##### 4.4.2 클래스 재구성
* 기존 클래스에 새로운 단일 연산을 추가하고자 할 때 좀더 안전하게 사용할 수 있는 방법이 있는데, 바로 재구성 composition이다.
#### 4.5 동기화 정책 문서화 하기
* 구현한 클래스가 어느 수준까지 스레드 안전성을 보장하는지에 대해 충분히 문서를 작성해둬야 한다. 동기화 기법이나 정책을 잘 정리해두면 유지보수 팀이 원활하게 관리할 수 있다.
* 최소한 클래스가 스레드 안전성에 대해서 어디까지 보장하는지는 문서로 남김
* java.text.SimpleDateFormat 클래스는 스레드 동기화가 되어 있지 않음
##### 4.5.1 애매한 문서 읽어내기
* 자바로 만들어진 여러 가지 기술을 정의하는 스펙을 보면 스레드 안전성에 대한 요구 사항이나 보장 범위에 대한 언급이 별로 없다.
### 5장 구성 단위
#### 5.1 동기화된 컬렉션 클래스
* 동기화되어 있는 컬렉션 클래스의 대표 주자는 바로 Vector와 HashTable이다.
![getlast 메소드와 deletelast 메소드가 절묘하게 겹쳐져 동작해 ArraylndexOutOfBoundsExceptionO I 발생하는 모습](/images/프로그래밍_언어/자바/자바병렬프로그래밍/figure_5-1.png)
##### 5.1.1 동기화된 컬렉션 클래스의 문제점
* 여러 스레드가 해당 컬렉션 하나를 놓고 동시에 그 내용을 변경하려 한다면 컬렉션 클래스가 상식적으로 올바른 방법으로 동작하지 않을 수도 있다.
* 반복문이 실행되는 도중에 예외 상황이 발생하는 경우 역시 클라이언트 측 락을 사용하면 예외 상황이 발생하지 않도록 정확하게 동기화시킬 수 있음
* 성능의측면에서 보자면 약간의 손해가 생길 가능성이 있음
##### 5.1.2 Iterator와 ConcurrentModificationException
* Iterator를 사용해 컬렉션 클래스 내부의 값을 차례로 입어다 사용한다 해도 반복문이 실행되는 동안 다른 스레드가 컬렉션 클래스 내부의 값을 추가하거나 제거하는 등의 변경 작업을 시도할 때 발생할 수 있는 문제를 막아주지는 못한다.
* 동기화된 컬렉션 클래스에서 만들어낸 Iterator를 사용한다 해도 다른 스레드가 같은 시점에 컬렉션 클래스 내부의값을 변경하는 작업을 처리하지는 못하게 만들어져 있고 대신 즉시 멈춤fail-fast의 형태로 반응하도록 되어 있다.
* 즉시 멈춤이란 반복문을 실행하는 도중에 컬렉션 클래스 내부의 값을 변경하는 상황이 포착되면 그 즉시 concurrentModificationException 예외를 발생시키고 멈추는 처리 방법이다.
* 소모상태 starvation나 데드락의 위험이 있는 상태에서 컬렉션 클래스를 오랜 시간 동안 락으로 막아두고 있는 상태라면 전체 애플리케이션의 확장성을 해칠 수도 있음
* 반복문에서 락을 오래 잡고 있으면 있을수록 락을 확보하고자 하는 스레드가 대기 상태에 많이 쌓일 수 있고 대기 상태에 스레드가 적체되면 될수록 CPU 사용량이 급격하게 증가할 가능성이 높음
* 반복문을 실행하는 동안 컬렉션 클래스에 들어 있는 내용에 락을 걸어둔 것과 비슷한 효과를 내려면 clone 메소드로 복사본을 만들어 복사본을 대상으로 반복문을 사용할 수 있다. 
##### 5.1.3 숨겨진 Iterator
* 여기에서 다시 한번상기하고 넘어가야할것이 있다. 개발자는상태 변수와상태 변수의 동기화를 맞춰주는 락이 멀리 떨어져 있을수록 동기회를 맞춰야 한다는 필요성을 잊기 쉽다는 점이다.
* `클래스 내부에서 필요한 변수를 모두 캡슐화하면 그 상태를 보존하기가 훨씬 편리한 것처럼, 동기화 기법을 클래스 내부에 캡슐화하면 동기화 정책을 적용하기가 쉬움`
```java
public class HiddenIterator {
	@GuardedBy ("this")
    private final Set<Integer> set = new HashSet<Integer>();
    
	public synchronized void add(Integer i) { set.add(i); }
    public synchronized void remove(Integer i) { set.remove (i); }
    public void addTenThings() {
        Random r = new Random();
        for (int i = O; i < 10; i++)
        add(r.nextint());
        // AbstractCollection toString 참고
        System.out.println("DEBUG: added ten elements to " + set);
    }
}
```
#### 5.2 병렬 컬렉션
* 자바 5.0에는 해시 기반의 HashMap을 대치하면서 병렬성을 확보한 ConcurrentHashMap 클래스가 포함
* `기존에 사용하던 동기화 컬렉션 클래스를 병렬 컬렉션으로 교체하는 것만으로도 별다른 위험 요소 없이 전체적인 성능을 상당히 물어 올랄 수 있다.`
* 자바 5.0은 Queue와 BlockingQueue라는 두 가지 형태의 컬렉션 인터페이스를 추가
* BlockingQueue 클래스는 프로듀서 - 컨슈머 producer-consumer 패턴을 구현
##### 5.2.1 ConcurrentHashMap
* ConcurrentHashMap은 락 스트라이핑 (lock striping) 이라 부르는 굉장히 세밀한 동기화 방법을 사용해 여러 스레드에서 공유하는 상태에 훨씬 잘 대응
* 값을 읽어가는 연산은 많은 수의 스레드라도얼마든지 동시에 처리할수있고 읽기 연산과쓰기 연산도동시에 처리할 수 있으며, 쓰기 연산은 제한된 개수만큼 동시에 수행
* 여러 스레드가 동시에 동작하는 환경에서 일반적으로 훨씬 높은 성능 결과를 볼 수 있으며, 이와 함께 단일 스레드 환경에서도 성능상의 단점을 찾아볼 수 없음
* ConcurrentHashMap이 만들어 낸 Iterator는 ConcurrentModificationException을 발생 시 키 지 않는다. 따라서 ConcurrentHashMap의 항목을 대상으로 반복문을 실행하는 경우에는 따로 락을 걸어 동기화해야 할 필요가 없음
* 작업 중인 애플리케이션에서 특정 Map을 완전히 독점해서 사용하는 경우가 있다면, 그 부분에 ConcurrentHashMap을 적용할 때는 충분히 신경을 기울임
##### 5.2.2 Map 기반의 또 다른 단일 연산
* ‘없을 경우에만 추가하는 put-if-absent’ 연산
* ‘동일한 경우에만 제거하는 remove-if-equal' 연산 
* ‘동일한 경우에만 대치 하는 replace-if-equal’ 연산

```java
public interface ConcurrentMap<K,V> extends Map<K,V> {
    // key라는커가없는경우에만 value 추가
     V putIfAbsent (K key, V value);
    
    // key라는 키가 value 값을 갖고 있는 경우 제거
    boolean remove (K key, V value);
    
    // key라는 키가 oldValue 값을 갖고 있는 경우 newValue로 치환
    boolean replace(K key, V oldValue, V newValue);
    
    // key라는 키가 들어 있는 경우에만 newValue로 치환
    V replace(K key, V newValue);
}
```

##### 5.2.3 CopyOnWriteArrayList
* 클래스는 동기화된 List 클래스보다 병렬성을 훨씬 높이고자 만들어졌다.
* 변경할 때마다 복재 하는 컬렉션 클래스는 불변 객체를 외부에 공개하면 여러 스레드가 동시에 사용하려는 환경에서도 별다른 동기화 작업이 펼요 없다는 개념을 바탕으로 스레드 안전성을 확보
* 컬렉션의 데이터가 변경될 때마다 복사본을 만들어내기 때문에 성능의 측면에서 손해를 볼 수 있고 특히나 컬렉션에 많은 양의 자료가 들어 있다면 손실이 클 수 있다.
* 변경할 때마다 복사하는 컬렉션은 변경 작업보다 반복문으로 읽어내는 일이 훨씬 빈번한 경우에 효과적이다.

#### 5.3 블로킹 큐와 프로듀서-컨슈머 패턴
* 블로킹 큐
  * 만약 큐가 가득 차 있다면 put 메소드는 값을 추가할 공간이 생길 때까지 대기
  * 반대로 큐가 비어 있는 상태라면 take 메소드는 뽑아낼 값이 들어올 때까지 대기
* 프로듀서-컨슈머 패턴은 ‘해야 할 일’ 목록을 가운데에 두고 작업을 만들어 내는 주체와 작업을 처리하는 주제를 분리시키는 설계 방법이다.
  * 개발 과정을 좀더 명확하게 단순화
  * 작업을 생성하는 부분과 처리하는 부분이 각각 감당할 수 있는 부하를 조절
* 프로듀서-컨슈머 패턴을 적용해 프로그램을 구현할 때 블로킹 큐를 사용하는 경우가 많음
* 블로킹 큐를 사용 하면 여러 개의 프로듀서와 여러 개의 컨슈머가 작동하는 프로듀서-컨슈머 패턴을 손쉽게 구현할 수 있다.
* 큐와 함께 스레드 풀을 사용하는 경우가 바로 프로듀서-컨슈머 패턴을 활용하는 가장 흔한 경우라고 볼 수 있다.
* `블로킹 큐는 애플리케이선이 안정적으로 동작하도록 만들고자 할 때 요긴하게 시용할 수있는 도구이다. 블로킹 큐를 사용하면 처리할 수 있는 양보다 훨샌 많은 업이 생겨 부하가 걸리는 상勳|서 챔료를 조절해 애플리케이션이 안정적으로 동작하도록 유도할 수 있다.`
* Linked.BlockingQueue
  * FIFO 형태의 큐 
  * LinkedList 대응
* ArrayBlockingQueue
  * FIFO 형태의 큐
  * ArrayList 대응
* PriorityBlockingQueue 
  * 기본 정렬 순서로 정렬
  * Comparator 인터페이스를 사용해 정렬
* SynchronousQueue
  * BlockingQueue 인터페이스를 구현
  * 큐에 항목이 쌓이지 않으며 따라서 큐 내부에 값을 저장할 수 있도록 공간을 할당 하지도 않음
  * 큐에 값을 추가하려는 스레드나 값을 읽어가려는 스레드의 큐를 관리

##### 5.3.1 예제: 데스크탑 검색
* 프로듀서-컨슈머 패턴
  * 멀티스레드를 사용하는 경우에 프로그램의 세부 기능을 쉽게 컴포넌트화 할 수 있다.
  * 성능의 측면에서도 이득을 많이 볼 수 있다.
  
##### 5.3.2 직렬 스레드 한정
* 프로듀서-컨슈머 패턴과 블로킹 큐는 가변 객체 (mutable object) 를 사용할 때 객체의 소유권을 프로듀서에서 컨슈머로 넘기는 과정에서 직렬 스레드 한정 (serial thread confinement) 기법을 사용한다.
* 스레드에 한정된 객체는 특정 스레드 하나만이 소유권을 가질 수 있는데, 객체를 안전한 방법으로 공개하면 객체에 대한 소유권을 이전(transfer) 할 수 있다.
* 객체 풀 (object pool) 은 직렬 스레드 한정 기법을 잘 활용하는 

##### 5.3.3 덱, 작업 가로채기
* 프로듀서-컨슈머 패턴에서 블로킹 큐의 기능을 그대로 가져다 사용하는 것 처럼 작업 가로채기 work stealing라는 패턴을 적용할 때에는 텍을 그대로 가져다 사용할 수 있다.
* 작업 가로채기 패턴은 또한 컨슈머가 프로듀서의 역할도 갖고 있는 경우에 적용하기에 좋은데, 이를테면 하나의 작업을 처리하고 나면 더 많은 작업이 생길 수 있는 상황을 생각해 볼 수 있다.

#### 5.4 블로킹 메소드, 인터럽터블 메소드
* 스레드 블록 원인 
  * I/0 작업이 끝나기를 기다리는 경우
  * 락을 확보하기 위해 기다리는 경우
  * Thread.sleep 메소드가 끝나기를 기다리는 경우
  * 다른 스레드가 작업 중인 내용의 결과를 확인하기 위해 기다리는 경우
* 스레드가 블록되면 동작이 멈춰진 다음 블록된 상태 (BLOCKED, WAITING, TIMED_WAITING) 가운데 하나를 갖게 된다.
* 블로킹 연산은 단순히 실행 시간이 오래 걸리는 일반 연산과는 달리 멈춘 상태에서 특정한 신호(예를 들어 VO 작업이 끝나기를 기다리거나 기다리던 락을 확보했거나. 다른 스레드의 작엽 결과를 받아오는 등의 신호)를 받아야 계속해서 실행할 수 있는 연산을 말한다.
* 인터럽트는 스레드가 서로 협력해서 실행하기 위한 방법이다.
* 어떤 스레드라도 다른 스레드가 하고 있는 일을 중간에 강제로 멈추라고 할 수는 없다.
#### 5.5 동기화 클래스
* 상태 정보를 사용해 스레드 간의 작업 흐름을 조절할 수 있도록 만들어진 모든 클래스를 동기화 클래스 synchronizer라고 한다.
* 동기화 클래스의 예로는 세마포어 semaphore, 배리어 barrier, 래치 latch 등이 있다.
##### 5.5.1 래치
* 래치는 스스로가 터미널 terminal 상태에 이를 때까지의 스레드가 동작하는 과정을 늦출 수 있도록 해주는 동기화 클래스이다.
* 래치가 터미널 상태에 이르기 전에는 관문이 닫혀 있다고 볼 수 있으며 어떤 스레드도 통과할 수 없다. 그리고 래치가 터미널 상태에 다다르면 관문이 열리고 모든 스레드가 통과한다.
* 래치가 한 번 터미널 상태에 다다르면 그 상태를 다시 이전으로 되돌릴 수는 없으며 따라서 한 번 열린 관문은 계속해서 열린 상태로 유지된다.
##### 5.5.2 FutureTask
* FutureTask 역시 래치와 비슷한 형태로 동작한다.
* FutureTask가 나타내는 연산 작업은 Callable 인터페이스(Runnable 인터페이스와 유사한 역할을 하지만 작업의 결과값을알려줄수있다)를구현하도록되어 있는데, 시작전 대기, 시작됨, 종료됨과 같은 세 가지 상태를 가질 수 있다.
* 종료된 상태는 정상적인 종료, 취소, 예외 상황 발생과 같이 연산이 끝나는 모든 종류의 상태를 의미한다.
* FutureTask가 한 번 종료 됨 상태에 이르고 나면 더 이상 상태가 바뀌는 일은 없다.
* FutureTask는 Executor 프레임원에서 비동기적인 작업을 실행하고자 할 때 사용하며, 기타 시간이 많이 필요한 모든 작업이 있을 때 실제 결과가 필요한 시점 이전에 미리 작업을 실행시켜두는 용도로 사용한다.
##### 5.5.3 세마포어
* 카운팅 세마포어 counting semaphore는 특정 자원이나 특정 연산을 동시에 사용하거나 호출할 수 있는스레드의 수를 제한하고자 할 때 사용한다.
* 자원 풀 pool 이나 컬렉션의 크기에 제한을 두고자 할 때 유용
##### 5.5.4 배리어
* 배리어 barrier는 특정 이벤트가 발생할 때까지 여러 개의 스레드를 대기 상태로 잡아둘 수 있다는 측면에서 래치와 비슷하다고 볼 수 있다. 
* 래치와의 차이점은 모든 스레드가 배리어 위치에 동시에 이르러야 관문이 열리고 계속해서 실행할 수 있다는 점이 다르다.
* CyclicBarrier 클래스를 사용
  * 여러 스레드가 특정한 배리어 포인트에서 반복적으로 서로 만나는 기능을 모델링
  * 커다란 문제 하나를 여러 개의 작은 부분 문제로 분리해 반복적으로 병렬 처리하는 알고리즘을 구현하고자 할 때 적용하기 좋다.
* 배리어는 대부분 실제 작업은 모두 여러 스레드에서 병렬로 처리하고, 다음 단계로 넘어가기 전에 이번 단계에서 계산해야 할 내용을 모두 취합해야 동}는 등의 작업이 많이 일어나는 시율레이션 알고리즘에서 유용하게 사용할 수 있다.
* Exchanger 클래스
  * 두 개의스레드가 연결되는 배리어이며 배리어 포인트에 도달하면 양쪽의 스레드가 서로 갖고 있던 값을 교환
  * 양쪽 스레드가 서로 대칭되 는작업을수행할때 유용
#### 5.6 효율적이고 확장성 있는 결과 캐시 구현
* 이전에 처리했던 작업의 결과를 재사용할 수 있다면 메모리를 조금 더 사용하기는 하지만 대기 시간을크게 줄이면서 처리 용량을늘릴 수 있다.
캐시를 대충 만들면 단일 스레드로 처리할 때 성능이 높아질 수는 있겠지만 나중에는 성능의 병목 현상을 확장성의 병목으로 바꾸는 결과를 얻을 수 있다.
## 2부 병렬 프로그램 구조 잡기
### 6장 작업 실행
 * 작업이란 추상적이면서 명확하게 구분된 업무의 단위
#### 6.1 스레드에서 작업 실행
* 프로그램에서 일어나는 일을 작업이라는 단위로 재구성하고자 한다면 가장 먼저 해야 할 일은 작업의 범위를 어디까지로 할 것인지 정하는 일이다.
* 다른 작업의 상태, 결과, 부수 효과 등에 영향을 받지 않아야 한다.
* 이런 독립성이 갖춰져 있어야 병렬성을 보장할 수 있는데, 독립적인 작업이라야 적절한 자원이 확보된 상태에서 병렬로 실행될 수 있다.
##### 6.1.1 작업을 순차적으로 실행
* 단일 스레드에서 I/O 작업을 하는 동안 CPU가 대기하고 있어야 하는 등 서버 하드웨어 자원을 제대로 활용하지 못한다는 문제도 있다.
##### 6.1.2 작업마다 스레드를 직접 생성
* 작업을 처리하는 기능이 메인 스레드에서 떨어져 나온다.
* 동시에 여러 작업을 병렬로 처리할 수 있기 때문에 두 개 이상의 요청을 받아 동시에 처리할 수 있다.
* 실제 작업을 처리히는 스레드의 프로그램은 여러 클라이언트가 접속하는 경우 동시에 동작할 가능성이 매우 높기 때문에 스레드 안전성을 확보해야 한다.
##### 6.1.3 스레드를 많이 생성할 때의 문제점
* 스레드 라이프 사이클 문제: 스레드를 생성하고 제거하는 작업에도 자원이 소모된다.
* 자원 낭비: 실행 중인 스레드는 시스댐의 자원 특히 메모리를 소모한다.
* 모든 시스랩에는 생성할 수 있는 스레드의 개수가 제한되어 있다.
#### 6.2 Executor 프레임웍
* 작업 task은 논리적인 업무의 단위이며 스레드는 특정 작업을 비동기적으로 동작시킬 수 있는 방법을 제공한다.
* 스레드 풀 thread pool은 스레드를 관리하는 측면에서 이와 같은 통제력을 갖출 수 있도록 해주며, java.util.concurrent 패키지에 보면 Executor 프레임원의 일부분으로 유연하게 사용할 수 있는 스레드 풀이 만들어져 있다.
* Executor는 작업 등록task submission과 작업 실행 task execution 을 분리하는 표준적인 방법이며 각 작업은 Runnable의 형태로 정의한다.
* Executor의 구조는 프로듀서-컨슈머 패턴에 기반하고 있으며, 작업을 생성해 등록하는 클래스가 프로듀서 (처리해야 할 작업을 생성하는 주체) 가 되고 작업을 실제로 실행하는 스레드가 컨슈머 (생성된 작업을 처리히는 주체) 가 되는 모양을 갖추고 있다.
##### 6.2.1 예제 : Executor를 사용한 웹서버
* 스레드를 직접 생성하도록 구현되어 있는 상태에서는 서버의 동작 특성을 쉽게 변경할 수 없었지만 Executor를 사용하면 Executor의 설정을 변경하는 것만으로 쉽게 변경된다.

```java
class TaskExecutionWebServer {
    private static final int NTHREADS = 100;
    private static final Executor exec = Ececutors.newFixedThreadPool(NTHREADS);

    public static void main (String [] args) throws IOException {
        Serversocket socket = new Serversocket(80);
        while (true) {
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                public void run () {
                    handleRequest(connection);
                    exec.execute(task);
                }
            }; 
        } 
    }
}
```
##### 6.2.2 실행 정책
* 작업을 등록하는 부분과 실행하는 부분을 서로 분리시켜두면 특정 작업을 실행하고자 할 때 코드를 많이 변경하거나 기타 여러 가지 어려운 상황에 맞닥뜨리지 않으면서도 실행 정책 execution p이icy을 언제든지 쉽게 변경할 수 있다는 장점이 있다.
##### 6.2.3 스레드 풀
* 풀 내부의 스레드를 사용해 작업을 실행 장점
  * 매번 스레드를 생성하는 대신 이전에 사용했던 스레드를 재사용하기 때문에 스레드를 계속해서 생성할 필요가 없음
  * 여러 개의 요청을 처리하는 데 필요한 시스템 자원이 줄어드는 효과
  * 클라이언트가 요청을보냈을때 해당 요청을 처리 할 스레드가 이미 만들어진 상태로 대기하고 있기 때문에 작업을 실행하는 데 딜레이가 발생하지 않음
  * 전체적인 반응 속도도 향상
  * 스레드 풀의 크기를 적절히 조절해두면 하드웨어 프로세서가 쉬지 않고 동작
  * 하드웨어 프로세서가 바쁘게 동작하는 와중에도 메모리를 전부 소모하거나 여러 스레드가 한정된 자원을 두고 서로 경쟁하느라 성능을 까먹는 현상도 없음
#### 6.3 병렬로 처리할 만한 작업
* Executor 프레임원을 보면 실행 정책은 쉽게 지정할 수 있도록 되어 있지만,Executor를 사용하려면 실행하려는 작업을 항상 Runnable 인터페이스에 맞춰 구현해야만 한다.
##### 6.3.1 예제: 순차적 페이지 렌더링
* 여기에서 처리해야 할 큰 작업 (HTML 페이지 렌더링)을 작은 단위의 작업으로 쪼개서 동시에 실행할 수 있도록 한다면 CPU도 훨씬 잘 활용할 수 있고 처리 속도와 응답 속도 역시 많이 개선할 수 있겠다.
##### 6.3.2 결과가 나올 때까지 대기 : Callable과 Future
* Callable 인터페이스에서는 핵심 메소드인 call을 실행하고 나면 결과 값을 돌려받을 수 있으며 Exception도 발생시킬 수 있도록 되어 있다.
* Future는 특정 작업이 정상적으로 완료됐는지 아니면 취소됐는지 등에 대한 정보를 확인할 수 있도록 만들어진 클래스이다.
##### 6.3.3 예제: Future를 사용해 페이지 렌더링
* 작업의 진행 상태에 따라 다르게 동작하는 get 메소드의 특정을 설명하긴 했지만, 그렇다고 해서 작업 결과를 기다리는 코드가 작업 진행 상태를 반드시 알아야 할 필요는 없다.
##### 6.3.4 다양한 형태의 작업을 병렬로 처리하는 경우의 단점
* 다양한 종류의 작업을 여러 작업 스레드에서 나눠 처리하도록 할 때는 나눠진 작업이 일정한 크기를 유지하지 못할 수 있다는 단점도 있다.
* 여러 종류의 작업을 병렬로 처리해 병렬성을 높이고자 노력하는 것은 상당한 양의 업무 부하가 될 수 있지만 그 업무의 결과로 얻을 수 있는 이득에는 한계가 있음을 알아야 한다.
##### 6.3.5 CompletionService: Executor와 BlockingQueue의 연합
* completionService
  * Executor의 기능과 BlockingQueue의 기능을 하나로 모은 인터페이스 
  * 필요한 Callable 작업을 등록해 실행
  * take나 poll과 같은 큐 메소드를 사용해 작업이 완료되는 순간 완료된 작업의 Future 인스턴스를 받아올 수 있음
##### 6.3.7 작업 실행 시간 제한
* 지정된 시간이 지나면 더 이상 기다려 줄 수 없다는 점
* 제한된 시간을 넘었을 때 해당 작업을 실제로 멈추도록 해서 더 이상 시스템의 자원을 소모하지 않도록 해야 한다는 점
##### 6.3.8 예제: 여행 예약 포털
* 작업 시간 제한 방법은 작업 개수가 몇 개가 되더라도 얼마든지 적용할 수 있도록 쉽게 일반화할 수 있다.
### 7장 중단 및 종료
* 자바에는 스레드가 작업을 실행하고 있을 때 강제로 멈추도록 하는 방법이 없다.
* 인터럽트 interrupt라는 방법을 사용할 수 있게 되어 있는데, 인터럽트는 특정 스레드에게 작업을 멈춰 달라고 요청하는 형태이다.
* 작업이나 서비스를 실행하는 부분의 코드를 작성할 때 멈춰달라는 요청을 받으면 진행 중이던 작업을 모두 정리한 다음 종료하도록 만들어야 한다.
#### 7.1 작업 중단
##### 7.1.1 인터럽트
* 특정 스레드의 interrupt 메소드를 호출한다 해도 해당 스러|드가 처리하던 작업을 멈추지는 않는다. 단지 해당 스레드에게 인터럽트 요청이 있었다는 메시지를 전달할 뿐이다.
* 작업 취소 기능을 구현하고자 할 때는 인터럽트가 가장 적절한 방법이라고 볼 수 있다.
##### 7.1.2 인터럽트 정책
* 인터럽트 처리 정책은 인터럽트 요청이 들어 왔을 때, 해당 스레드가 인터럽트를 어떻게 처리해야 하는지에 대한 지침이다.
##### 7.1.3 인터럽트에 대한 대응
* 발생한 예외를 호출 스택의 상위 메소드로 전달한다.
* 호출 스택의 상단에 위치한 메소드가 직접 처리할 수 있도록 인터럽트 상태를 유지한다.
* 인터럽트 상태를 유지할 수 있는 가장 일반적 인 방법은 interrupt 메소드를 다시 한 변 호출하는 것이다. 반대로 catch 블록에서 InterruptedException을 잡아낸 다음 아무런 행동을 취하지 않고 말 그대로 예외를 먹어버리는 일은 하지 말아야 한다.
* 인터럽트 상태를 얼마만에 한 번씩 확인할 것인지 주기를 결정할 때에는 응답 속도와 효율성 측면에서 적절한 타협점을 찾아야 한다.
##### 7.1.4 예제: 시간 지정 실행
```java
public class TimedRun1 {
    private static final ScheduledExecutorService cancelExec = Executors.newScheduledThreadPool(1);

    public static void timedRun(Runnable r, long timeout, TimeUnit unit) {
        final Thread taskThread = Thread.currentThread();
        cancelExec.schedule(new Runnable() {public void run() {taskThread.interrupt();}}, timeout, unit);
        r.run();
    }
}
```
* 스레드에 인터럽트를 걸 때 대상 스레드의 인터럽트 정책을 알고 있어야 한다
##### 7.1.5 Future를 사용해 작업 중단
* ExecutorService.submit 메소드를 실행하면 등록한 작업을 나타내는 Future 인스턴스를 리턴받는다.
* Future에는 cancel 메소드가 있는데 mayInterruptIfRunning 이라는 불린 값을 하나 넘겨 받으며 취소 요청에 따른 작업 중단 시도가 성공적이었는지를 알려주는 결과 값을 리턴받을 수 있다.
```java
public class TimedRun {
    private static final ExecutorService taskExec = Executors.newCachedThreadPool();

    public static void timedRun(Runnable r, long timeout, TimeUnit unit) throws InterruptedException {
        Future<?> task = taskExec.submit(r);
        try {
            task.get(timeout, unit);
        } catch (TimeoutException e) {
            // task will be cancelled below
        } catch (ExecutionException e) {
            // exception thrown in task; rethrow
            throw launderThrowable(e.getCause());
        } finally {
            // Harmless if task already completed
            task.cancel(true); // interrupt if running
        }
    }
}
```
##### 7.1.6 인터럽트에 응답하지 않는 블로킹 작업 다루기
* 자바 라이브러리에 포함된 여러 블로킹 메소드는 대부분 인터럽트가 발생하는 즉시 멈추면서 InterruptedException을 띄움
* 작업 중단 요청에 적절하게 대응하는 작업을 쉽게 구현할 수 있음
* 모든 블로킹 메소드가 인터럽트에 대응하도록 되어 있지는 않다.
##### 7.1.7 newTaskFor 메소드로 비표준적인 중단 방법 처리
* 표준을 따르지 않는 중단 방법을 표준의 범주 내에서 시용할 수 있도록 ReaderThread 에서 시용했던 기법은 자바 6 버전의 ThreadPoolExecutor 클래스에 newTaskFork라는 메소드로 정리해 추가됐다.
* newTaskFork 메소드 역시 등록된 작업을 나타내는 Future 객체를 리턴해주는데, 이전과는 다른 RunnableFuture 객체를 리턴한다.
#### 7.2 스레드 기반 서비스 중단
* 애플리케이션은 스레드 기반 서비스를 생성해 사용하며 스레드 기반 서비스는 필요한 개별 스레드를 생성해 사용하지만 애플리케이션은 개별 스레드를 직접 소유하고 있지 않기 때문에 개별 스레드를 직접 조작하는 일이 없어야 한다.
* 애플리케이션이 개별 스레드에 직접 액세스하는 대신 스레드 기반 서비스가 스레드의 시작부터 종료까지 모든 기능에 해당하는 메소드를 직접 제공해야 한다.
##### 7.2.1 예제: 로그 서비스
* 프로듀서컨슈머패턴으로 구현된 프로그램을 중단시키려면 프로듀서와 컨슈머 모두 중단시켜야 한다.
##### 7.2.2 ExecutorService 종료
* shutdownNow를 사용해 강제로 종료시키고 나면 먼저 실행 중인 모든 작업을 중단하도록 한 다음 아직 시작하지 않은 작업의 목록을 그 결과로 리턴
* 강제로 종료하는 방법은 응답이 훨씬 빠르지만 실행 도중에 스레드에 인터럽트를 걸어야 하기 때문에 작업이 중단되는 과정에서 여러 가지 문제가 발생할 가능성이 있음
* 안전하게 종료하는 방법은 종료 속도가 느리지만 큐에 등록된 모든 작업을 처리 할 때까지 스레드를 종료시키지 않고 놔두기 때문에 작업을 잃을 가능성이 없어 안전
##### 7.2.3 독약
* 특정 객체를 큐에 쌓도록 되어 있으며, 이 객체는 “이 객체를 받았다면 종료해야 한다”는 의미
* FIFO 유형의 큐를 사용하는 경우에는 독약 객체를 사용했을 때 컨슈머가 쌓여 있던 모든 작업을 종료하고 독약 객체를 만나 종료되도록 할 수 있다.
* 독약 객체는 프로듀서의 개수와 컨슈머의 개수를 정확히 알고 있을 때에만 사용할 수 있다.
##### 7.2.4 예제: 단번에 실행하는 서비스
* 일련의 작업을 순서대로 처리해야 하며 작업이 모두 끝나기 전에는 리턴되지 않는 메소드를 생각해보자. 이런 메소드는 내부에서만 사용할 Executor 인스턴스를 하나 확보할 수 있다면 서비스의 시작과 종료를 쉽게 관리할 수 있다.
##### 7.2.5 shutdownNow 메소드의 약점
* shutdownNow 메소드를 사용해 ExecutorService를 강제로 종료시커는 경우에는 현재 실행 중인 모든 스레드의 작업을 중단시키도록 시도하고 등록됐지만 실행은 되지 않았던 모든 작업의 목록을 리턴해준다.
* 실행되기 시작은 했지만 아직 완료되지 않은 작업이 어떤 것인지를 알아볼 수 있는 방법은 없다.
#### 7.3 비정상적인 스레드 종료 상황 처리
* 작업 처리 스레드는 실행할 작업을 try-catch 구문 내부에서 실행해 예상치 못한 예외 상황에 대응할 수 있도록 준비
* try finally 구문을 사용해 스레드가 피치 못할 사정으로 종료되는 경우에도 외부에 종료 된다는 사실을 알려 프로그램의 다른 부분에서라도 대응할 수 있도록 함
##### 7.3.1 정의되지 않은 예외 처리
* 스레드 API를 보면 UncaughtExceptionHandler라는 기능을 제공하는데, 이 기능을 사용하면 처리하지 못한 예외 상황으로 인해 특정 스레드가 종료되는 시점을 정확히 알 수 있다.
* `잠깐 실행하고 마는 애플리케이션이 아닌 이상 예외가 발생했을 때 로그 파일에 오류를 출력하는 간단한 기능만이라도 확보할 수 있도록 모든 스레드를 대상으로 UncaughtExceptionHandler를 활용해야 한다.`
#### 7.4 JVM 종료
##### 7.4.1 종료 훅
* 예정된 절차대로 종료되는 경우에 NM은 가장 먼저 등록되어 있는 모든 종료 혹 shutdown hook을 실행시킨다.
* 종료 혹은 Runtime.addShutdownHook 메소드를 사용해등록된 아직 시작되지 않은 스레드를 의미한다.
* 종료 혹에서는 애플라케이션이 종료되거나 다른 종료 혹이 종료시킬 수 있는 서비스는 사용하지 말아야 한다.
##### 7.4.2 데몬 스레드
* 스레드 종류
  * 일반 스레드 : main 스레드에서 생성한 모든 스레드는 기본적으로 데몬 스레드가 아닌 일반 스레드
  * 데몬 스레드 : JVM 이 처음 시작할 때 main 스레드를 제외하고 JVM 내부적으로 사용하기 위해 실행하는 스레드
* `데몬 스레드는 예고 없이 종료될 수 있기 때문에 애플리케이션 내부에서 시작시키고 종료 시키며 사용하기에는 그다지 좋은 방법이 아니다.`  
##### 7.4.3 finalize 메소드
* `finalize 메소드는 사용하지 마라`
### 8장 스레드 풀 활용
#### 작업과 실행 정책 간의 보이지 않는 연결 관계
#### 스레드 풀 크기 조절
#### ThreadPoolExecutor 설정
#### ThreadPoolExecutor 상속
#### 재귀 함수 병렬화
### 9장 GUI 애플리케이션
#### GUI는 왜 단일 스레드로 동작하는가?
#### 짧게 실행되는 GUI 작업
#### 장시간 실행되는 GUI 작업
#### 데이터 공유 모델
#### 다른 형태의 단일 스레드 서브시스
## 3부 가용성, 성능, 테스트
### 10장 가용성을 최대로 높이기
#### 데드락
#### 데드락 방지 및 원인 추척
#### 그 밖의 활동성 문제점
### 11장 성능, 확장성
#### 성능에 대해
#### 암달의 법칙
#### 스레드와 비용
#### 락 경쟁 줄이기
#### 예제: Map 객체의 성능 분석
### 12장 병렬 프로그램 테스트
#### 정확성 테스트
#### 성능 테스트
#### 성능 측정의 함정 피하기
#### 보조적인 테스트 방
## 4부 고급 주제
### 13장 명시적인 락
#### Lock과 ReentrantLock
#### 성능에 대한 고려 사항
#### 공정성
#### synchronized 또는 ReentrantLock 선택
#### 읽기-쓰기 락
### 14장 전용 동기화 기능 구현
#### 상태 종속성 관리
#### 조건 큐 활용
#### 명시적인 조건 객체
#### 동기화 클래스의 내부 구조
#### AbstractQueuedSynchronizer
#### java.uitl.concurrent 패키지의 동기화 클래스에서 AQS 활용 모습
### 15장 단일 연산 변수와 넌블로킹 동기화
#### 락의 단점
#### 병렬 연산을 위한 하드웨어적인 지원
#### 단일 연산 변수 클래스
#### 넌블로킹 알고리즘
### 16장 자바 메모리 모델
#### 자바 메모리 모델은 무엇이며, 왜 사용해야 하는가?
* 특정 스레드에서 변수에 할당된 최신 값을 읽어가지 못할 수 있는 원인
  * 컴파일러에서 소스코드에 적힌 내용을 명확하게 구현하는 코드를 생성해 내지 못할 가능성
##### 플랫폼 메모리 모델
##### 재배치
##### 자바 메모리 모델을 간략하게 설명한다면
* 미리 발생 현상에 대한 규칙
  * 프로그램 순서 규척: 특정 스레드를 놓고 봤을 때 프로그램된 순서에서 앞서있는 작업은 동일 스레드에서 뒤에 실행되도록 프로그램된 작업보다 미리 발생한다.
  * 모니터 잠금 규척: 특정 모니터 잠금 업이 뒤이어 오는 모든 모니터 잠금 법보다 미리 발생한다.
  * volatile 변수 규칙 : volatile 변수에 대한 쓰기 업은 이후에 따라오는 해당 변수에 대한 모든 읽기 업보다 미리 발생한다.
  * 스례드 시작 규척 : 특정 스러|드에 대한 Thread.start 작업은 시작된 스레드가 갖고 있는 모든 작업보다 미리 발생한다.
  * 스레드 완료 규칙 : 스레드 내부의 모든 법은 다른 스러|드에서 해당 스레드가 완료됐다 는 점을 파악하는 시점보다 미리 발생한다 특정 스레드가 완료됐는지를 판단하는 것은 Thread.join 메소드가 리턴되거나 Thread.isAlive 메소드가 false를 리턴하는지 확인하는 방법을 말한다.
  * 인터럽트 규칙 : 다른 스레드를 대상으로 interrupt 메소드를 호출하는 작업은 인터럽트 당한 스레드에서 인터럽트를 당했다는 사실을 파악하는 일보다 미리 발생한다. 인터럽트를 당했다는 사실을 파악하려면 InterrupterException을 받거나 isInterrupted 메소드 또는 interrupted 메소드를 호출하는 방법을 사용할 수 있다.
  * 완료 메소드 규칙 : 특정 객체에 대한 생성 메소드가 완료되는 시점은 완료 메소드가 시작하는 시점보다 미리 발생한다.
  * 전이성(transitivity) : A가 B보다 미리 발생하고, B가 C보다 미리 발생한다면, A는 C보다 미리 발생한다. 
##### 동기화 피기백
#### 안전한 공개
#### 초기화 안전성