# 자바 병렬 프로그래밍

### 1장 개요
#### 작업을 동시에 실행하는 일에 대한 (아주) 간략한 역사
* 프로세스끼리는 서로 통신을 할 수도 있는데 소켓, 시그널 핸들러, 공 유메모리, 세마포어, 파일등의 비교적 큰단위의 다양한통신수단이 제공
* 운영체제를 개발하게 된 몇 가지 요인
 * 자원 활용 
   * 프로그램은 때로 입출력과 같이 외부 동작이 끝나기를 기다려야 송}는 경우 가 많은데 기다리는 동안은 유용한 일을 처리하지 못함 
   * 하나의 프로그램이 기다리는 동안 다른 프로그램을 실행하도록 지원하는 편이 더 효율적
 * 공정성 
   * 여러 시용자와 프로그램이 컴퓨터 내 자원에 대해 통일한 권한을 가질 수 있음 
   * 한 번에 프로그램 하나를 끝까지 실행해 종료된 이후에야 다른 프로그램을 시작하 는 것보다는 더 작은 단위로 컴퓨터를 공유하는 방법이 바람직
 * 편의성
   * 때론 여러 작업을 전부 처리하는 프로그램 하나를 작성하는 것보다 각기 일을 하나씩 처리하고 필요할 때 프로그램 간에 조율랜 프로그램을 여러 개 작성하는 편이 더 쉽고 바람직
* 자원 활용, 공정성, 편의성 등 프로세스 개념을 만들어내게 된 것과 같은 동기를 갖고 스레드가 고안
* 스레드로 인해 한 프로세스 안에 여러 개의 프로그램 제어흐름이 공존
* 스레드는 메모리 파일 핸들과 같이 프로세스에 할당된 자원을 공유
* 스레드는 각기 별도의 프로그램 카운터, 스택, 지역 변수를 가짐
* 현대 운영체제의 대부분은 프로세스가 아니라 스레드를 기본 단위로 CPU 자원의 스케줄을 정함
* 스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드는 같은 변수에 접근하고 같은 협 heap에 객체를 할당
* 공유 된 데이터에 접근하는 과정을 적절하게 동기화하지 않으면 다른 스레드가 사용 중인 변수를 순간적으로 수정해서 예상치 못한 결과
#### 스레드의 이점
##### 멀티프로세스 활용
* 제대로 설계하기만 한 다면 멀티스레드 프로그램은 가용한 프로세서 자원을 더 효율적으로 이용해서 처리 속도를 높일 수 있음
* I/O 때문에 대기 상태에 들어가는 동안에도 다른 스레드는 동작할 수 있기 때문에 애플리케이션이 계속 실행
##### 단순한 모델링
* 한 종류 일을 순차적으로 처리하는 프로그램은 작성하 기 쉽고 오류도 별로 생기지 않음
* 여러 종류의 일을 동시에 처리하는 프로그램 보다 태스트하기도 쉬움
##### 단순한 비동기 이벤트 처리
* 각 요청을 별개 스레드에서 처리하면 대기 상태에 들어가도 다른 스레드가 요청을 처리하는 데는 별 영향을 끼치지 않음
##### 더 빨리 반응하는 사용자 인터페이스
* 시간이 오래 걸릴 작업을 별도 스레드에서 실행했다면 이벤트 스레드는 계속 UI 이벤트를 처리할 수 있어 UI가 더 빨리 반응
#### 스레드 사용의 위험성
##### 안전성 위해 요소
* 스레드 안전성은 생각보다 미묘 
* 동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산의 순서가 때론 놀라울 만큼 예측하기가 어렵움
![UnsafeSequence.getNext 메소드가 잘못 동작하는 예](/images/프로그래밍_언어/자바/자바병렬프로그래밍/figure_1-1.png)
##### 활동성 위험
* 단일 스레드 프로그램에서는 나타나지 않는 추가적인 형태의 활동성 liveness 장애가 생길 수 있음
* 스레드에서 실행하는 작업의 상대적인 타이밍에 따라 활동성 문제점이 나타나기 때문에 개발이나 테스트 도중에 잘 드러나지는 않음
##### 성능 위험
* 멀티스레드 프로그램은 단일 스레드 프로그램에서 발생할 수 있는 모든 성능 위험뿐만 아니라, 스레드를 사용하기 때문에 생기는 추가 위험에도 노출
* 스레드가 많은 프로그램에서는 컨텍스트 스위칭 (다른 스레드가 실행될 수 있게 스케줄러가 현재 실행 중인 스레드를 잠시 멈출 때)이 더 빈번하고 그 때문에 상당한부담이 생김
#### 스레드는 어디에나
* 프로그램을 작성할 때 스레드를 직접 생성하지 않더라도 프로그램이 사용하는 프레임웍에서 스레드를 생성할 수도 있음
## 1부 기본 원리
### 2장 스레드 안전성
* 객체의 상태는 인스턴스나 static 변수 같은 상태 변수에 저장된 객체의 데이터
* 공유됐다는 것은 여러 스레드가 특정 변수에 접근할 수 있다는 뜻
* 변경할 수 있다 mutable 는 것은 해당 변수 값이 변경될 수 있다는 뜻
* 스레드 안전성이 마치 코드를 보호하는 것처럼 이해하는 경우가 많지만 실제로는 데이터에 제어 없이 동시 접근하는 걸 막으려는 의미임
* 객체를 스레드에 안전하게 만들려면 동기회를 통해 변경할 수 있는 상태에 접근하는 과정을 조율
* 스레드가 하나 이상 상태 변수에 접근하고 그 중 하나라도 변수에 값을 쓰면, 해당 변수에 접근할 때 관련된 모든 스레드가 동기화를 통해 조율
* 자바에서 동기화를 위한 기본 수단은 synchronized 키워드로서 배타적인 락을 통해 보호 기능을 제공
* volatile 변수 명시적 락 단일 연산 변수 atomic variable 를 사용하는 경우에도 ‘동기화’ 라는 용어를 사용
* 스레드 안전성을 확보하기 위해 나중에 클래스를 고치는 것보다는 애당초 스레드에 안전하게 설계하는 편이 훨씬 쉬움
* 캡슐화나 데이터 은닉 data hiding 같은 기법이 스레드에 안전한 클래스를 작성하는 데도 도움
#### 스레드 안정성이란?
* 정확성이란 클래스가 해당 클래스의 명세에 부합한다는 뜻
* 여러 스레드가 클래스에 접근할 때 계속 정확하게 동작하면 해당 클래스는 스레드 안전
* `여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케쥴하든 어디서 끼워 넣든, 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고 말한다.`
##### 예제: 상태 없는 서블릿
* 선언한 변수가 없고 다른 클래스의 변수를 참조하지도 않음
* 특정 계산을 위한 일시적인 상태는 스레드의 스택에 저장되는 지역 변수에만 저장
* 실행하는 해당 스레드에서만 접근할 수 있음
* `상태 없는 객체는 항상 스레드 안전하다.`
#### 단일 연산
```java
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
    private long count = O;
    public long getCount() { return count; }
    public void service(ServletRequest req, ServletResponse resp) {
        Biginteger i = extractFromRequest(req);
        Biginteger[] factors= factor(i);
        ++count;
        encdeintoResponse(resp, factors);
    }
}
```
* 값을 증가시키는 ++count는 한 줄짜리 간단한 코드인지라 단일 작업처럼 보이지만 실제로는 단일 연산이 아님
##### 경쟁 조건
* 상대적인 시점이나 또는 JVM이 여러 스레드를 교차해서 실행하는 상황에 따라 계산의 정확성이 달라질 때 나타남
* 가장 일반적인 경쟁 조건 형태는 잠재적으로 유효하지 않은 값을 참조해서 다음에 뭘 할지를 결정하는 점검 후 행동 형태의 구문
##### 예졔: 늦은 초기화 시 경쟁 조건
* 늦은 초기화는 특정 객체가 실제 필요할 때까지 초기화를 미루고 동시에 단 한 번만 초기화 되도록 하기 위한 것
```java
@NotThreadSafe
public class LazyinitRace {
    private ExpensiveObject instance = null;
    public ExpensiveObject getinstance() {
        if (instance == null) {
            instance =new ExpensiveObject();
        }
        return instance;
    }
}
```
##### 복합 동작
* 경쟁 조건을 피하려면 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 막을 방법이 있어야 하며, 이런 방법으로 보호해두면 특정 스레드에서 변수를 수정할 때 다른 스레드는 수정 도중이 아닌수정 이전이나 이후에만 
상태를 읽거나 변경을 가할 수 있다.
```java
@ThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
    private final AtomicLong count = new AtomicLong(0);
    public long getCount() { return count.get(); }
    public void service(ServletRequest req, ServletResponse resp) {
        Biginteger i = extractFromRequest(req);
        Biginteger[] factors= factor(i);
        count.incrementAndGet();
        encdeintoResponse(resp, factors);
    }
}
```
#### 락
* 상태를 일관성 있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야 한다.
##### 암묵적인 락
* 단일 연산 특성을 보장하기 위해 synchronized 라는 구문으로 사용할 수 있는 락을 제공
* 자바에서 암묵적 인 락은 뮤텍스 mutexes 또는 mutual exclusion lock(즉 상호 배제 락)로 동작
* 스레드 B가 가지고 있는 락을 스레드 A가 얻으려면 A는 B가 해당 락을 놓을 때까지 기다려야 한다. 만약 B가 락을 놓지 않으면, A는 영원히 기다릴 수밖에 없음
```java
@ThreadSafe
public class SynchronizedFactorizer implements Servlet {
    @GuardedBy("this")
    private BigInteger lastNumber;
    @GuardedBy("this")
    private BigInteger lastFactors;
    
    public synchronized void service(ServletRequest req, ServletResponse resp) {
        Biginteger i = extractFromRequest(req);
        if(i.equals(lastNumber)) {
            encdeintoResponse(resp, factors);
        } else {
        	Biginteger[] factors= factor(i);
        	lastNumber = i;
            lastFactors = factors;
            encdeintoResponse(resp, factors);
        }
    }
}
```
##### 재진입성 (?)
* 재진입 가능 reentrant 하기 때문에 특정 스레드가 자기가 이미 획득한 락을 다시 확보
* 재진입성은 확보 요청 단위가 아닌 스레드 단위로 락을 얻는다는 것을 의미
#### 락으로 상태 보호하기
* 락은 자신이 보호하는 코드 경로에 여러 스레드가 순차적으로 접근하도록 하기 때문에 , 공유된 상태에 배타적으로 접근할 수 있도록 보장하는 규칙을 만들 때 유용
* 객체의 암묵적인 락과그 객체의 상태 사이에 원천적인 관계는 없음
* 특정 객체의 변수를 항상 그 객체의 암묵적인 락으로 보호해야 하는 건 아님
* 특정 객체의 락을 얻는다고 해도 다른 스레드가 해당 객체에 접근하는 걸 막을 순 없음 
* 락을 얻으면 단지 다른 스레드가 동일한 락을 얻지 못하게 할 수 있음
* 모든 객체에 내장된 락이 있다는 점 때문에 매번 별도로 락 객체를 생성할 필요가 없음
* 메소드를 동기화하면 각 메소드의 작업을 단일 연산으로 만들지만, 여러 메소드가 하나의 복합 동작으로 묶일 땐 락을 사용해 추가로 동기화
#### 활동성과 성능
* 종종 단순성과 성능이 서로 상충할 때가 있다. 동기화 정책을 구현할 때는 성능을 위해 조급하게 단순성(잠재적으로 안전성을 훼손하면서)을 희생하고픈 유혹을 버려야 한다.
* 복잡하고 오래 걸리는 계산 작업, 네트웍 작업, 사용자 입출력 작업과 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 한 락을 잡지 말아라.
### 3장 객체 공유
#### 가시성
* ``여러 쓰레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용한다.``
#### 공개와 유출
#### 스레드 한정
#### 불변셩
#### 안전 공개
### 4장 객체 구성
#### 스레드 안전한 클래스 설계
#### 인스턴스 한정
#### 스레드 안전성 위임
#### 스레드 안전하게 구현된 클래스에 기능 추가
#### 동기화 정책 문서화 하기
### 5장 프로그래밍 단위
#### 동기화된 컬렉션 클래스
#### 병렬 컬렉션
#### 블로킹 큐와 프로듀서-컨슈머 패턴
#### 블로킹 메소드, 인터럽터블 메소드
#### 동기화 클래스
#### 효율적이고 확장성 있는 결과 캐시 구현
## 2부 병렬 프로그램 구조 잡기
### 6장 작업 실행
#### 스레드에서 작업 실행
#### Executor 프레임웍
#### 병렬로 처리할 만한 작업
### 7장	중단 및 종료
#### 작업 중단
#### 스레드 기반 서비스 중단
#### 비정상적인 스레드 종료 상황 처리
#### JVM 종료
### 8장 스레드 풀 활용
#### 작업과 실행 정책 간의 보이지 않는 연결 관계
#### 스레드 풀 크기 조절
#### ThreadPoolExecutor 설정
#### ThreadPoolExecutor 상속
#### 재귀 함수 병렬화
### 9장 GUI 애플리케이션
#### GUI는 왜 단일 스레드로 동작하는가?
#### 짧게 실행되는 GUI 작업
#### 장시간 실행되는 GUI 작업
#### 데이터 공유 모델
#### 다른 형태의 단일 스레드 서브시스
## 3부	가용성, 성능, 테스트
### 10장	가용성을 최대로 높이기
#### 데드락
#### 데드락 방지 및 원인 추척
#### 그 밖의 활동성 문제점
### 11장	성능, 확장성
#### 성능에 대해
#### 암달의 법칙
#### 스레드와 비용
#### 락 경쟁 줄이기
#### 예제: Map 객체의 성능 분석
### 12장 병렬 프로그램 테스트
#### 정확성 테스트
#### 성능 테스트
#### 성능 측정의 함정 피하기
#### 보조적인 테스트 방
## 4부 고급 주제
### 13장 명시적인 락
#### Lock과 ReentrantLock
#### 성능에 대한 고려 사항
#### 공정성
#### synchronized 또는 ReentrantLock 선택
#### 읽기-쓰기 락
### 14장 전용 동기화 기능 구현
#### 상태 종속성 관리
#### 조건 큐 활용
#### 명시적인 조건 객체
#### 동기화 클래스의 내부 구조
#### AbstractQueuedSynchronizer
#### java.uitl.concurrent 패키지의 동기화 클래스에서 AQS 활용 모습
### 15장 단일 연산 변수와 넌블로킹 동기화
#### 락의 단점
#### 병렬 연산을 위한 하드웨어적인 지원
#### 단일 연산 변수 클래스
#### 넌블로킹 알고리즘
### 16장 자바 메모리 모델
#### 자바 메모리 모델은 무엇이며, 왜 사용해야 하는가?
#### 안전한 공개
#### 초기화 안전성