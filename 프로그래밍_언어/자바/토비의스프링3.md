# 토비의 스프링 3 [code](https://github.com/csj4032/enjoy-spring/tree/master/toby)

## 1부 이해
### 1장 오브젝트와 의존관계
* 스프링은 객체지향 설계와 구현에 관해 특정한 모델과 기법을 억지로 강요하지 않음
* 오브젝트를 어떻게 효과적으로 설계하고 구현하고, 사용하고, 이를 개선 해나갈 것인가에 대한 명쾌한 기준을 마련
* 스프링은 객체지향 기술과 설계, 구현에 관한 실용적인 전략과 검증된 베스트 프랙티스를 평범한 개발자도 자연스럽게 손쉽게 적용할 수 있도록 프레임워크 형태로 제공
#### 초난감 DAO
##### User
* 자바빈은 원래 비주얼 툴에서 조작 가능한 컴포턴트를 말함
* 자바빈의 몇 가지 코딩 관례는 JSP 빈, EJB와 같은 표준 기술과 자바비 스타일의 오브젝트를 사용하는 오픈 소스 기술을 통해 계속 이어짐
  * 디포트 생성자
    * 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 함
    * 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문
  * 프로퍼티
    * 자바빈의 노출하는 이름을 가진 속성을 프로퍼티라고 함
    * set 수정 메소드, get 접근자 메소드
##### UserDao
* JDBC를 이용하는 작업의 일반적인 순서
  * DB 연결을 위한 Connection을 가져옴
  * SQL을 담은 Statement (또는 PreparedStatement)를 만듬
  * 만들어진 Statement를 실행
  * 조회의 경우 SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮김
  * 작업 중에 생성된 Connection, Statement, ResultSet 같은 리소스는 작업을 마친 후 반드시 닫음
  * JDBC API가 만들어내는 예외를 잡아서 직접 처리하거나, 메소드에 throws를 선언해서 예외가 발생하면 메소드 밖으로 던짐
##### main()을 이용한 DAO 테스트 코드
* 스프링은 기계적인 답변이나 성급한 결론을 주지 않음
* 최종 결론은 스프링을 이용해 개발자 스스로 만들어내는 것
#### DAO의 분리
##### 관심사의 분리
* 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가
* 객체 지향 기술은 흔히 실세계를 최대한 가깝게 모델링해낼 수 있기 때문에 의미가 있고 여겨짐 하지만 그보다는 객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭게 편리하게 변경, 발전, 확장시킬 수 있다든데 더 의미가 있음
* 분리와 확장을 고려한 설계
* 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어남
* 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 한곳에 집중되지 않은 경우가 많음
* 관심사분의 분리(Separation of Concerns) : 관심이 같은 것끼리 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것
##### 커넥션 만들기의 추출
###### UserDao의 관심사항
* 첫째는 DB와 연결을 위한 커넥션을 어떻게 가져올까라는 관심
* 둘째는 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것
* 셋째는 작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아줘서 소중한 공유 리소스를 시스템에 돌려주는 것
###### 중복 코드의 메소드 추출
* 관심의 종류에 따라 코드를 구분해놓았기 때문에 한 가지 관심에 대한 변경이 일어날 경우 그 관심이 집중되는 부분의 코드만 수정하면 됨
* 관심이 다른 코드가 있는 메소드에는 영향을 주지도 않을뿐더러, 관심 내용이 독립적으로 존재하므로 수정도 간
###### 변경사항에 대한 검증 : 리팩토링과 테스트단
* 메소드 추출 : 중복된 코드를 메소드로 뽑아내는 것
* 리팩토링 : 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술
##### DB 커넥션 만들기의 독립
###### 상속을 통한 확장
* 템플릿 메소드 패턴 : 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브 클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법
![UserDao에 적용된 팩토리 메소드 패턴](/images/프로그래밍_언어/자바/토비의스프링3/figure_1-2.png)
#### DAO의 확장
* 변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 뜻
##### 클래스의 분리
* UserDao가 SimpleConnectionMaker라는 특정 클래스와 그 코드에 종속적이기 때문에 앞으로 납품 후에 고객이 DB 커넥션을 가져오는 방법을 자유롭게 확장하기 힘듬
##### 인터페이스의 도입
* 추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업
##### 관계설정 책임의 분리
* UserDao의 다른 모든 곳에서는 인터페이스를 이용하게 만들어서 DB 커넥션을 제공하는 클래스에 대한 구체적인 정보를 모두 제거가 가능
* 초기에 한 번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 제거되지 않고 남음
* UserDao가 어떤 ConnectionMaker 구현 클래스의 오브젝트를 이용하게 할지를 결정하는 것
* UserDao와 UserDao가 사용할 ConnectionMaker의 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심
* UserDaoTest는 UserDao와 ConnectionMaker 구현 클래스와의 런타임 오브젝트 의존 관계를 설정하는 책임을 담당
![관계설정 책임을 담당한 클라이언트 UserDaoTest가 추가된 구조](/images/프로그래밍_언어/자바/토비의스프링3/figure_1-7.png)
##### 원칙과 패턴
###### 개방 폐쇄 원칙
* `클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀있어야 한다.`
* 인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 활짝 개방, 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄
###### 높은 응집도와 낮은 결합도
* 개방 패쇄 원칙은 높은 응집도와 낮은 결합도라는 소프트웨어 개발의 고전적인 원리로도 설명 가능
####### 높은 응집도
* 응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수도 있음
####### 낮은 결합도
* 낮은 결합도는 높은 응집도보다 더 민감한 원칙
* 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직함
* 결합도란 '하나의 오프젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오프젝트에게 변화를 요구하는 정도'
###### 전략 패턴
* 전략 패턴은 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
#### 제어의 역전(IoC)
##### 오브젝트 팩토리
###### 팩토릭
* 팩토리 : 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것
* 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적
###### 설계도로서의 팩토리
* DaoFactory는 애플리케이션의 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맏고 있음
##### 오브젝트 팩토리의 활용
##### 제어권의 이전을 통한 제어관계 역전
#### 1.5 스프링의 IoC
##### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC
###### 애플리케이션 컨텍스트와 설정정보
###### DaoFactory를 사용하는 애플리케이션 컨텍스트
##### 1.5.2 애플리케이션 컨텍스트의 동작방식
##### 1.5.3 스프링 IoC의 용어 정리
#### 1.6 싱글톤 레지스트리와 오브젝트 스코프
##### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
###### 서버 애플리케이션과 싱글톤
###### 싱글톤 패턴의 한계
###### 싱글톤 레지스트리
##### 1.6.2 싱글톤과 오브젝트의 상태
##### 1.6.3 스프링 빈의 스코프
#### 1.7 의존관계 주입(DI)
##### 1.7.1 제어의 역전(IoC)과 의존관계 주입
##### 1.7.2 런타임 의존관계 설정
###### 의존관계
###### UserDao의 의존관계
###### UserDao의 의존관계 주입
##### 1.7.3 의존관계 검색과 주입
##### 1.7.4 의존관계 주입의 응용
###### 기능 구현의 교환
###### 부가기능 추가
##### 1.7.5 메소드를 이용한 의존관계 주입
#### 1.8 XML을 이용한 설정
##### 1.8.1 XML 설정
###### connectionMaker() 전환
###### userDao() 전환
###### XML의 의존관계 주입 정보
##### 1.8.2 XML을 이용하는 애플리케이션 컨텍스트
##### 1.8.3 DataSource 인터페이스로 변환
###### DataSource 인터페이스 적용
###### 자바 코드 설정 방식
###### XML 설정 방식
##### 1.8.4 프로퍼티 값의 주입
###### 값 주입
###### value 값의 자동 변환
#### 1.9 정리