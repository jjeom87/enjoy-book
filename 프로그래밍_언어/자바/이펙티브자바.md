# 이펙티브 자바

## 1장 서론
* 클래스의 멤버로는 필드, 메서드, 멤버 클래스 그리고 멤버 인터페이스 등
* 메서드의 시그너처는 그 이름과 형식 인자 자료형들로 구성 (반환값 자료형 X)
## 2장 객체의 생성과 삭제
### 규칙 1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라
* 생성자와는 달리 정적 팩터리 메서드에는 이름이 있다는 것이다.
* 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요는 없다는 것이다.
* 생성자와는 달리 변환값 자료형의 하위 자료형 객체를 반환할 수 있다든 것이다.
### 규칙 2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라.
* 점층적 생성자 패턴은 잘 동작하지만 인자 수가 늘어나면 클라이언트 코드를 작성하기가 어려워지고, 무엇보다 읽기 어려운 코드가 됨
* 자바빈 패턴은 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로, 객체 일관성(consistency)이 일시적으로 깨질 수 있음
* 자바빈 패턴으로 변경 불가능(immutable) 클래스를 만들 수 없다는 것
* 빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인자가 선택적 인자인 상황에 유용
* 생성자와 마찬가지로, 빌더 패턴을 사용하면 인자에 불변식(invariant)을 적용할 수 있음
* 빌더 객체는 여러 개의 varargs 인자를 받을 수 있다는 것
* 빌더 패턴은 하나의 빌더 객체로 여러 객체를 만들 수 있음
* 빌더 객체는 어떤 필드의 값은 자동으로 채울 수도 있음
* 단점
  * 객체를 생성하려면 우선 빌더 객체를 생성 
  * 실무에서 빌더 객체를 만드는 오버헤드가 문제가 될 소지는 없어 보이지만, 성능이 중요한 상황에선 그렇지 않을 수도 있음
* 빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인지가 선택적 인자인 상황에 유용
### 규칙 3 private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라
* 클래스를 싱글턴으로 만들면 클라이언트를 테스트하기가 어려워질 수가 있음
* 원소가 하나뿐인 enum 자료형이야말로 싱글턴을 구현하는 가장 좋은 방법
### 규칙 4 객체 생성을 막을 때는 private 생성자를 사용하라
* 원소가 하나뿐인 enum 자료형이야말로 싱글턴을 구현하는 가장 좋은 방법
* 객체를 만들 수 없도록 하려고 클래스를 abstract로 선언해 봤자 소용
* private 생성자를 클래스에 넣어서 객체 생성을 방지하자는 것
### 규칙 5 불필요한 객체는 만들지 말라
### 규칙 6 유효기간이 지난 객체 참조는 폐기하라
* 만기 참조란, 다시 이용되지 않을 참조
* 자동적으로 쓰레기 객체를 수집하는 언어에서 발생하는 메모니 누수 문제 (의도치 않은 객체 보유)
* 만기 참조가 몇 개라도 있으면 굉장히 많은 객체가 쓰레기 수집에서 제외될 가능성이 있음
* 객체 참조를 null 처리하는 것은 규범(norm)이라기보단 예외적인 조치가 되어야 한다.
* 자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 누수가 발생하지 않도록 주의해아 한다.
* 더 이상 사용되지 않는 원소 안에 있는 객체 참조는 반드시 null로 바꿔 주어야 한다.
* 캐시도 메모리 누수가 흔히 발생하는 장소다.
* WeakHashMap은 캐시 안에 보관되는 항목의 수명이 키에 대한 외부 참조의 수명에 따라 결정되는 상황에서만 적용 가능하다는 것을 기억하자.
* 메모리 누수가 흔히 발견되는 또 한 곳은 리스너 등의 역호출자다.
### 규칙 7 종료자 사용을 피하라
* 종료자(finalizer)는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요
* 긴급한(time-critical) 작업을 종료자 안에서 처리하면 안됨
* 중요 상태 정보(Cridcal Pers蹈tent state)는 종료자로 갱신하면 안됨
* 종료자는 그런 자원을 발견하게 될 경우 반드시 경고 메시지를 로그(1og)
## 3장 모든 객체의 공통 메서드
### 규칙 8 equals를 재정의할 때는 일반 규약을 따르라
* 각각의 객체가 고유하다
* 클래스에 논리적 동일성(logical eqUality), 검사 방법이 있건 없건 상관없다
### 규칙 9 equals를 재정의할 때는 반드시 hashCode도 재정의하라
### 규칙 10 toString은 항상 재정의하라
* toString을 잘 만들어 놓으면 클래스를 좀 더 쾌적하게 사용할 수 있다.
* 가능하다면 toString 메서드는 객체 내에 중요 정보를 전부 담아 반환해야 한다.
### 규칙 11 clone을 재정의할 때는 신중하라
* 어떤 클래스가 Cloneable을 구현하면, Object의 clone 메서드는 헤당 객체를 필드 단위로 복사한 객체를 반환
### 규칙 12 Comparable 구현을 고려하라
## 4장 클래스와 인터페이스
### 규칙 13 클래스와 멤버의 접근 권한은 최소화하라
### 규칙 14 public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라
### 규칙 15 변경 가능성을 최소화하라
### 규칙 16 계승하는 대신 구성하라
### 규칙 17 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라
### 규칙 18 추상 클래스 대신 인터페이스를 사용하라
### 규칙 19 인터페이스는 자료형을 정의할 때만 사용하라
### 규칙 20 태그 달린 클래스 대신 클래스 계층을 활용하라
### 규칙 21 전략을 표현하고 싶을 때는 함수 객체를 사용하라
### 규칙 22 멤버 클래스는 가능하면 static으로 선언하라
## 5장 제네릭 
### 규칙 23 새 코드에는 무인자 제네릭 자료형을 사용하지 마라
* 선언부에 형인자(type parameter)가 포함된 클래스나 인터페이스는 제네릭(generic) 클래스나 인터페이스라고 부름
* 무인자 자료형을 쓰면 형 안전성이 사라지고, 제네릭의 장점 중 하나인 표현력(expressiveness) 측면에서 손해를 보게 됨
* List와 List\<Object\> 사이에는 무슨 차이가 있나? 간단히 말해서 List는 형 검사 절차를 완전히 생략한 것이고, List<Object>는 아무 객체나 넣을 수 있다는 것을 컴파일러에게 알리는 것
* 제네릭에 대한 하위 자료형 정의 규칙에 따르면 List\<String\>은 List의 하위 자료형(subtype)이지만 List\<Object\>의 하위 자료형은 아니기 때문
* List와 같은 무인자 자료형을 사용하면 형 안전성을 잃게 되지만, List\<Object\>와 같은 형인자 자료형을 쓰면 그렇지 않음
```java
public class Raw {

    public static void main(String[] args) {
        List<String>strings = new ArrayList<string>();
        unsafeAdd(strings, newInteger(42));
        Strings=strings.get(0);
    }
    
    private static void unsafeAdd(List list, Object o) {
        list.add(o);
    }
}
```
* Collection<?>에는 null 이의의 어떤 원소도 넣을 수 없음
### 규칙 24 무점검 경고(unchecked warning)를 제거하라
* 제거할 수 없는 경고 메시지는 형 안전성이 확실할 때만 @SuppressWarnings("unchecked") 어노테이션(annotation)을 사용해 억제
### 규칙 25 배열 대신 리스트를 써라
### 규칙 26 가능하면 제네릭 자료형으로 만들 것
### 규칙 27 가능하면 제네릭 메서드로 만들 것
### 규칙 28 한정적 와일드카드를 써서 API 유연성을 높여라
### 규칙 29 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라
## 6장 열거형(enum)과 어노테이션 
### 규칙 30 int 상수 대신 enum을 사용하라
### 규칙 31 ordinal 대신 객체 필드를 사용하라 
### 규칙 32 비트 필드(bit field) 대신 EnumSet을 사용하라
### 규칙 33 ordinal을 배열 첨자로 사용하는 대신 EnumMap을 이용하라
### 규칙 34 확장 가능한 enum을 만들어야 한다면 인터페이스를 이용하라 
### 규칙 35 작명 패턴 대신 어노테이션을 사용하라 
### 규칙 36 Override 어노테이션은 일관되게 사용하라
### 규칙 37 자료형을 정의할 때 표식 인터페이스를 사용하라
### 7장 메서드 
### 규칙 38 인자의 유효성을 검사하라
### 규칙 39 필요하다면 방어적 복사본을 만들라
### 규칙 40 메서드 시그너처는 신중하게 설계하라
### 규칙 41 오버로딩할 때는 주의하라
### 규칙 42 varargs는 신중히 사용하라
### 규칙 43 null 대신 빈 배열이나 컬렉션을 반환하라 
### 규칙 44 모든 API 요소에 문서화 주석을 달라 
## 8장 일반적인 프로그래밍 원칙들 
### 규칙 45 지역 변수의 유효범위를 최소화하라
### 규칙 46 for 문보다는 for-each 문을 사용하라 
### 규칙 47 어떤 라이브러리가 있는지 파악하고, 적절히 활용하라 
### 규칙 48 정확한 답이 필요하다면 float와 double은 피하라 
### 규칙 49 객체화된 기본 자료형 대신 기본 자료형을 이용하라
### 규칙 50 다른 자료형이 적절하다면 문자열 사용은 피하라 
### 규칙 51 문자열 연결 시 성능에 주의하라
### 규칙 52 객체를 참조할 때는 그 인터페이스를 사용하라
### 규칙 53 리플렉션 대신 인터페이스를 이용하라
### 규칙 54 네이티브 메서드는 신중하게 사용하라
### 규칙 55 신중하게 최적화하라
### 규칙 56 일반적으로 통용되는 작명 관습을 따르라
## 9장 예외 327 
### 규칙 57 예외는 예외적 상황에만 사용하라
### 규칙 58 복구 가능 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류에는 실행시점 예외를 이용하라
### 규칙 59 불필요한 점검지정 예외 사용은 피하라
### 규칙 60 표준 예외를 사용하라
### 규칙 61 추상화 수준에 맞는 예외를 던져라
### 규칙 62 메서드에서 던져지는 모든 예외에 대해 문서를 남겨라
### 규칙 63 어떤 오류인지를 드러내는 정보를 상세한 메시지에 담으라
### 규칙 64 실패 원자성 달성을 위해 노력하라
### 규칙 65 예외를 무시하지 마라
## 10장 병행성  
### 규칙 66 변경 가능 공유 데이터에 대한 접근은 동기화하라
### 규칙 67 과도한 동기화는 피하라
### 규칙 68 스레드보다는 실행자와 태스크를 이용하라
### 규칙 69 wait나 notify 대신 병행성 유틸리티를 이용하라
### 규칙 70 스레드 안전성에 대해 문서로 남겨라
### 규칙 71 초기화 지연은 신중하게 하라
### 규칙 72 스레드 스케줄러에 의존하지 마라
### 규칙 73 스레드 그룹은 피하라
## 11장 직렬화  
### 규칙 74 Serializable 인터페이스를 구현할 때는 신중하라
### 규칙 75 사용자 지정 직렬화 형식을 사용하면 좋을지 따져 보라
### 규칙 76 readObject 메서드는 방어적으로 구현하라
### 규칙 77 개체 통제가 필요하다면 readResolve 대신 enum 자료형을 이용하라
### 규칙 78 직렬화된 객체 대신 직렬화 프락시를 고려해 보라
