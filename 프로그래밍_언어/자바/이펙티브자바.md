# 이펙티브 자바

## 1장 서론
* 클래스의 멤버로는 필드, 메서드, 멤버 클래스 그리고 멤버 인터페이스 등
* 메서드의 시그너처는 그 이름과 형식 인자 자료형들로 구성 (반환값 자료형 X)

## 2장 객체의 생성과 삭제

### 규칙 1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라
* 생성자와는 달리 정적 팩터리 메서드에는 이름이 있다는 것이다.
* 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요는 없다는 것이다.
* 생성자와는 달리 변환값 자료형의 하위 자료형 객체를 반환할 수 있다든 것이다.

### 규칙 2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라.
* 점층적 생성자 패턴은 잘 동작하지만 인자 수가 늘어나면 클라이언트 코드를 작성하기가 어려워지고, 무엇보다 읽기 어려운 코드가 됨
* 자바빈 패턴은 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로, 객체 일관성(consistency)이 일시적으로 깨질 수 있음
* 자바빈 패턴으로 변경 불가능(immutable) 클래스를 만들 수 없다는 것
* 빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인자가 선택적 인자인 상황에 유용
* 생성자와 마찬가지로, 빌더 패턴을 사용하면 인자에 불변식(invariant)을 적용할 수 있음
* 빌더 객체는 여러 개의 varargs 인자를 받을 수 있다는 것
* 빌더 패턴은 하나의 빌더 객체로 여러 객체를 만들 수 있음
* 빌더 객체는 어떤 필드의 값은 자동으로 채울 수도 있음
* 단점
  * 객체를 생성하려면 우선 빌더 객체를 생성 
  * 실무에서 빌더 객체를 만드는 오버헤드가 문제가 될 소지는 없어 보이지만, 성능이 중요한 상황에선 그렇지 않을 수도 있음
* 빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인지가 선택적 인자인 상황에 유용

### 규칙 3 private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라
* 클래스를 싱글턴으로 만들면 클라이언트를 테스트하기가 어려워질 수가 있음
* 원소가 하나뿐인 enum 자료형이야말로 싱글턴을 구현하는 가장 좋은 방법

### 규칙 4 객체 생성을 막을 때는 private 생성자를 사용하라
* 원소가 하나뿐인 enum 자료형이야말로 싱글턴을 구현하는 가장 좋은 방법
* 객체를 만들 수 없도록 하려고 클래스를 abstract로 선언해 봤자 소용
* private 생성자를 클래스에 넣어서 객체 생성을 방지하자는 것

### 규칙 5 불필요한 객체는 만들지 말라

### 규칙 6 유효기간이 지난 객체 참조는 폐기하라
* 만기 참조란, 다시 이용되지 않을 참조
* 자동적으로 쓰레기 객체를 수집하는 언어에서 발생하는 메모니 누수 문제 (의도치 않은 객체 보유)
* 만기 참조가 몇 개라도 있으면 굉장히 많은 객체가 쓰레기 수집에서 제외될 가능성이 있음
* 객체 참조를 null 처리하는 것은 규범(norm)이라기보단 예외적인 조치가 되어야 한다.
* 자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 누수가 발생하지 않도록 주의해아 한다.
* 더 이상 사용되지 않는 원소 안에 있는 객체 참조는 반드시 null로 바꿔 주어야 한다.
* 캐시도 메모리 누수가 흔히 발생하는 장소다.
* WeakHashMap은 캐시 안에 보관되는 항목의 수명이 키에 대한 외부 참조의 수명에 따라 결정되는 상황에서만 적용 가능하다는 것을 기억하자.
* 메모리 누수가 흔히 발견되는 또 한 곳은 리스너 등의 역호출자다.

### 규칙 7 종료자 사용을 피하라
* 종료자(finalizer)는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요
* 긴급한(time-critical) 작업을 종료자 안에서 처리하면 안됨
* 중요 상태 정보(critical persistent state)는 종료자로 갱신하면 안됨
* 종료자는 그런 자원을 발견하게 될 경우 반드시 경고 메시지를 로그(1og)

## 3장 모든 객체의 공통 메서드

### 규칙 8 equals를 재정의할 때는 일반 규약을 따르라
* 각각의 객체가 고유하다
* 클래스에 논리적 동일성(logical eqUality), 검사 방법이 있건 없건 상관없다.
* 상위 클래스에서 재정의한 equals가 하위 클래스에서 사용히기에도 적당하다.
* 클래스가 Private 또는 Package-Private로 선언되었고, equals 메서드를 호출할 일이 없다.
* 반사성(Reflexivity): 모든 객체는 자기 자신과 같아야 한다는 뜻이다.
* 대칭성(Symmetry): 두 객체에게 서로 같은지 물으면 같은 답이 나와야 한다는 것이다. 첫 번째 요구사항과는 달리, 실수하면 쉽게 깨지는 요구사항이다.
* 추이성(Transitivity): 첫 번째 객체가 두 번째 객체와같고, 두 번째 객체가 세 번째 객체와 같다면 첫 번째 객체와 세 번째 객체도 같아야 한다는 것이다.
* 일관성(Consistency): 일단 같다고 판정된 객체들은 추후 변경되지 않는 한 계속 같아야 한다는 것이다.
* 널(Null)에 대한 비 동치성(Non-nullity): 모든 객체는 null과 동치 관계에 있지 아니한다는 요구조건이다.
* equals가 따라야 할 규약을 어기면, 그 객체를 만난 다른 객체들이 어떻게 행동할지 예측할 수 없게 된다.
* 객체 생성가능(instantiable) 클래스를 계승하여 새로운 값 컴포넌트를 추가하면서 equals 규약을 어기지 않을 방법은 없다.
* 신뢰성이 보장되지 않는 자원(unreliable resource)들을 비교히는 equals를 구현하는 것은 삼가라.
* equals 메서드를 구현하기 위해 따라야 할 지침
  * == 연산자를 사용하여 equals의 인지가 자기 자신인지 검사하라.
  * instanceOf 연산지를 사용하여 인자의 자료형이 정확한지 검사하라.
  * equals의 인자를 정확한 자료형으로 변환하라.
  * "중요" 필드 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사한다.
  * equals 메서드 구현을 끝냈다면, 대칭성, 추이성, 일관성의 세 속성이 만족되는지 검토하라.

### 규칙 9 equals를 재정의할 때는 반드시 hashCode도 재정의하라
* equals 메서드를 재정의하는 클래스는 반드시 hashCode 메서드도 재정의 해야 한다.
  * HashMap, HashSet, HashTable 같은 해시(hash) 기반 컬렉션과 함께 시용하면 오동작
* hashCode를 재정의하지 않으면 위반되는 핵심 규약은 두 번째다. 같은 객체는 같은 혜시 코드 값을 가져야 한다는 규약이 위반되는 것이다.
* HashMap은 성능 최적화를 위해 내부에 보관된 항목의 해시 코드를 캐시해 두고, 캐시된 해시 코드가 없는 객체는 동일성 검사조차 하지 않음

### 규칙 10 toString은 항상 재정의하라
* toString을 잘 만들어 놓으면 클래스를 좀 더 쾌적하게 사용할 수 있다.
* 가능하다면 toString 메서드는 객체 내에 중요 정보를 전부 담아 반환해야 한다.
* toString이 반환하는 문자열의 형식을 명시하건 그렇지 않건 간에, 어떤 의도인지는 문서에 분명하게 남겨야 한다.
* toString이 반환하는 문자열에 포함되는 정보들은 전부 프로그래밍을 통해서 가져올 수 있도록(programmatic access) 하라.

```java
public class PhoneNumber {
    /**
    * 전화번호를 문자열로 변환해서 반환한다.
    * 문자열은 "(XXX) YYY-ZZZZ'' 형식으로, 14개 문자로 구성된다.
    * XXX는 지역번호, YYY는 국번, ZZZZ는 회선 번호다. 각 문자(X, Y, Z)는
    * 하나의 숫자다.
    *
    * 전화번호의 각 필드가 주어진 자리를 다 채우지 못할 경우 필드 앞에는
    * 0이 불는다. 예를 들어, 회선 번호가 123일 경우, 위의 문자열 마지막 필드에
    * 채워지는 문자열은 "0123"이 된다.
    *
    * 지역번호를 닫는 괄호와 국번 사이에는 공백이 온다는 것에 주의하자.
    */
    @Override
    public String toString() {
        return String.format("(%03d) %03d-%04d" ,areaCode, prefix, lineNumber);
    }
}
```

### 규칙 11 clone을 재정의할 때는 신중하라
* Cloneable은 어떤 객체가 복제(cl○ne)를 허용한다는 사실을 알리는 데 쓰려고 고안된 믹스인(mixin) 인터페이스다
* 비-final 클래스에 clone을 재정의할 때는 반드시 super.clone을 호출해 얻은 객체를 반환해야 한다.
* 실질적으로 cloneable 인터페이스를 구현하는 클래스는 제대로 동작하는 pubEc clone 메서드를 제공해야 한다.
* 라이브러리가 할 수 있는 일을 클라이언트에게 미루지 말라는 것이다.
* 사실상, clone 메서드는 또 다른 형태의 생성자다. 원래 객체를 손상시키는 일이 없도록 해야 하고, 복사본의 불변식(invariant)도 제대로 만족시켜야 한다.
* clone의 아키텍처는 변경 가능한 객체를 참조하는 final 필드의 일반적 용법과 호환되지 않는다.

### 규칙 12 Comparable 구현을 고려하라
* compareTO를 구현할 때는 모든 x와 y에 대해 sgn(x.compareTO(y)) == -sgn(y,compareTO(x))가 만족되도록 해야 한다. (y.compareTO(x)가 예외를 발생시킨다면 x.compareTo(y)도 그래야 하고, 그 역도 성립해야 한다.)
* compareTO를 구현할 때는 추이성(transitivity)이 만족되도록 해야 한다. 즉, (x.compareTO(y)) 0 && y.compareTO(z) ) 0)이면 x.compareTO(z) ) 0이어야 한다.
* 마지막으로, x.compareTO(y) == 0이면 sgn(x.compareTO(z)) == sgn(y.compareTO(z))의 관계가 모든 z에 대해 성립하도록 해야 한다.
* 강력히 추천하지만 절대적으로 요구되는 것은 아닌 조건 하나는 (x.compareTO(y) == 0) == (x.equals(y))이다.

## 4장 클래스와 인터페이스

### 규칙 13 클래스와 멤버의 접근 권한은 최소화하라
* 정보 은닉
  * 시스템을 구성하는 모듈 사이의 의존성을 낮춰서(decouple), 각자 개별적으로 개발하고, 시험하고, 최적화하고, 이해하고, 변경할 수 있도록 한다는 사실에 기초
  * 좋은 성능을 자동적으로 보장하는 것은 아니지만, 효과적인 성능 튜닝(tuning)을 가능하게 하는 것은 사실
  * 소프트웨어의 재시용 가능성을 높인다. 모듈간 의존성이 낮으므로 각 모듈은 다른 소프트웨어 개발에도 유용하게 쓰일 수 있음
  * 대규모 시스템 개발 과정의 위험성(risk)도 낮춤
* 각 클래스와 멤버는 기능한 한 접근 불가능하도록 만들라는 것.
* private - 이렇게 선언된 멤버는 선언된 최상위 레벨 클래스 내부에서만 접근 가능하다.
* package-private - 이렇게 선언된 멤버는 같은 패키지 내의 아무 클래스나 사용할 수 있다. 기본 접근 권한(default access)으로 알려져 있는데, 멤버를 선언할 때 아무런 접근 권한 수정자(access modifier)도 붙이지 않으면, 이 권한이 주어지기 때문.
* protected - 이렇게 선언된 멤버는 선언된 클래스 및 그 하위 클래스만 사용할 수 있다(몇 가지 제약 사항에 대해서는 [JLS, 6.6.2] 참고). 선언된 클래스와 같은 패키지에 있는 클래스에서도 시용이 기능하다.
* public - 이렇게 선언된 멤버는 어디서도 사용이 가능하다.
* 객체 필드(instance field)는 절대로 public으로 선언하면 안 된다.
* 변경 가능 public 필드를 가진 클래스는 다중 스레드에 안전하지않다.
* 요약 
  * public static final 배열 필드를 두거나, 배열 필드를 반환하는 접근지(accessor)를 정의하면 안 된다.
  * 접근 권한은 가능한 낮추라. 최소한의 pubic API를 설계한 다음, 다른 모든 클래스, 인터페이스, 멤버는 API에서 제외하라. 
  * public static final 필드를 제외한 어떤 필드도 pubMC 필드로 선언하지 마라. 
  * public static final 필드가 참조하는 객체는 변경 불가능 객체로 만들라.

### 규칙 14 public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라
* 선언된 패키지 밖에서도 사용 가능한 클래스에는 접근자 메서드를 제공하라.
* package-private 클래스나 private 중첩 클래스(nested class)는 데이터필드를 공개하더라도 잘못이라 말할 수 없다.

### 규칙 15 변경 가능성을 최소화하라
* 변경 불가능 클래스 규칙
  * 객체 상태를 변경하는 메서드(수정자 메서드 등)를 제공하지 않는다.
  * 계승할 수 없도록 한다.
  * 모든 필드를 final로 선언한다.
  * 모든 필드를 private로 선언한다.
  * 변경 기능 컴포넌트에 대한 독점적 접근권을 보장한다.
* 변경 불가능 객체는 단순하다.
* 변경 불가능 객체는 스레드에 안전, 어떤 동기화도 필요 없음
* 변경 불가능한 객체는 자유롭게 공유할 수 있다.
* 변경 불기능한 객체는 그 내부도 공유할 수 있다.
* 변경 불가능 객체는 다른 객체의 구성요소로도 홀륭하다.
* 변경 불기능 객체의 유일한 단점은 값마다 별도의 객체를 만들어야 한다는 점이다.

### 규칙 16 계승하는 대신 구성하라
* 메서드 호출과 달리, 계승은 캡슐화(encapsulation) 원칙을 위반한다.
* 계승은 하위 클래스가 상위 클래스의 하위 자료형(subtype)ol 확실한 경우에만 바람직하다.

### 규칙 17 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라
* 재정의 가능 메서드를 내부적으로 어떻게 사용하는지(self-use) 반드시 문서에 남기라는 것이다.
* 클래스 내부 동작에 개입할 수 있는 훅(hooks)을 신중하게 고른 protected 메서드 형태로 제공해야 한다.
* 계승을 위해 설계한 클래스를 테스트할 유일한 방법은 하위 클래스를 직접 만들어 보는 것이다.

### 규칙 18 추상 클래스 대신 인터페이스를 사용하라
* 이미 있는 클래스를 개조해서 새로운 인터페이스를 구현하도록 하는 것은 간단하다.
* 인터페이스는 믹스인(mixin)을 정의하는 데 이상적이다.
* 인터페이스는 비 계층적인(nonhierarchical) 자료형 프레임워크(type framework)를 만들 수 있도록 한다.
* 인터페이스를 사용하면 포장 클래스 숙어(wrapper class idiom)을 통해 안전하면서도 강력한 기능 개선이 기능하다.
* 추상 골격 구현(abstract skeletal implementation) 클래스를 중요 인터페이스마다 두면, 인터페이스의 점과 추상 클래스의 장점을 결합할 수 있다.
* 인터페이스보다는 추상 클래스가 발전시키기 쉽다
* 인터페이스가 공개되고 널리 구현된 다음에는, 인터페이스 수정이 거의 불기능

### 규칙 19 인터페이스는 자료형을 정의할 때만 사용하라
* 상수 인터페이스 패턴은 인터페이스를 잘못 사용한 것이다.
* 자바 플랫폼 라이브러리에도 상수 인터페이스가 몇 개 있음 (java.io.object StreamConstants 이런 인터페이스는 실수로 포함된 것이라 생각해야 하며, 절대로 따라해서는 안 됨)

### 규칙 20 태그 달린 클래스 대신 클래스 계층을 활용하라
* 태그 기반 클래스(tagged class)는 너저분한데다 오류 발생 가능성이 높고, 효율적이지도 않다.
* 태그 기반 클래스는 클래스 계충을 얼기설기 흉내 낸 것일 뿐이다.

### 규칙 21 전략을 표현하고 싶을 때는 함수 객체를 사용하라
* 함수 객체의 주된 용도는 전략 패턴(Strategy pattern)을 구현 
* 패턴을 구현하기 위해서는 전략을 표현하는 인터페이스를 선언하고, 실행 기능 전략 클래스가 전부 해당 인터페이스를 구현하도록야 함
* 실행 가능 전략이 한 번만 시용되는 경우에는 보통 그 전략을 익명 클래스 객체로 구현 
* 반복적으로 시용된다면 private static 멤버 클래스로 전략을 표현한 다음, 전략 인터페이스가 자료형인 public static final 필드를 통해 외부에 공개하는 것이 바람

```java
// 실행 가능 전략들을 외부에 공개하는 클래스
class Host {
  
	private static class StrLenCmp implements Comparator<String>, Serializable {

        public int compare(String s1, String s2) {
            return s1.length() - s2.length();
        }
    }

  // 이 비교자는 직렬화가 가능
  public static final Comparator<String> STRING_LENGTH_COMPARATOR = new StrLenCmp();
  
  // 나머지 생략
}
```

### 규칙 22 멤버 클래스는 가능하면 static으로 선언하라
* 중첩 클래스 정적 멤버 클래스 (static member class), 비-정적 멤버 클래스(nonstatic member class), 익명 클래스(anonymous class), 그리고 지역 클래스(local class) 
* 내부 클래스(inner class) 비-정적 멤버 클래스(nonstatic member class), 익명 클래스(anonymous class), 그리고 지역 클래스(local class)
* 비-정적 멤버 클래스 안에서는 비깥 클래스의 메서드를 호출할 수도 있고, this 한정(qualified this) 구문을 통해 바깥 객체에 대한 참조를 획득할 수도 있다.
* 바깥 클래스 객체에 접근할 필요가 없는 멤버 클래스를 정의할 때는 항상 선언문 앞에 static을 붙여서 비-정적 멤버 클래스 대신 정적 멤버 클래스로 만들자.

## 5장 제네릭 

### 규칙 23 새 코드에는 무인자 제네릭 자료형을 사용하지 마라
* 선언부에 형인자(type parameter)가 포함된 클래스나 인터페이스는 제네릭(generic) 클래스나 인터페이스라고 부름
* 무인자 자료형을 쓰면 형 안전성이 사라지고, 제네릭의 장점 중 하나인 표현력(expressiveness) 측면에서 손해를 보게 된다.
* List와 같은 무인자 자료형을 사용하면 형 안전성을 잃게 되지만, List\<Object\> 와 같은 형인자 자료형을 쓰면 그렇지 않다.
* List와 List\<Object\> 사이에는 무슨 차이가 있나? 간단히 말해서 List는 형 검사 절차를 완전히 생략한 것이고, List<Object>는 아무 객체나 넣을 수 있다는 것을 컴파일러에게 알리는 것
* 제네릭에 대한 하위 자료형 정의 규칙에 따르면 List\<String\>은 List의 하위 자료형(subtype)이지만 List\<Object\>의 하위 자료형은 아니기 때문
* 비한정적 와일드카드 자료형과 무인자 자료형의 차이
  * 와일드카드 자료형은 안전하지만 무인자 자료형은 그렇지 않다.
  * 무인자 자료형 컬렉션에는 아무 객체나 넣을 수 있어서, 컬렉션의 자료형 불변식(type invanant)이 쉽게 깨진다.
  * Collection<?>에는 null 이의의 어떤 원소도 넣을 수 없다.
  * Collection<?>에는 어떤 자료형의 객체를 꺼낼 수 있는지도 알 수 없다.
* [클래스 리터럴(class literal)](https://docs.oracle.com/javase/tutorial/extra/generics/literals.html) 에는 반드시 무인자 자료형을 사용해야 한다.
* 제네릭 자료형에 instanceof 연산자를 적용할 때는 다음과 같이 하는 것이 좋다.
  
```java
public class Raw {

    public static void main(String[] args) {
        List<String> strings = new ArrayList<string>();
        unsafeAdd(strings, new Integer(42));
        String s = strings.get(0);
    }
    
    private static void unsafeAdd(List list, Object o) {
        list.add(o);
    }
}
```

### 규칙 24 무점검 경고(unchecked warning)를 제거하라
* 모든 무점검 경고는, 기능하다면 없애야 한다. 
* 제거할 수 없는 경고 메시지는 형 안전성이 확실할 때만 @SuppressWarnings("unchecked") 어노테이션(annotation)을 사용해 억제하기 바란다.
* @SuppressWarnings 어노테이션은 개별 지역 변수 선언부터 클래스 전체에까지, 어떤 크기의 단위에도 적용할 수 있다. 하지만 @SuppressWarnings 어노테이션은 가능한 한 작은 범위에 적용하라.
* @SuppressWarnings(“unchecked”) 어노테이션을 사용할 때마다, 왜 형 안전성을 위반하지 않는지 밝히는 주석을 반드시 붙이라.

### 규칙 25 배열 대신 리스트를 써라
* 배열은 제네릭 자료형과 두 가지 중요한 차이점
  * 배열은 공변 자료형(covariant), 제네릭은 불변 자료형(invariant)
    * Sub가 Super의 하위 자료형(subtype)이라면 Sub[]도 Super[]의 하위 자료형이라는 것이다.
    * Type1과 Type2가 있을 때, List\<Type1\>은 List\<Type2\>의 상위 지료형이나 하위 자료형이 될 수 없다.
  * 배열은 실체화(reification) 되는 자료형
    * 배열의 각 원소의 자료형은 실행시간(runtime)에 결정된다는 것이다.
    * 제네릭은 삭제(erasure) 과정을 통해 구현된다.
    * 자료형에 관계된 조건들은 컴파일 시점에만 적용되고, 그 각 원소의 자료형 정보는 프로그램이 실행될 때는 삭제된다는 것이다.
    * 자료형 삭제(erasure) 덕에, 제네릭 자료형은 제네릭을 사용하지 않고 작성된 오래된 코드와도 문제 없이 연동한다.
    * new List\<E\>[], new List\<String\>[], new E[]는 전부 컴파일되지 않는 코드다. 컴파일하려고 하면 제네릭 배열 생성(generic arraycreation)이라는 오류가 발생할 것이다. 
    * E, List\<E\>, List\<String\>와 같은 자료형은 실체화 불기능(non-refiable) 자료형으로 알려져 있다.
    * 프로그램이 실행될 때 해당 자료형을 표현하는 정보의 양이 컴파일 시점에 필요한 정보의 양보다 적은 자료형이 실체화 불기능 자료형이다.
    * 제네릭 자료형에 담긴 원소들의 자료형으로 만든 배열을 반환하는 것은 일반적으로 불가능하다.

### 규칙 26 가능하면 제네릭 자료형으로 만들 것
* 클래스를 제네릭화하는 첫 번째 단계는 선언부에 형인자(type parameter)를 추가하는 것이다.
* 무점검 형변환(unchecked cast) 경고 억제의 위험성은 스칼라(scalar) 자료형보다 배열 자료형 쪽이 더 크기 때문에 두번째 해법이 더 낫다고 볼 수도 있다.

### 규칙 27 가능하면 제네릭 메서드로 만들 것
* 형인자를 선언하는 형인자 목록(type parameter list)은 메서드의 수정자(modifier)와 반환값 자료형 사이에 둔다.
* 제네릭 싱글턴 패턴(generic singleton pattern)이 있다. 때로는 변경이 불가능하지만 많은 자료형에 적용 기능한 객체를 만들어야 할 때 가 있다. 
* 형인자가 포함된 표현식으로 형인자를 한정하는 것도 가능하다. 이런 용법을 재귀적 자료형 한정(recursive type bound)이라 한다.

### 규칙 28 한정적 와일드카드를 써서 API 유연성을 높여라
* 유연성을 최대화하려면, 객체 생산자(producer)나 소비자(consumer) 구실을 하는 메서드 인자의 자료형은 와일드카드 자료형으로 하라는 것이다.
* 반환값에는 와일드카드 자료형을 쓰면 안 된다.
* 클래스 사용자가 와일드카드 자료형에 대해 고민하게 된다면, 그것은 아마도 클래스 API가 잘못 설계된 탓일 것이다. 
* Comparable(T) 대신 항상 Comparable(? super T)를 사용해야 한다.
* 형인자가 메서드 선언에 단 한군데 나타난다면 해당 인자를 와일드카드로 바꾸라는 것이다.

### 규칙 29 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라
* 자바 15부터 Class가 제네릭 클래스가 되었으므로 가능하다. 
* class 리터털의 자료형은 더 이상 Class가 아니며, Class\<T\>다. 예를 들어 String.class의 자료형은 Class\<String\>이고 Integer.class의 자료형은 Class\<Integer\>다. 
* 컴파일 시간 자료형이나 실행시간 자료형 정보를 메서드들에 전달할 목적으로 Class 리터럴을 이용하는 경우, 그런 Class 리터럴을 자료형 토큰(type token)이라 부른다.

## 6장 열거형(enum)과 어노테이션

### 규칙 30 int 상수 대신 enum을 사용하라
* 열거 자료헝(enumemted type)은 고정 개수의 상수들로 값이 구성되는 자료형이다. (객체, 배열)
* 열거 상수 (enumelation Constant)별로 하나의 객체를 public static final 필드 형태로 제공하는 것이다.
* enum 자료형은 컴파일 시점 형 안전성(compile-time type safety)을 제공한다.
* enum 자료형은 임의의 메서드나 필드도 추가할 수 있도록 한다.
* 임의의 인터폐이스를 구현할 수도있다.
* enum 자료형에는 object에 정의된 모든 고품질 메서드들이 포함되어 있으며 Completable 인터페이스와 Serializable 인터페이스가 구현되어 있다.
* enum 상수의 직렬화 형식(selialized form)은 enum 자료형상의 변화 대부분을 견딜 수 있도록 설계되어 있다.
* enum 상수에 데이터를 넣으려면 객체 필드(instance Eeld)를 선언하고 생성자를 통해 받은 데이터를 그 필드에 저장하면 된다.
* 외부(external) enum 자료형 상수별로 달리 동작하는 코드를 만들어야 할 때는 enum 상수에 switch 문을 적용하면 좋다. 

### 규칙 31 ordinal 대신 객체 필드를 사용하라
* enum 상수에 연계되는 값을 ordinal을 사용해 표현하지 말라는 것이다. 그런 값이 필요하다면 그 대신 객체 필드(instance field)에 저장해야 한다.

### 규칙 32 비트 필드(bit field) 대신 EnumSet을 사용하라
* 열거 자료형을 집합에 사용해야 한다고 해서 비트 필드로 표현하면 곤란하다

### 규칙 33 ordinal을 배열 첨자로 사용하는 대신 EnumMap을 이용하라
* ordinal 값을 배열 첨자로 사용하는 것은 적절치 않다는 것이다. 대신 EnumMap을 써라.

### 규칙 34 확장 가능한 enum을 만들어야 한다면 인터페이스를 이용하라
* 계승 가능 enum 자료형은 만들 수 없지만, 인터페이스를 만들고 그 인터페이스를 구현하는 기본 enum 자료형을 만들면 계승 가능 enum 자료형을 흉내 낼 수 있다.

### 규칙 35 작명 패턴 대신 어노테이션을 사용하라
* 작명 패턴(naming pattern)
  * 철자를 틀리면 알아채기 힘든 문제가 생긴다.
  * 특정한 프로그램 요소에만 적용되도록 만들 수 없다는 것이다.
  * 프로그램 요소에 인자를 전달할 마땅한 방법이 없다는 것이다.

```java

// 표식 어노테이션 자료형(marker annotation type) 선언
import java.lang.annotation.*;

/**
* 어노데이션이 붙은 메서드가 데스트 메서드임을 표시.
* 무인자(parameterless) 정적 메서드에만 사용 가능
*/
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD )
public @interface Test {
}

```
* @Retension(RetensionPolicy.RUNTIME)은 Test가 실행시간(runtime)에도 유지되어야 하는 어노테이션이라는 뜻이다.
* @Target(ElementType.METHOD)는 Test가 메서드 선언부에서만 적용할 수 있는 어노테이션이라는 뜻이다.

### 규칙 36 Override 어노테이션은 일관되게 사용하라
* 상위 클래스에 선언된 메서드를 재정의할 때는 반드시 선언부에 Override 어노테이션을 붇어야 한다.

### 규칙 37 자료형을 정의할 때 표식 인터페이스를 사용하라
* 가장 중요한 첫 번째 장점은, 표식 인터페이스는 결국 표식 붙은 클래스가 만드는 객처I들이 구현하는 자료형이라는 점이다. 표식 어노테이션은 자료형이 아니다.
* 적용 범위를 좀 더세밀하게 지정할 수 있다는 것이다.
* 만일 ElementType.TYPE에 적용될 표식 어노데이션 자료형을 작성하고 있다면, 반드시 어노테이션 자료형으로 구현해야 하는지, 표식 인터페이스로 만드는 것이 바람직하지는 않은지 고민해보기 바란다.

### 7장 메서드

### 규칙 38 인자의 유효성을 검사하라
* **클래스 불변식(invariant)을 위반하는 객체**가 만들어지는 것을 막으려면, 생성자에 전달되는 인자의 유효성을 반드시 검사해야 한다.
* 유효성 검사 예외
  * 오버헤드가 너무 크거나 비현실적이고, 계산과정에서 유효성 검사가 자연스럽게 이루어지는 경우
* 암묵적인 유효성 검사 방법에 지나치게 기대다 보면, 실패 원자성(failure atomicity)을 잃게 된다는 점이다

### 규칙 39 필요하다면 방어적 복사본을 만들라
* 여러분이 만드는 클래스의 클라이언트가 불변식(invariant)을 망가뜨리기 위해 최선을 다할 것이라는 가정하에, 방어적으로 프로그래밍해야 한다.
* 생성자로 전달되는 변경 가능 객체를 반드시 방어적으로 복사
* 인자의 유효성을 검사하기 전에(규칙 38) 방어적 복사본을 만들었다는 것에 유의하자. 유효성 검사는 복사본에 대해서 시행한다.
  * 취약 구간(window of vulnerability)
  * 보안 커뮤니티에서는 이런 공격을 TICTOU 공격, 즉 time-of-check/time-of-use 공격
* Date 클래스는 final 클래스가 아니므로, clone 메서드가 반드시 java.util.Date 객체를 반환할 거라는 보장이 없다.
* 인자로 전달된 객체의 자료형이 제3자가 계승할 수 있는 자료형일 경우, 방어적 복사본을 만들 때 clone을 사용하지 않도록 해야 한다.
* 변경 기능 내부 필드에 대한 방어적 복사본을 반환하도 록 접근자를 수정해야 한다.

### 규칙 40 메서드 시그너처는 신중하게 설계하라
* 메서드 이름은 신중하게 고르라.
  * 모든 이름은 표준 작명 관습(standard naming conversion)을 따라야 한다.
  * 좀 더 널리 합의된 사항에도 부합하는 이름을 고르는 것이다.
* 편의 메서드(convenience method)를 제공하는 데 너무 열 올리지 마라.
  *  "맡은 일이 명확하고 거기 충실해야(pull its weight)" 한다.
  * 클래스나 인터페이스가 수행해야 하는 동작 각각에 대해서 기능적으로 완전한 메서드를 제공하라.
* 인자 리스트(parameter list)를 길게 만들지 마라.
* 자료형이 같은 인자들이 길게 연결된 인자 리스트는 특히 더 위험하다.
* 긴 인자 리스트를 짧게 줄이는 방법
  * 여러 메서드로 나누는 것
  * 도움 클래스(helper class)를 만들어 인자들을 그룹별로 나누는 것
  * 빌더 패턴(builder pattern)을 고쳐서 객체 생성 대신 메서드 호출에 적용하는 것
  * 인자의 자료형으로는 클래스보다 인터페이스가 좋다.
  * 인자 자료형으로 boolean을 쓰는 것보다는, 원소가 2개인 enum 자료형을 쓰는 것이 낫다.

### 규칙 41 오버로딩할 때는 주의하라
* 오버로딩된 메서드 가운데 어떤 것이 호출될지는 컴파일 시점에 결정되기 때문이다.
* 오버로딩된 메서드는 정적 (static)으로 선택되지만, 재정의된 메서드는 동적(dynamic)으로 선택되기 때문이다.
* 오버로딩을 사용할 때는 혼란스럽지 않게 사용할 수 있도록 주의해야 한다.
* 혼란을 피하는 안전하고 보수적인 전략은, 같은 수의 인자를 갖는 두 개의 오버로딩 메서드를 API에 포함시키지 않는 것이다.
* 생성자에는 다른 이름을 시용할 수 없다. 생성자가 많다면, 그 생성자들은 향상 오버로딩된다.
  * 생성자 대신 정적 팩터리 메서드를 사용하는 옵션을 시용할 수도 있다.

### 규칙 42 varargs는 신중히 사용하라
* 자바 15부터는 공식적으로는 가변 인자 메서드(variable arity method)라고 부르는 varargs 메서드가 추가
* 마지막 인자가 배열이라고 해서 무조건 뜯어고칠 생각은 버려라.
* varargs는 정말로 임의 개수의 인자를 처리할 수있는 메서드를 만들어야 할 때만 사용하라.
* varargs가 추가된 것은 자바 1.5부터 플랫폼에 추가된 printf 메서드와, varargs를 이용할 수 있도록 개선된 핵심 리플렉션(core reflection) 기능 때문이다.
* 마지막 인자가 배열이라고 해서 무조건 뜯어고칠 생각은 버려라.
* varargs는 정말로 임의 개수의 인자를 처리할 수있는 메서드를 만들어야 할 때만 사용하라.

### 규칙 43 null 대신 빈 배열이나 컬렉션을 반환하라
* Collection.toArray(T[])의 명세를 보면, 인자로 주어진 배열이 컬렉션의 모든 원소를 담을 정도로 큰 경우에는 해당 배열을 반환값으로 시용한다고 되어 있다. 따라서 위의 숙어대로 하면 빈 배열은 절대로 자동 할당되지 않는다.
* null 대신에 빈 배열이나 빈 컬렉션을 반환하라는 것이다.

### 규칙 44 모든 API 요소에 문서화 주석을 달라
* 좋은 API 문서를 만들려면 API에 포함된 모든 클래스, 인터페이스, 생성자, 메서드, 그리고 필드 선언에 문서화 주석을 달아야 한다.
* 문서화 주석에는 해당 메서드의 모든 선행츠건 (precondition)과 후행조건(postcondition)을 나열해야 한다.
* 선행조건과 후행조건 의에도, 메서드는 부작용(side effect)에 대해서도 문서화 해야 한다.
* 더 이상은 HTML \<code\>나 \<tt\>를 사용할 필요가 없다. Javadoc의 {@code} 태그를 쓰는 편이 더 낫다. HTML의 메타문자를 이스케이프 처리할 필요가 없기 때문이다.
* 메서드에 대한 문서화 주석은 메서드와 클라이언트 사이의 규약(contract)을 간명하게 설명해야 한다.
* 제네릭 자료형이나 메서드에 주석을 달 때는 모든 자료형 인자들을 설명해야 한다.
* enum 자료형에 주석을 달 때는 자료형이나 public 메서드뿐 아니라 상수 각각에도 주석을 달아 주어야 한다.
* 어노테이션 자료형에 주석을 달 때는 자료형뿐 아니라 모든 멤버에도 주석을 달아야 한다. 

## 8장 일반적인 프로그래밍 원칙들

### 규칙 45 지역 변수의 유효범위를 최소화하라
* 지역 변수의 유효범위를 최소화하는 가장 강력한 기법은, 처음으로 사용하는 곳에서 선언하는 것이다.
* 거의 모든 지역 변수 선언에는 초기값(initializer)이 포함되어야 한다.
* while 문보다는 fbr 문을 쓰는 것이 좋다.
* 메서드의 크기를 줄이고 특정한 기능에 집중하라는 것이다. 

### 규칙 46 for 문보다는 for-each 문을 사용하라
* for-each 문은 전통적인 fbr 문에 비해 명료하고 버그 발생 가능성도 적으며, 성능도 fbr 문에 뒤지지 않는다. 
* for-each 미적용
  * 필터링
  * 변환
  * 병렬 순회

### 규칙 47 어떤 라이브러리가 있는지 파악하고, 적절히 활용하라
* 라이브러리를 사용 장점
 * 표준 라이브러리(standard library)를 사용하면 그 라이브러리를 개발한 전문가의 지식뿐만 아니라 여러분보다 먼저 그 라이브러리를 시용한 사람들의 경험을 활용할 수 있다.
 * 실제로 하려는 일과 큰 관련성도 없는 문제에 대한 해결 방법을 임의로 구현하느라 시간을 낭비하지 않아도 된다는 것이다.
 * 여러분이 별다른 노력을 하지 않아도 그 성능이 점차로 개선된다는 것이다.
* 중요한 새 릴리스(major new release)가 나올 때마다 많은 기능이 새로 추가되는데, 그때마다 어떤 것들이 추가되었는지를 알이두는 것이 좋다.
* 자바 프로그래머라면 java.lang, java.util 안에 있는 내용은 잘 알고 있어야 하며, java.io의 내용도 어느 정도 알고 있어야 한다. 
* 바퀴를 다시 발명하지 말라(don,t reinvent the wheel)

### 규칙 48 정확한 답이 필요하다면 float와 double은 피하라
* float와 double은 특히 돈과 관계된 계산에는 적합하지 않다.
* 돈 계산을 할 때는 BigDecimal, int 또는 long을 사용한다는 원칙을 지켜야 한다.
* 성능이 중요하고 소수점 아래 수를 직접 관리해도 상관없으며 계산할 수가 심하게 크지 않을 때는 int나 long을 쓰라
* 관계된 수치
  * 십진수 아홉 개 이하로 표현이 기능할 때는 int를 쓰라. 
  * 18개 이하로 표현 가능할 때는 long을 쓰라.
  * 그 이상일 때는 BigDecimal을 써야 한다.

### 규칙 49 객체화된 기본 자료형 대신 기본 자료형을 이용하라
* 기본 자료형과 객체화된 기본 자료형 차이점
  * 기본 지료형은 값만 가지지만 객체화된 기본 자료형은 값 외에도 신원(identity)을 가진다는 것
  * 기본 자료형에 저장되는 값은 전부 기능적으로 완전한 값(fully functional value)이지만, 객체화된 기본 자료형에 저장되는 값에는 그 이외에도 이무 기능도 없는 값, 즉 null이 하나 있다는 것
  * 기본 자료형은 시간이나 공간 요구량 측면에서 일반적으로 객체 표현형보다 효율적이라는 것
* 객체화된 기본 자료형에 == 연산자를 사용하는 것은 거의 항상 오류라고 봐야 한다.
* 기본자료형과 객체화된 기본 자료형올 한 연산 안에 엮어 놓으면 객체화된 기본 자료형은 자동으로 기본 자료형으로 변환된다.
* 객체화된 기본 자료형
  * 컬렉션의 요소, 키, 값으로 사용할 때다. 컬렉션에는 기본 자료형을 넣을 수 없으므로 객체화된 자료형
  * 형인자 자료형의 형인자료는 객체화된 기본 자료형
  * 리플렉션을 통해 메서드를 호출할 때도 객체화된 기본자료형을 사용
* 자동 객체화는 번거로운 일을 줄여주긴 하지만, 객체화된 기본 자료형을 사용할 때 생길 수 있는 문제들까지 없애주진 않는다.
* 객체화된 기본 자료형과 기본 자료형을 한 표현식 안에 뒤섞으면 비객체화가 자동으로 일어나며, 그 과정에서 NullPointerException이 발생할 수 있다.
* 기본 자료형 값을 객체화하는 과정에서 불필요한 객체들이 만들어지면 프로그램 성능이 저하될 수도 있다.

### 규칙 50 다른 자료형이 적절하다면 문자열 사용은 피하라
* 문자열은 값 자료형(value type)을 대신하기에는 부족하다.
* 적절한 값 자료형이 있다면 그것이 기본 자료형이건 아니면 객체 자료형이건 상관없이 해당 자료형을 사용

### 규칙 51 문자열 연결 시 성능에 주의하라
### 규칙 52 객체를 참조할 때는 그 인터페이스를 사용하라
### 규칙 53 리플렉션 대신 인터페이스를 이용하라
### 규칙 54 네이티브 메서드는 신중하게 사용하라
### 규칙 55 신중하게 최적화하라
### 규칙 56 일반적으로 통용되는 작명 관습을 따르라

## 9장 예외 327
### 규칙 57 예외는 예외적 상황에만 사용하라
### 규칙 58 복구 가능 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류에는 실행시점 예외를 이용하라
### 규칙 59 불필요한 점검지정 예외 사용은 피하라
### 규칙 60 표준 예외를 사용하라
### 규칙 61 추상화 수준에 맞는 예외를 던져라
### 규칙 62 메서드에서 던져지는 모든 예외에 대해 문서를 남겨라
### 규칙 63 어떤 오류인지를 드러내는 정보를 상세한 메시지에 담으라
### 규칙 64 실패 원자성 달성을 위해 노력하라
### 규칙 65 예외를 무시하지 마라

## 10장 병행성
### 규칙 66 변경 가능 공유 데이터에 대한 접근은 동기화하라
### 규칙 67 과도한 동기화는 피하라
### 규칙 68 스레드보다는 실행자와 태스크를 이용하라
### 규칙 69 wait나 notify 대신 병행성 유틸리티를 이용하라
### 규칙 70 스레드 안전성에 대해 문서로 남겨라
### 규칙 71 초기화 지연은 신중하게 하라
### 규칙 72 스레드 스케줄러에 의존하지 마라
### 규칙 73 스레드 그룹은 피하라

## 11장 직렬화
### 규칙 74 Serializable 인터페이스를 구현할 때는 신중하라
### 규칙 75 사용자 지정 직렬화 형식을 사용하면 좋을지 따져 보라
### 규칙 76 readObject 메서드는 방어적으로 구현하라
### 규칙 77 개체 통제가 필요하다면 readResolve 대신 enum 자료형을 이용하라
### 규칙 78 직렬화된 객체 대신 직렬화 프락시를 고려해 보라