# 도메인주도설계

![도메인주도설계](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_0-1.png)

## 01부 동작하는 도메인 모델 만들기
* **사용자가 프로그램을 사용하는 대상 영역이 바로 해당 소프트웨어의 도메인**
* **모델은 지식을 선택적으로 단순화히고 의식적으로 구조화한 형태다.**
* **도메인 모델은 어떤 특정한 다이어그램이 아니라 다이어그램이 전달하고자 하는 아이디어**
* 도메인 모델은 단지 도메인 전문가의 머릿속에만 존재하는 지식이 아니라 해당 지식을 엄격하게구성하고 선택적으로 추상화한 것이다.
* 신중하게 작성된 코드나 우리가 쓰는 문장이 그렇듯 우리는 다이어그램을 이용해 모델을 표현히코 전달할 수 있다.
* 도메인 모델링은 가능한 한 '사실적인' 모델을 만드는 문제가 아니댜 현실 세계에 실재하는 사물에 대한 도메인에서도 모델은 인위적 창조물이다 그리고 단순히 필요한 결과를 내는 소프트웨어 메커니즘을 만드는 것도 아니다
* 모델은 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태

### 도메인 주도 설계에서의 모델의 유용성
1. 모델과 핵심 설계는 서로 영향을 주며 구체화된다.
2. 모델은 모든 팀 구성원이 사용하는 언어의 중추다.
3. 모델은 지식의 정수만을 뽑아낸 것이다.
  * 모델은 도메인 지식을 조직화하고 가장 중요한 요소를 구분하는 팀의 합의된 방식
* 목표
  * 기술보다는 도메인에 대한 모델에 집중해 더 나은 소프트웨어를 만들어내는 것

### 소프트웨어의 본질
* 소프트웨어의 본질은 해당 소프트웨어의 사용자를 위해 도메인에 관련된 문제를 해결하는 능력
* 도메인 업무는 무질서하고 컴퓨터 과학자로서의 능력에 보탬이 될 것 같지 않은 복잡하고 새로운 지식을 많이 요구

### 01장 지식 탐구

#### 효과적인 모델링의 요소
1. 모델과 구현의 연계.
2. 모델을 기반으로 하는 언어 정제.
3. 풍부한 지식이 담긴 모델 개발.
4. 모델의 정제.
5. 브레인스토밍과 실험.

#### 지식 탐구
* 효과적으로 도메인 모델링을 수행하는 사람들도 지식을 면밀히 탐구
1. 엄청난 양의정보 속에서 아주 미미한 관련성을 찾아냄
2. 전체를 이해할 수 있는 간결한 관점을 찾아 체계적인 아이디어들을 차례로 시도
3. 그 과정에서 수많은 모델이 시도 거부 변형
4. 모든 세부사항에 들어 맞는 일련의 추상적 개념이 나타나면 비로소 성공에 이름
5. 이렇게 해서 뽑아낸 정수는 가장 적절한 것으로 밝혀진 특정 지식을 엄밀하게 표현한 것
* 도메인 전문가들은 자신이 알고 있는 지식의 정수만을 추출해내야 하므로 스스로 이해하는 바를 자주 정제하고, 그리하여 소프트웨어 프로젝트에서 요구하는 개념적 엄밀함(conceptual rigor)을 이해하게 됨
* 모델이 점점 향상되면서 모델은 프로젝트 내내 계속해서 흘러가는 정보들을 조직화하는 도구로 자리잡음
* 모델은 결코 완벽해질 수 없으며, 다만 계속 발전해나갈 뿐
* 모델은 쉽게 구현하고 이해하기에 충분할 만큼 엄밀해야함

#### 지속적인 학습
* **우리는 스스로 얼마나 알지 못하는가를 깨닫지 못하는 것이다.**
* 생산성이 매우 뛰어난 팀은 지속적인 학습을 바탕으로 의식적으로 지식을 함양한다.

#### 풍부한 지식이 담긴 설계
* 도메인에 관련된 엔티티 만큼 업무 활동과 규칙도 도메인에 중요한데, 어떠한 도메인에도 다양한 범주의 개념이 존재한다

##### 예제

###### 감춰진 개념 추출하기
* 예약 애플리케이션의 책임이 각 Cargo(화물)를 하나의 Voyage(운항)와 연관관계를 맺고, 것을 기록 관리하는 것

![도메인주도설계](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_1-8.png)

```java
public int makeBooking(Cargo cargo, Voyage voyage) {
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

* 초과예약(overbooking)

![도메인주도설계](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_1-9.png)

```java
public int makeBooking(Cargo cargo, Voyage voyage) {
    double maxBooking = voyage.capacity() * 1.1;
    if ((voyage.bookedCargoSize() + cargo.size()) > maxBooking)
        return=1;
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

* 정책이란 잘 알려진 STRATEGY(Gamma et al. 1995) 디자인 패턴의 또 다른 이름

* 초과예약 별개의 정책

![도메인주도설계](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_1-10.png)

```java
public int makeBooking(Cargo cargo, Voyage voyage) {
    if (!overbookingPolicy.isAllowed(cargo, voyage)) return -1;
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

```java
public boolean isAllowed(Cargo calgo, Voyage voyage) {
    return (cargo.size() + voyage.bookedCargoSize()) <= (voyage.capacity() * 1.1);
}
```

#### 심층 모델
* 유용한 모델은 겉으로 드러나 있는 경우가 거의 없음
* 도메인과 애플리케이션의 요구사항을 이해하게 되면서 대체로 처음에 중요하게 생각했던 피상적인 모델 요소를 버리거나 관점을 바꿈
* 처음에는 나타나기 힘들지만 문제의 핵심을 관통하는 포착하기 힘든 추상화가 서서히 나타나기 시작

### 02장 의사소통과 언어 사용
* 모델 기반 의사소통은 통합 모델링 언어(Unined Modeling Language, UML)상의 다이어그램으로 한정돼서는 안 됨
* 모델을 가장 효과적으로 사용하려면 모든 의사소통 수단에 스며들 필요가 있음

#### UBIQUITOUS LANGUAGE (보편 언어)
* 공통 언어가 없는 프로젝트에서는 개발자가 도메인 전문가를 위해 자신들의 언어를 번역
* 도메인 전문가도 개발자 간의, 그리고 다른 도메인 전문가 간의 언어를 번역
* 프로젝트에서 사용하는 언어가 분열되면 심각한 문제가 발생한다. 도메인 전문가는 자신의 전문 용어를 사용하고 기술적인 업무를 맡은 팀원들은 설계 측면에서 도메인에 관한 토론에 적합한 자신들만의 언어를 사용
* 일상적인 토론에서 쓰이는 용어가 코드(궁극적으로 가장 중요한 소프트웨어 프로젝트 산출물)에 녹아든 용어와 단절된다. 그리고 같은 사람인데도 말할 때나 글을 쓸 때 서로 다른 용어를써서 도메인의 가장 간결히고 명확한 표현이 일시적인 형태로 나타났다가 코드나 문서에도 담기지 않는 결괴카 나타나기도 함
* 번역은 의사소통을 무디게 하고 지식 탐구를 빈약하게 만듬
* 일부 사람들만 쓰는 언어는 모두의 필요를 충족하지 못히므로 공통 언어가 될 수 없음
* 모델을 언어의 근간으로 사용하라. 팀 내 모든 의사소통과 코드에서 해당 언어를 끊임없이 적용하는데 전념하라.
* 다이어그램과 문서에서, 그리고 특히 말할 때 동일한 언어를 사용하라.
* 대안 모델을 반영하는 대안이 되는 표현을 시도해 봄으로써 어려움을 해소하라.
* 새로운 모델에 맞게끔 클래스, 메서드, 모듈의 이름을 다시 지으면서 코드를 리팩터링하라.
* 일상적으로 쓰는 단어의 의미에 동의를 이끌어내는 것과 같은 방식으로 대화할 때 쓰는 용어의 혼란도 해결하라.
* UBIQUITOUS LANGUAGE의 변화가 곧 모델의 변화라는 것을 인식하라.
* 도메인 전문가는 도메인을 이해하는 데 부자연스럽고 부정확한 용어나 구조에 대해 반대 의사를 표명해야 한다.
* 개발자는 설계를 어렵게 만드는 모호함과 불일치를 찾아내는 데 촉각을 곤두세워야 한다.

##### 예졔

###### 화물의 운송 항로 고안하기
* 시나리오1 : 도메인에 대한 최소한의 추상화

![도메인주도설계](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_2-1.png)

* 시나리오2 : 논의를 돕는 풍성한 도메인 모델

![도메인주도설계](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_2-2.png)

#### 크게 소리내어 모델링하기
* 시스템에 관해 이야기를 주고받을 때 모델을 사용하라.
* 모델의 요소와 싱호작용을 이용하고 모델이 허용하는 범위에 개념을 조합하면서 시나리오를 큰 소리로 말해보라.
* 표현해야 할 것을 더 쉽게 말하는 방법을 찾아낸 다음 그러한 새로운 아이디 어를 다이어 그램과 코드에 적용하라.

#### 한 팀, 한 언어
* 수준 높은 도메인 전문가도 해당 모델을 이해하지 못한다면 모델이 뭔가 잘못된 것이다.
* UBIQUITOUS LANGUAGE가 마련되면 개발자 간의 대화, 도메인 전문가 간의 논의, 코드 자체에 포함된 표현까지 이 모든 것이 공유된 도메인 모델에서 비롯된 동일한 언어를 기반

![도메인주도설계](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_2-3.png)

#### 문서와 다이어그램
* 간결히고 형식에 얽매이지 않은 UML 다이어그램은 논의의 구심점 역할을 할 수 있음
* 설계의 생생한 세부사항은 코드에 담김
* 모델은 다이어그램이 아니라는 점을 항상 명심

##### 글로 쓴 설계 문서
* **문서는 코드와 말을 보완하는 역할을 해야 한다**
* 문서는 코드가 이미 잘 히고 있는 것을 하려고 해서는 안 된다.
* **문서는 유효한 상태를 유지하고 최신 내용을 담고 있어야 한다**
* 문서는 프로젝트 활동과 관련을 맺고 있어야 한다.

##### 실행 가능한 기반
* 올바르게 실행되는 것뿐만 아니라 올바른 의미를 전달하는 코드를 작성히자면 엄청나게 세심한 노력을 기울어야 한다.

#### 설명을 위한 모델
* 모델이 구현, 설계, 의사소통의 기초가 돼야 한다는 것
* 모델은 도메인을 가르치는 도구로도 아주 유용할 수 있다.
* 다른 모델이 필요한 이유 가운데 특별한 한 가지는 바로 범위 때문
* 설명을 위한 모델이 꼭 객체 모델일 필요는 없으며, 오히려 그렇지 않을 때가 일반적으로 가장 좋다.

#### 예제

##### 해운 활동과 항로

![운송 항로를 나타내는 클래스 다이어그램](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_2-4.png)

![운송 항로에 대한 설명을 위한 모델](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_2-5.png)

### 03장 모델과 구현의 연계

#### MODEL-DRIVEN DESIGN (모델 주도 설계)
* 설계 혹은 설계의 주된 부분이 도메인 모델과 대응하지 않는다면 그 모델은 그다지 가치가 없으며 소프트웨어의 정확힘도 의심스러워진다. 동시에 모델과 설계 기능 사이의 복잡한 대응은 이해하기 힘들고, 실제로 설계가 변경되면 유지보수가 불가능해진다. 분석과 설계가 치명적으로 동떨어 지고, 그에 따라 각자의 활동에서 얻은 통찰력이 서로에게 전해지지 않는다.
* 모델로부터 설계와 기본적인 책임 할당에 사용한 용어를 도출하라. 코드를 작성할 때 그러한 용어를 사용하면 코드가 모델을 표현한 것이 되고, 코드의 변경이 곧 모델의 변경으로 이어질 수 있다. 그 효과는 프로젝트의 나머지 활동에도 퍼져나가야 한다.
* 구현을 모델과 그대로 묶으려면 보통 객체지향 프로그래밍과 같은 모델링 패러다임을 지원하는 소프트웨어 개발 도구와 언어가 필요하다.

#### 모델링 패러다임과 도구 지원
* 객체지향 프로그래밍은 모델링 패러다임에 근거히고 모델의 구성요소에 대한 구현을 제공하기 때문에 매우 효과적
* 객체 설계에서의 진정한 도약은 코드가 모델의 개념을 표현할 때 나옴
* 도메인의 중요한 개념만 추출해서 간결하고 예리한 모델로 표현하려면 리팩터링과 지식 탐구의 과정을 수차례에 걸쳐 반복해야 할 것

##### 예제

###### 기계적인 설계
* 풍부한 기능과 싱호작용을 원한다면 그에 상응하는 대가를 빠짐 없이 치러야 할 것

###### 모델 주도 설계

#### 내부 드러내기: 왜 모델이 사용자에게 중요한가

#### HANDS-ON MODELER (실천적 모델러)

## 02부 모델 주도 설계의 기본 요소

### 04장 도메인의 격리

#### LAYERED ARCHITECTURE (계층형 아키텍처)

| | |
| 사용자 인터페이스 (또는 표현 계층) | 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 일을 책임진다. 간혹 사람이 아닌 다른 컴퓨터 시스템이 외부 행위자가 되기도 한다. |
| 응용 계층 | 소프트웨어가 수행할 작업을 정의하고 표현력 있는 도메인 객체가 문제를 해결하게 한다. 이 계층에서 책임지는 작업은 업무상 중요하거나 다른 시스템의 응용 계층과 상호작용하는데 필요한 것들이다. 이 계층은 얇게 유지된다. 여기에는 업무 규칙이나 지식이 포함되지 않으며, 오직 작업을 조경하고 아래에 위치한 계층에 포함된 도메인 객체의 협력자에거l 작업을 위임한다. 응용 계층에서는 업무 상황을 반영하는 상태가 없지만 사용자나 프로그램의 작업에 대한 진행상황을 반영하는 상태를 가질 수는 있다. |
| 도메인 계층 (또는 모델 계층) | 업무 개념과 업무 상황에 관한 정보, 업무 규칙을 표현하는 일을 책임진다 이 계층에서는 업무 상황을 반영하는 상태를 제어하고 사용하며, 그와 갇은 상태 저장과 관련된 기술적인 세부사항은 인프라스트럭처에 위입한다 이 계층은 업무용 소프트웨어의 핵심이다. |
| 인프라스트럭처 계층 | 상위 계층을 지원하는 일반화된 기술적 기능을 제공한댜 이러한 기능에는 애플리케이션에 대한 메시지 전송, 도메인 영속화, UI에 위젯을 그리는 것 등이 있다 또한 인프라스트럭처 계층은 아키텍처 프러l잉워크를 통해 네 가지 계층에 대한 상호작용 패턴을 지원할 수도 있다. |

##### 계층 간 관계 설정
* 각 계층은 설계 의존성을 오직 한 방향으로만 둬서 느슨하게 결합된다.
* 상위 계층은 하위 계층의 공개 인터페이스를 호출하고 하위 계층에 대한 침조를 가지며(최소한 임시로리도), 그리고 일반적으로 관례적인 상호작용 수단을 이용해 하위 계층의 구성요소를 직접적으로 사용하거나 조작할 수 있다.
* 보통 인프라스트럭처 계층에서는 도메인 계층에서 어떤 활동이 일어나게 하지 않는다.

##### 아키텍처 프레임워크

#### 도메인 계층은 모델이 살아가는 곳

#### SMART UI(지능형 UI) "안티 패턴"

#### 다른 종류의 격리

### 05장 소프트웨어에서 표현되는 모델

#### 연관관계
* 모델 내의 모든 팀책 가능한(traversable) 연관관계에 대해 그것과 동일한 특성을 지닌 메커니즘이 소프트웨어에도 있다.

#### ENTITY (엔티티, 참조객체라고도 함)
* 수많은 객체는 본질적으로 해당 객체의 속성이 아닌 연속성과 식별성이 이어지느냐를 기준으로 정의 된다.

##### ENTITY 모델링

##### 별 연산의 설계

#### VALUE OBJECT (값 객체)

##### VALUE OBJECT의 설계
* 공유를 제한
  * 공간을 절약하거나 데이터베이스 내의 객체 수를 줄이는 것이 중요한 경우
  * 통신 부하가 낮은 경우(이를테면, 중앙집중형 서버)
  * 공유 객체의 불변성이 엄격하게 지켜지는 경우
* 변경가능성을 허용하는 경우
  * VALUE가 자주 변경되는 경우
  * 객체 생성이나 삭제에 비용이 많이 드는 경우
  * 교체(변경이아닌)로 인해 클리스터링이 제한되는 경우
  * VALUE를 공유할 일이 그리 많지 않거나 클리스터링을 향상시키기 위해서나 댜른 기술적인 이유로 공유가 보류된 경우

##### VALUE OBJECT를 포함한 연관관계 설계

#### SERVICE(서비스)

##### SERVICE와 격리된 도메인 계층

##### 구성 단위

##### SERVICE에 접근하기

#### MODULE(모듈, 패키지라고도 함)

##### 기민한 MODULE

##### 인프라스트럭처 주도 패키지화의 함정

#### 모델링 패러다임

##### 객체 패러다임이 지배적인 이유

##### 객체 세계에서 객체가 아닌 것들

##### 패러다임이 혼재할 때 MODEL-DRIVEN DESIGN 고수하기

### 06장 도메인 객체의 생명주기

#### AGGREGATE (집합)

#### FACTORY (팩터리)

##### FACTORY와 FACTORY의 위치 선정

##### 생성자만으로 충분한 경우
* 클래스가 타입인 경우. 클래스가 어떤 계층구조의 일부를 구성하지 않으며, 인터페이스를 구현하는 식으로 다형적으로 사용되지 않는 경우.
* 클라이언트가 STRATEGY를 선택하는 한 방법으로서 구현체에 관심이 있는 경우
* 클라이언트가 객체의 속성을 모두 이용할 수 있어서 클라이언트에게 노출된 생성자 내에서 객체 생성이 중첩되지 않는 경우
* 생성자가 복잡하지 않은 경우
* 공개 생성자가 FACTORY와 동일한 규칙을 반드시 준수해야 하는 경우 이때 해당 규칙은 생성된 객체의 모든 불변식을 충족하는 원자적인 연산이어야 한다.

##### 인터페이스 설계

##### 불변식 로직의 위치

##### ENTITY FACTORY와 VALUE OBJECT FACTORY
* 차이점
  * VALUE OBJECT는 불변적
  * ENTITY에는 식별성 할당과 관련된 쟁점이 있다는 것

##### 저장된 객체의 재구성
* FACTORY는 객체의 생성과 재구성이라는 생명주기 전이(transition)를 캡슐화
* 저장소에 들어갈 때와 저징소에서 나올 때 거치는 전이가 있다. 이러한 전이는 또 다른 도메인 설계 구조물인 REPOSITORY의 책임

#### REPOSITORY (리파지터리)
* 연관관계의 응집성과 검색의 분리는 상층 관계에 있다.
* 저장돼 있는 객체로부터 인스턴스를 만들어 내는 것을 재구성(reconstitution)이라고 한다.
* **도메인 주도 설계의 목표는 기술보다는 도메인에 대한 모델에 집중해 더 나은 소프트웨어를 만들어내는 것이다**
* AGGREGATE 내부에 존재하는 모든 객체는 루트에서부터 탐색을 토대로 접근하는 것 말고는 접근이 금지돼 있다는 점이다.

##### REPOSITORY에 질의하기

##### 클라이언트 코드가 REPOSITORY 구현을 무시한다 (개발자는 그렇지 않지만)

##### REPOSITORY 구현

##### 프레임워크의 활용

##### FACTORY와의 관계

#### 관계형 데이터베이스를 위한 객체 설계

### 07장 언어의 사용(확장 예제)

#### 화물 해운 시스템 소개

![도메인주도설계](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_7-1.png)

#### 도메인 격리: 응용 기능 소개
* 도메인의 책임이 시스템의 다른 부분과 섞이는 것을 방지하고자 LAYERED ARCHITECTURE를 적용해 도메인 계층을 구별

#### ENTITY와 VALUE OBJECT의 구분

##### 역할과 그 밖의 속성
* 역할은 그것이 한정하는 연관관계에 관한 사항을 전해주지만 이력이나 연속성을 지니고 있지는 않다.

#### 해운 도메인의 연관관계 설계

![도메인주도설계](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_7-2.png)

#### AGGREGATE의 경계

![도메인주도설계](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_7-3.png)

#### REPOSITORY의 선정
* 전제는 모두 바뀔 수 있으므로 만약 전제가 바뀌었다면 REPOSITORY를 추가할 것

![도메인주도설계](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_7-4.png)

#### 시나리오 연습

##### 예제 애플리케이션 기능: 화물의 목적지 변경

##### 예제 애플리케이션 기능: 반복 업무

#### 객체 생성

##### Cargo에 대한 FACTORY와 생성자

##### Handling Event 추가

#### 리팩터링할 시간: Cargo AGGREGATE의 설계 대안

#### 해운 모델의 MODULE

#### 새로운 기능 도입: 할당량 검사

##### 두 시스템의 연계

##### 모델 강화: 업무 분야 나누기

##### 성능 최적화

#### 최종 검토

## 03부 더 심층적인 통찰력을 향한 리팩터링
1. 정교한 도메인 모델은 만들 수 있으며, 노력을 들일 만한 가치가 있다.
2. 해당 도메인을 학습하는 개발자와 도메인 전문가의 긴밀한 참여와 반복적인 리팩터링 과정 없이 유용한 모델을 개발하기란 쉽지 않다.
3. 유용한 모델을 효과적으로 구현하고 사용하려면 정교한 설계 기술이 필요할지도 모른다.

### 리팩터링 수준

### 심층 모델
* 심층모델(deepmodel)이란 도메인의 피상적인 측면은 배제하고 도메인 전문가의 주요 관심사와 가장 적절한 지식을 알기 쉽게 표현하는 모델

### 심층 모델/유연한 설계

### 발견 과정

### 08장 도약

#### 도약에 관한 일화

##### 괜찮은 모델이기는 하지만……

##### 도약

##### 더 심층적인 모델

##### 냉정한 결정

##### 결말

#### 기회

#### 기본에 집중하라

#### 후기 : 연이은 새로운 통찰력의 출현
* 심층 모델로의 진정한 도약을 거치고 나면 새로운 설계의 명확성과 단순함이 새로운 UBIQUITOUS LANGUAGE를 기빈으로 한 개선된 의사소통과 결합되어 또 다른 모델링 도약으로 이어지는 사례가 자주 발생

### 09장 암시적인 개념을 명확하게
* 개발자들이 토의 중에 단서를 얻거나 설계상에 암시적으로 존재하는 개념을 인지하면 도메인 모델과 관련 코드를 대량으로 변환하게 되며, 그 후 하나 이상의 객체와 객체 간의 관계를 활용해 모델 내에 해당 개념을 명확하게 표현하게 된다.

#### 개념 파헤치기

##### 언어에 귀 기울여라

##### 예제

###### 해운 모델의 누락된 개념에 귀 기울이기

##### 어색한 부분을 조사하라

##### 예제

###### 이자 수익 예제 - 어려운 방식으로 접근하기

##### 모순점에 대해 깊이 고민하라

##### 서적을 참고하라

##### 시도하고 또 시도하라

#### 다소 불명확한 개념의 모델링

##### 명시적인 제약조건
* 제약조건을 자체적인 메서드로 분리하면 제약조건에 의도를 드러내는 이름을 부여해서 설계 내에 제약 조건을 명확하게 표현할 수 있음
* 제약조건이 객체가 담당하는 기본 책임을 모호하게 만들거나 제약조건이 도메인과 관련된 대화에서는 중요한 개념으로 디뤄지지만 모델 내에 명확하게 표현돼 있지 않다면 제약조건을 명시적인 객체로 분리하거나, 나아가 일련의 객체와 관계의 집합으로 모델링할 수 있음

```java
class Bucket {
  private float capacity;
  private float contents;

  publiv void pourIn(float addedVolume) {
    if(contents + addedVolume > capacity) {
      contents = capacity;
    } else {
      contents = contents + addedVolume;
    }
  }
}
```

```java
class Bucket
  plivate float capacity;
  prlvate float contents;

  public void pourIn(float addedVolume) {
    float volumePresent = contents + addedVolume;
    contents = constrainedToCapacity(volumePresent);
  }

  private float constrainedToCapacity(float volumePlacedIn) {
    if (volumePlacedIn > capacity) return capacity;
    return volumePlacedIn;
  }
}
```

* 제약조건을 포함한 객체의 설계가 어딘가 잘못돼 있음을 나타내는 조짐
1. 제약조건을 평가하려면 해당 객체의 정의에 적합하지 않은 데이터가 필요하다.
2. 관련된 규칙이 여러 객체에 걸쳐 나타나며, 동일한 계층구조에 속하지 않는 객체 간에 중복 또는 상속 관계를 강요한다.
3. 설계와 요구사항에 관한 다양한 논의는 제약조건에 초점을 맞춰 이뤄지지만 정작 구현 단계에서는 절차적인 코드에 묻혀 명시적으로 표현되지 않는다.

##### 예제

###### 설계 검토: 초과 예약 정책

##### 도메인 객체로서의 프로세스

#### SPECIFICATION (명세)

##### SPECIFICATION의 적용과 구현

### 10장 유연한 설계

![도메인주도설계](/assets/images/books/컴퓨터공학/소프트웨어공학/도메인주도설계/figure_10-1.png)

#### INTENTION-REVEALING INTERFACE (의도를 드러내는 인터페이스)

#### SIDE-EFFECT-FREE FUNCTION (부수효과가 없는 함수)
* 연산은 크게 명령(command)과 질의(query)라는 두 가지 범주로 나눔
* 질의는 변수 안에 저장된 데이터에 접근하거나, 저장된 데이터를 기반으로 계산을 수행해서 시스템으로부터 정보를 얻는 연산을 의미
* 명령(또는 변경자(modiher)라고도 한다)은 변수의 값을 변경하는 등의 작업을 통해 시스템의 상태를 변경하는 연산을 의미
* 부수효과를 일으키지 않으면서 결과를 반환하는 연산을 함수(function)함

#### ASSERTION (단정)

#### CONCEPTUAL CONTOUR (개념적 윤곽)
* 도메인을 중요 영역올 나누는 것과 관련한 직관을 감안해서 설계요소(연산,인터페이스, 클래스, AGGREGATE)를 응집력 있는 단위로 분해하라
* 계속적인 리팩터링을 토대로 변경되는 부분과 변경되지 않는 부분을 나누는 중심 축을 식별하고, 변경을 분리하기 위한 패턴을 명확하게 표현하는 CONCEPTUAL CONTOUR를 찾아라
* 우선적으로 확실한 지식 영역을 구성하는 도메인의 일관성 있는 측면과 모델을 조화시켜라

#### STANDALONE CLASS (독립형 클래스)

#### CLOSURE OF OPERATION (연산의 닫힘)

#### 선언적 설계

##### 도메인 특화 언어

#### 선언적인 형식의 설계

##### SPECIFICATION을 선언적인 형식으로 확장하기

#### 받음각

##### 서브 도메인으로 분할하라

##### 가능하다면 정립된 정형화를 활용하라

### 11장 분석 패턴의 적용

### 12장 모델과 디자인 패턴의 연결

#### STRATEGY (POLICY라고도 함)

#### COMPOSITE (복합체)

#### 그렇다면 FLYWEIGHT는?

### 13장 더 심층적인 통찰력을 향한 리팩터링

#### 시작

#### 조사팀

#### 선행 기술

#### 개발자를 위한 설계

#### 타이밍

#### 위기를 기회로

## 04부 전략적 설계

### 14장 모델의 무결성 유지

#### BOUNDED CONTEXT (제한된 컨텍스트)

##### BOUNDED CONTEXT 안의 균열 인식

#### CONTINUOUS INTEGRATION (지속적인 통합)

#### CONTEXT MAP (컨텍스트 맵)

##### CONTEXT 경계에서의 테스트

##### CONTEXT MAP의 조직화와 문서화

#### BOUNDED CONTEXT 간의 관계

#### SHARED KERNEL (공유 커널)

#### CUSTOMER/SUPPLIER DEVELOPMENTTEAM (고객/공급자 개발 팀)

#### CONFORMIST (준수자)
* CONFORMIST는 동일한 모델을 이용하는 영역과 추가를 통해 모델을 확장한 영역, 다른 모델이 영향을 미치는 영역을 보유한다는 점에서 SHARED KERNEL과 유사

#### ANTICORRUPTION LAYER (오류 방지 계층)

##### ANTICORRUPTION LAYER의 인터페이스 설계

##### ANTICORRUPTION LAYER의 구현

##### 교훈적인 이야기

#### SEPARATE WAYS (각자의 길)

#### OPEN HOST SERVICE (공개 호스트 서비스)

#### PUBLISHED LANGUAGE (공표된 언어)

#### 코끼리 통일하기

#### 모델의 컨텍스트 전략 선택

##### 팀 의사결정 또는 그 이상

##### 우리 자신을 컨텍스트에 배치하기

##### 경계의 변형

##### 변경할 수 없다는 사실을 인정하기: 외부 시스템의 묘사

##### 외부 시스템과의 관계

##### 설계 중인 시스템

##### 개별 모델의 특수한 요구사항 충족하기

##### 배치

##### 타협점

##### 프로젝트가 이미 진행 중일 때

#### 변형

##### CONTEXT 병합: SEPARATE WAYS → SHARED KERNEL

##### CONTEXT 병합: SHARED KERNEL → CONTINUOUS INTEGRATION

##### 레거시 시스템의 단계적 폐기

##### OPEN HOST SERVICE → PUBLISHED LANGUAGE

### 15장 디스틸레이션

#### CORE DOMAIN (핵심 도메인)

##### CORE 선택

##### 누가 그 일을 할 것인가?

#### 디스틸레이션의 단계적 확대

#### GENERIC SUBDOMAIN (일반 하위 도메인)

##### 일반화가 재사용 가능하다는 의미는 아니다

##### 프로젝트 위험 관리

#### DOMAIN VISION STATEMENT (도메인 비전 선언문)

#### HIGHLIGHTED CORE (강조된 핵심)

##### 디스틸레이션 문서

##### 표시된 CORE

##### 프로세스 도구로서의 디스틸레이션 문서

#### COHESIVE MECHANISM (응집력 있는 메커니즘)

##### GENERIC SUBDOMAIN과 COHESIVE MECHANISM

##### MECHANISM이 CORE DOMAIN의 일부인 경우

#### 선언적 형식의 디스틸레이션

#### SEGREGATED CORE (분리된 핵심)

##### SEGREGATED CORE를 만드는 데 드는 비용

##### 발전하는 팀의 의사결정

#### ABSTRACT CORE (추상화된 핵심)

#### 심층 모델의 디스틸레이션

#### 리팩터링의 대상 선택

### 16장 대규모 구조

#### EVOLVING ORDER (발전하는 질서)

#### SYSTEM METAPHOR (시스템 은유)

##### "미숙한 은유"와 그것이 필요 없는 이유

#### RESPONSIBILITY LAYER (책임 계층)

##### 적절한 계층의 선택

#### KNOWLEDGE LEVEL (지식 수준)

#### PLUGGABLE COMPONENT FRAMEWORK (착탈식 컴포넌트 프레임워크)

#### 구조는 얼마나 제약성을 지녀야 하는가?

#### 잘 맞아떨어지는 구조를 향한 리팩터링

##### 최소주의

##### 의사소통과 자기 훈련

##### 재구조화가 유연한 설계를 낳는다

##### 디스틸레이션은 부하를 줄인다

### 17장 전략의 종합

#### 대규모 구조와 BOUNDED CONTEXT와의 결합

#### 대규모 구조와 디스틸레이션과의 결합

#### 평가 먼저

#### 누가 전략을 세우는가?

##### 애플리케이션 개발에서 창발하는 구조

##### 고객(애플리케이션 개발팀) 중심의 아키텍처 팀

#### 전략적 설계 결정을 위한 6가지 필수 요소

##### 기술 프레임워크도 마찬가지다

##### 종합계획을 조심하라
